"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/appwrite";
exports.ids = ["vendor-chunks/appwrite"];
exports.modules = {

/***/ "(ssr)/./node_modules/appwrite/dist/esm/sdk.js":
/*!***********************************************!*\
  !*** ./node_modules/appwrite/dist/esm/sdk.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AppwriteException: () => (/* binding */ AppwriteException),\n/* harmony export */   AuthenticationFactor: () => (/* binding */ AuthenticationFactor),\n/* harmony export */   AuthenticatorType: () => (/* binding */ AuthenticatorType),\n/* harmony export */   Avatars: () => (/* binding */ Avatars),\n/* harmony export */   Browser: () => (/* binding */ Browser),\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   Condition: () => (/* binding */ Condition),\n/* harmony export */   CreditCard: () => (/* binding */ CreditCard),\n/* harmony export */   Databases: () => (/* binding */ Databases),\n/* harmony export */   ExecutionMethod: () => (/* binding */ ExecutionMethod),\n/* harmony export */   ExecutionStatus: () => (/* binding */ ExecutionStatus),\n/* harmony export */   ExecutionTrigger: () => (/* binding */ ExecutionTrigger),\n/* harmony export */   Flag: () => (/* binding */ Flag),\n/* harmony export */   Functions: () => (/* binding */ Functions),\n/* harmony export */   Graphql: () => (/* binding */ Graphql),\n/* harmony export */   ID: () => (/* binding */ ID),\n/* harmony export */   ImageFormat: () => (/* binding */ ImageFormat),\n/* harmony export */   ImageGravity: () => (/* binding */ ImageGravity),\n/* harmony export */   Locale: () => (/* binding */ Locale),\n/* harmony export */   Messaging: () => (/* binding */ Messaging),\n/* harmony export */   OAuthProvider: () => (/* binding */ OAuthProvider),\n/* harmony export */   Operator: () => (/* binding */ Operator),\n/* harmony export */   Output: () => (/* binding */ Output),\n/* harmony export */   Permission: () => (/* binding */ Permission),\n/* harmony export */   Query: () => (/* binding */ Query),\n/* harmony export */   Realtime: () => (/* binding */ Realtime),\n/* harmony export */   Role: () => (/* binding */ Role),\n/* harmony export */   Storage: () => (/* binding */ Storage),\n/* harmony export */   TablesDB: () => (/* binding */ TablesDB),\n/* harmony export */   Teams: () => (/* binding */ Teams),\n/* harmony export */   Theme: () => (/* binding */ Theme),\n/* harmony export */   Timezone: () => (/* binding */ Timezone)\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\n\n/**\n * Helper class to generate query strings.\n */\nclass Query {\n    /**\n     * Constructor for Query class.\n     *\n     * @param {string} method\n     * @param {AttributesTypes} attribute\n     * @param {QueryTypes} values\n     */\n    constructor(method, attribute, values) {\n        this.method = method;\n        this.attribute = attribute;\n        if (values !== undefined) {\n            if (Array.isArray(values)) {\n                this.values = values;\n            }\n            else {\n                this.values = [values];\n            }\n        }\n    }\n    /**\n     * Convert the query object to a JSON string.\n     *\n     * @returns {string}\n     */\n    toString() {\n        return JSON.stringify({\n            method: this.method,\n            attribute: this.attribute,\n            values: this.values,\n        });\n    }\n}\n/**\n * Filter resources where attribute is equal to value.\n *\n * @param {string} attribute\n * @param {QueryTypes} value\n * @returns {string}\n */\nQuery.equal = (attribute, value) => new Query(\"equal\", attribute, value).toString();\n/**\n * Filter resources where attribute is not equal to value.\n *\n * @param {string} attribute\n * @param {QueryTypes} value\n * @returns {string}\n */\nQuery.notEqual = (attribute, value) => new Query(\"notEqual\", attribute, value).toString();\n/**\n * Filter resources where attribute is less than value.\n *\n * @param {string} attribute\n * @param {QueryTypes} value\n * @returns {string}\n */\nQuery.lessThan = (attribute, value) => new Query(\"lessThan\", attribute, value).toString();\n/**\n * Filter resources where attribute is less than or equal to value.\n *\n * @param {string} attribute\n * @param {QueryTypes} value\n * @returns {string}\n */\nQuery.lessThanEqual = (attribute, value) => new Query(\"lessThanEqual\", attribute, value).toString();\n/**\n * Filter resources where attribute is greater than value.\n *\n * @param {string} attribute\n * @param {QueryTypes} value\n * @returns {string}\n */\nQuery.greaterThan = (attribute, value) => new Query(\"greaterThan\", attribute, value).toString();\n/**\n * Filter resources where attribute is greater than or equal to value.\n *\n * @param {string} attribute\n * @param {QueryTypes} value\n * @returns {string}\n */\nQuery.greaterThanEqual = (attribute, value) => new Query(\"greaterThanEqual\", attribute, value).toString();\n/**\n * Filter resources where attribute is null.\n *\n * @param {string} attribute\n * @returns {string}\n */\nQuery.isNull = (attribute) => new Query(\"isNull\", attribute).toString();\n/**\n * Filter resources where attribute is not null.\n *\n * @param {string} attribute\n * @returns {string}\n */\nQuery.isNotNull = (attribute) => new Query(\"isNotNull\", attribute).toString();\n/**\n * Filter resources where attribute is between start and end (inclusive).\n *\n * @param {string} attribute\n * @param {string | number} start\n * @param {string | number} end\n * @returns {string}\n */\nQuery.between = (attribute, start, end) => new Query(\"between\", attribute, [start, end]).toString();\n/**\n * Filter resources where attribute starts with value.\n *\n * @param {string} attribute\n * @param {string} value\n * @returns {string}\n */\nQuery.startsWith = (attribute, value) => new Query(\"startsWith\", attribute, value).toString();\n/**\n * Filter resources where attribute ends with value.\n *\n * @param {string} attribute\n * @param {string} value\n * @returns {string}\n */\nQuery.endsWith = (attribute, value) => new Query(\"endsWith\", attribute, value).toString();\n/**\n * Specify which attributes should be returned by the API call.\n *\n * @param {string[]} attributes\n * @returns {string}\n */\nQuery.select = (attributes) => new Query(\"select\", undefined, attributes).toString();\n/**\n * Filter resources by searching attribute for value.\n * A fulltext index on attribute is required for this query to work.\n *\n * @param {string} attribute\n * @param {string} value\n * @returns {string}\n */\nQuery.search = (attribute, value) => new Query(\"search\", attribute, value).toString();\n/**\n * Sort results by attribute descending.\n *\n * @param {string} attribute\n * @returns {string}\n */\nQuery.orderDesc = (attribute) => new Query(\"orderDesc\", attribute).toString();\n/**\n * Sort results by attribute ascending.\n *\n * @param {string} attribute\n * @returns {string}\n */\nQuery.orderAsc = (attribute) => new Query(\"orderAsc\", attribute).toString();\n/**\n * Sort results randomly.\n *\n * @returns {string}\n */\nQuery.orderRandom = () => new Query(\"orderRandom\").toString();\n/**\n * Return results after documentId.\n *\n * @param {string} documentId\n * @returns {string}\n */\nQuery.cursorAfter = (documentId) => new Query(\"cursorAfter\", undefined, documentId).toString();\n/**\n * Return results before documentId.\n *\n * @param {string} documentId\n * @returns {string}\n */\nQuery.cursorBefore = (documentId) => new Query(\"cursorBefore\", undefined, documentId).toString();\n/**\n * Return only limit results.\n *\n * @param {number} limit\n * @returns {string}\n */\nQuery.limit = (limit) => new Query(\"limit\", undefined, limit).toString();\n/**\n * Filter resources by skipping the first offset results.\n *\n * @param {number} offset\n * @returns {string}\n */\nQuery.offset = (offset) => new Query(\"offset\", undefined, offset).toString();\n/**\n * Filter resources where attribute contains the specified value.\n *\n * @param {string} attribute\n * @param {string | string[]} value\n * @returns {string}\n */\nQuery.contains = (attribute, value) => new Query(\"contains\", attribute, value).toString();\n/**\n * Filter resources where attribute does not contain the specified value.\n *\n * @param {string} attribute\n * @param {string | any[]} value\n * @returns {string}\n */\nQuery.notContains = (attribute, value) => new Query(\"notContains\", attribute, value).toString();\n/**\n * Filter resources by searching attribute for value (inverse of search).\n * A fulltext index on attribute is required for this query to work.\n *\n * @param {string} attribute\n * @param {string} value\n * @returns {string}\n */\nQuery.notSearch = (attribute, value) => new Query(\"notSearch\", attribute, value).toString();\n/**\n * Filter resources where attribute is not between start and end (exclusive).\n *\n * @param {string} attribute\n * @param {string | number} start\n * @param {string | number} end\n * @returns {string}\n */\nQuery.notBetween = (attribute, start, end) => new Query(\"notBetween\", attribute, [start, end]).toString();\n/**\n * Filter resources where attribute does not start with value.\n *\n * @param {string} attribute\n * @param {string} value\n * @returns {string}\n */\nQuery.notStartsWith = (attribute, value) => new Query(\"notStartsWith\", attribute, value).toString();\n/**\n * Filter resources where attribute does not end with value.\n *\n * @param {string} attribute\n * @param {string} value\n * @returns {string}\n */\nQuery.notEndsWith = (attribute, value) => new Query(\"notEndsWith\", attribute, value).toString();\n/**\n * Filter resources where document was created before date.\n *\n * @param {string} value\n * @returns {string}\n */\nQuery.createdBefore = (value) => Query.lessThan(\"$createdAt\", value);\n/**\n * Filter resources where document was created after date.\n *\n * @param {string} value\n * @returns {string}\n */\nQuery.createdAfter = (value) => Query.greaterThan(\"$createdAt\", value);\n/**\n * Filter resources where document was created between dates.\n *\n * @param {string} start\n * @param {string} end\n * @returns {string}\n */\nQuery.createdBetween = (start, end) => Query.between(\"$createdAt\", start, end);\n/**\n * Filter resources where document was updated before date.\n *\n * @param {string} value\n * @returns {string}\n */\nQuery.updatedBefore = (value) => Query.lessThan(\"$updatedAt\", value);\n/**\n * Filter resources where document was updated after date.\n *\n * @param {string} value\n * @returns {string}\n */\nQuery.updatedAfter = (value) => Query.greaterThan(\"$updatedAt\", value);\n/**\n * Filter resources where document was updated between dates.\n *\n * @param {string} start\n * @param {string} end\n * @returns {string}\n */\nQuery.updatedBetween = (start, end) => Query.between(\"$updatedAt\", start, end);\n/**\n * Combine multiple queries using logical OR operator.\n *\n * @param {string[]} queries\n * @returns {string}\n */\nQuery.or = (queries) => new Query(\"or\", undefined, queries.map((query) => JSON.parse(query))).toString();\n/**\n * Combine multiple queries using logical AND operator.\n *\n * @param {string[]} queries\n * @returns {string}\n */\nQuery.and = (queries) => new Query(\"and\", undefined, queries.map((query) => JSON.parse(query))).toString();\n/**\n * Filter resources where attribute is at a specific distance from the given coordinates.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @param {number} distance\n * @param {boolean} meters\n * @returns {string}\n */\nQuery.distanceEqual = (attribute, values, distance, meters = true) => new Query(\"distanceEqual\", attribute, [[values, distance, meters]]).toString();\n/**\n * Filter resources where attribute is not at a specific distance from the given coordinates.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @param {number} distance\n * @param {boolean} meters\n * @returns {string}\n */\nQuery.distanceNotEqual = (attribute, values, distance, meters = true) => new Query(\"distanceNotEqual\", attribute, [[values, distance, meters]]).toString();\n/**\n * Filter resources where attribute is at a distance greater than the specified value from the given coordinates.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @param {number} distance\n * @param {boolean} meters\n * @returns {string}\n */\nQuery.distanceGreaterThan = (attribute, values, distance, meters = true) => new Query(\"distanceGreaterThan\", attribute, [[values, distance, meters]]).toString();\n/**\n * Filter resources where attribute is at a distance less than the specified value from the given coordinates.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @param {number} distance\n * @param {boolean} meters\n * @returns {string}\n */\nQuery.distanceLessThan = (attribute, values, distance, meters = true) => new Query(\"distanceLessThan\", attribute, [[values, distance, meters]]).toString();\n/**\n * Filter resources where attribute intersects with the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.intersects = (attribute, values) => new Query(\"intersects\", attribute, [values]).toString();\n/**\n * Filter resources where attribute does not intersect with the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.notIntersects = (attribute, values) => new Query(\"notIntersects\", attribute, [values]).toString();\n/**\n * Filter resources where attribute crosses the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.crosses = (attribute, values) => new Query(\"crosses\", attribute, [values]).toString();\n/**\n * Filter resources where attribute does not cross the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.notCrosses = (attribute, values) => new Query(\"notCrosses\", attribute, [values]).toString();\n/**\n * Filter resources where attribute overlaps with the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.overlaps = (attribute, values) => new Query(\"overlaps\", attribute, [values]).toString();\n/**\n * Filter resources where attribute does not overlap with the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.notOverlaps = (attribute, values) => new Query(\"notOverlaps\", attribute, [values]).toString();\n/**\n * Filter resources where attribute touches the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.touches = (attribute, values) => new Query(\"touches\", attribute, [values]).toString();\n/**\n * Filter resources where attribute does not touch the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.notTouches = (attribute, values) => new Query(\"notTouches\", attribute, [values]).toString();\n\n/**\n * Exception thrown by the  package\n */\nclass AppwriteException extends Error {\n    /**\n     * Initializes a Appwrite Exception.\n     *\n     * @param {string} message - The error message.\n     * @param {number} code - The error code. Default is 0.\n     * @param {string} type - The error type. Default is an empty string.\n     * @param {string} response - The response string. Default is an empty string.\n     */\n    constructor(message, code = 0, type = '', response = '') {\n        super(message);\n        this.name = 'AppwriteException';\n        this.message = message;\n        this.code = code;\n        this.type = type;\n        this.response = response;\n    }\n}\n/**\n * Client that handles requests to Appwrite\n */\nclass Client {\n    constructor() {\n        /**\n         * Holds configuration such as project.\n         */\n        this.config = {\n            endpoint: 'https://cloud.appwrite.io/v1',\n            endpointRealtime: '',\n            project: '',\n            jwt: '',\n            locale: '',\n            session: '',\n            devkey: '',\n        };\n        /**\n         * Custom headers for API requests.\n         */\n        this.headers = {\n            'x-sdk-name': 'Web',\n            'x-sdk-platform': 'client',\n            'x-sdk-language': 'web',\n            'x-sdk-version': '21.5.0',\n            'X-Appwrite-Response-Format': '1.8.0',\n        };\n        this.realtime = {\n            socket: undefined,\n            timeout: undefined,\n            heartbeat: undefined,\n            url: '',\n            channels: new Set(),\n            subscriptions: new Map(),\n            subscriptionsCounter: 0,\n            reconnect: true,\n            reconnectAttempts: 0,\n            lastMessage: undefined,\n            connect: () => {\n                clearTimeout(this.realtime.timeout);\n                this.realtime.timeout = window === null || window === void 0 ? void 0 : window.setTimeout(() => {\n                    this.realtime.createSocket();\n                }, 50);\n            },\n            getTimeout: () => {\n                switch (true) {\n                    case this.realtime.reconnectAttempts < 5:\n                        return 1000;\n                    case this.realtime.reconnectAttempts < 15:\n                        return 5000;\n                    case this.realtime.reconnectAttempts < 100:\n                        return 10000;\n                    default:\n                        return 60000;\n                }\n            },\n            createHeartbeat: () => {\n                if (this.realtime.heartbeat) {\n                    clearTimeout(this.realtime.heartbeat);\n                }\n                this.realtime.heartbeat = window === null || window === void 0 ? void 0 : window.setInterval(() => {\n                    var _a;\n                    (_a = this.realtime.socket) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify({\n                        type: 'ping'\n                    }));\n                }, 20000);\n            },\n            createSocket: () => {\n                var _a, _b, _c;\n                if (this.realtime.channels.size < 1) {\n                    this.realtime.reconnect = false;\n                    (_a = this.realtime.socket) === null || _a === void 0 ? void 0 : _a.close();\n                    return;\n                }\n                const channels = new URLSearchParams();\n                if (this.config.project) {\n                    channels.set('project', this.config.project);\n                }\n                this.realtime.channels.forEach(channel => {\n                    channels.append('channels[]', channel);\n                });\n                const url = this.config.endpointRealtime + '/realtime?' + channels.toString();\n                if (url !== this.realtime.url || // Check if URL is present\n                    !this.realtime.socket || // Check if WebSocket has not been created\n                    ((_b = this.realtime.socket) === null || _b === void 0 ? void 0 : _b.readyState) > WebSocket.OPEN // Check if WebSocket is CLOSING (3) or CLOSED (4)\n                ) {\n                    if (this.realtime.socket &&\n                        ((_c = this.realtime.socket) === null || _c === void 0 ? void 0 : _c.readyState) < WebSocket.CLOSING // Close WebSocket if it is CONNECTING (0) or OPEN (1)\n                    ) {\n                        this.realtime.reconnect = false;\n                        this.realtime.socket.close();\n                    }\n                    this.realtime.url = url;\n                    this.realtime.socket = new WebSocket(url);\n                    this.realtime.socket.addEventListener('message', this.realtime.onMessage);\n                    this.realtime.socket.addEventListener('open', _event => {\n                        this.realtime.reconnectAttempts = 0;\n                        this.realtime.createHeartbeat();\n                    });\n                    this.realtime.socket.addEventListener('close', event => {\n                        var _a, _b, _c;\n                        if (!this.realtime.reconnect ||\n                            (((_b = (_a = this.realtime) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.type) === 'error' && // Check if last message was of type error\n                                ((_c = this.realtime) === null || _c === void 0 ? void 0 : _c.lastMessage.data).code === 1008 // Check for policy violation 1008\n                            )) {\n                            this.realtime.reconnect = true;\n                            return;\n                        }\n                        const timeout = this.realtime.getTimeout();\n                        console.error(`Realtime got disconnected. Reconnect will be attempted in ${timeout / 1000} seconds.`, event.reason);\n                        setTimeout(() => {\n                            this.realtime.reconnectAttempts++;\n                            this.realtime.createSocket();\n                        }, timeout);\n                    });\n                }\n            },\n            onMessage: (event) => {\n                var _a, _b;\n                try {\n                    const message = JSON.parse(event.data);\n                    this.realtime.lastMessage = message;\n                    switch (message.type) {\n                        case 'connected':\n                            let session = this.config.session;\n                            if (!session) {\n                                const cookie = JSON.parse((_a = window.localStorage.getItem('cookieFallback')) !== null && _a !== void 0 ? _a : '{}');\n                                session = cookie === null || cookie === void 0 ? void 0 : cookie[`a_session_${this.config.project}`];\n                            }\n                            const messageData = message.data;\n                            if (session && !messageData.user) {\n                                (_b = this.realtime.socket) === null || _b === void 0 ? void 0 : _b.send(JSON.stringify({\n                                    type: 'authentication',\n                                    data: {\n                                        session\n                                    }\n                                }));\n                            }\n                            break;\n                        case 'event':\n                            let data = message.data;\n                            if (data === null || data === void 0 ? void 0 : data.channels) {\n                                const isSubscribed = data.channels.some(channel => this.realtime.channels.has(channel));\n                                if (!isSubscribed)\n                                    return;\n                                this.realtime.subscriptions.forEach(subscription => {\n                                    if (data.channels.some(channel => subscription.channels.includes(channel))) {\n                                        setTimeout(() => subscription.callback(data));\n                                    }\n                                });\n                            }\n                            break;\n                        case 'pong':\n                            break; // Handle pong response if needed\n                        case 'error':\n                            throw message.data;\n                        default:\n                            break;\n                    }\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            },\n            cleanUp: channels => {\n                this.realtime.channels.forEach(channel => {\n                    if (channels.includes(channel)) {\n                        let found = Array.from(this.realtime.subscriptions).some(([_key, subscription]) => {\n                            return subscription.channels.includes(channel);\n                        });\n                        if (!found) {\n                            this.realtime.channels.delete(channel);\n                        }\n                    }\n                });\n            }\n        };\n    }\n    /**\n     * Set Endpoint\n     *\n     * Your project endpoint\n     *\n     * @param {string} endpoint\n     *\n     * @returns {this}\n     */\n    setEndpoint(endpoint) {\n        if (!endpoint.startsWith('http://') && !endpoint.startsWith('https://')) {\n            throw new AppwriteException('Invalid endpoint URL: ' + endpoint);\n        }\n        this.config.endpoint = endpoint;\n        this.config.endpointRealtime = endpoint.replace('https://', 'wss://').replace('http://', 'ws://');\n        return this;\n    }\n    /**\n     * Set Realtime Endpoint\n     *\n     * @param {string} endpointRealtime\n     *\n     * @returns {this}\n     */\n    setEndpointRealtime(endpointRealtime) {\n        if (!endpointRealtime.startsWith('ws://') && !endpointRealtime.startsWith('wss://')) {\n            throw new AppwriteException('Invalid realtime endpoint URL: ' + endpointRealtime);\n        }\n        this.config.endpointRealtime = endpointRealtime;\n        return this;\n    }\n    /**\n     * Set Project\n     *\n     * Your project ID\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setProject(value) {\n        this.headers['X-Appwrite-Project'] = value;\n        this.config.project = value;\n        return this;\n    }\n    /**\n     * Set JWT\n     *\n     * Your secret JSON Web Token\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setJWT(value) {\n        this.headers['X-Appwrite-JWT'] = value;\n        this.config.jwt = value;\n        return this;\n    }\n    /**\n     * Set Locale\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setLocale(value) {\n        this.headers['X-Appwrite-Locale'] = value;\n        this.config.locale = value;\n        return this;\n    }\n    /**\n     * Set Session\n     *\n     * The user session to authenticate with\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setSession(value) {\n        this.headers['X-Appwrite-Session'] = value;\n        this.config.session = value;\n        return this;\n    }\n    /**\n     * Set DevKey\n     *\n     * Your secret dev API key\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setDevKey(value) {\n        this.headers['X-Appwrite-Dev-Key'] = value;\n        this.config.devkey = value;\n        return this;\n    }\n    /**\n     * Subscribes to Appwrite events and passes you the payload in realtime.\n     *\n     * @deprecated Use the Realtime service instead.\n     * @see Realtime\n     *\n     * @param {string|string[]} channels\n     * Channel to subscribe - pass a single channel as a string or multiple with an array of strings.\n     *\n     * Possible channels are:\n     * - account\n     * - collections\n     * - collections.[ID]\n     * - collections.[ID].documents\n     * - documents\n     * - documents.[ID]\n     * - files\n     * - files.[ID]\n     * - executions\n     * - executions.[ID]\n     * - functions.[ID]\n     * - teams\n     * - teams.[ID]\n     * - memberships\n     * - memberships.[ID]\n     * @param {(payload: RealtimeMessage) => void} callback Is called on every realtime update.\n     * @returns {() => void} Unsubscribes from events.\n     */\n    subscribe(channels, callback) {\n        let channelArray = typeof channels === 'string' ? [channels] : channels;\n        channelArray.forEach(channel => this.realtime.channels.add(channel));\n        const counter = this.realtime.subscriptionsCounter++;\n        this.realtime.subscriptions.set(counter, {\n            channels: channelArray,\n            callback\n        });\n        this.realtime.connect();\n        return () => {\n            this.realtime.subscriptions.delete(counter);\n            this.realtime.cleanUp(channelArray);\n            this.realtime.connect();\n        };\n    }\n    prepareRequest(method, url, headers = {}, params = {}) {\n        method = method.toUpperCase();\n        headers = Object.assign({}, this.headers, headers);\n        if (typeof window !== 'undefined' && window.localStorage) {\n            const cookieFallback = window.localStorage.getItem('cookieFallback');\n            if (cookieFallback) {\n                headers['X-Fallback-Cookies'] = cookieFallback;\n            }\n        }\n        let options = {\n            method,\n            headers,\n        };\n        if (headers['X-Appwrite-Dev-Key'] === undefined) {\n            options.credentials = 'include';\n        }\n        if (method === 'GET') {\n            for (const [key, value] of Object.entries(Client.flatten(params))) {\n                url.searchParams.append(key, value);\n            }\n        }\n        else {\n            switch (headers['content-type']) {\n                case 'application/json':\n                    options.body = JSON.stringify(params);\n                    break;\n                case 'multipart/form-data':\n                    const formData = new FormData();\n                    for (const [key, value] of Object.entries(params)) {\n                        if (value instanceof File) {\n                            formData.append(key, value, value.name);\n                        }\n                        else if (Array.isArray(value)) {\n                            for (const nestedValue of value) {\n                                formData.append(`${key}[]`, nestedValue);\n                            }\n                        }\n                        else {\n                            formData.append(key, value);\n                        }\n                    }\n                    options.body = formData;\n                    delete headers['content-type'];\n                    break;\n            }\n        }\n        return { uri: url.toString(), options };\n    }\n    chunkedUpload(method, url, headers = {}, originalPayload = {}, onProgress) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const [fileParam, file] = (_a = Object.entries(originalPayload).find(([_, value]) => value instanceof File)) !== null && _a !== void 0 ? _a : [];\n            if (!file || !fileParam) {\n                throw new Error('File not found in payload');\n            }\n            if (file.size <= Client.CHUNK_SIZE) {\n                return yield this.call(method, url, headers, originalPayload);\n            }\n            let start = 0;\n            let response = null;\n            while (start < file.size) {\n                let end = start + Client.CHUNK_SIZE; // Prepare end for the next chunk\n                if (end >= file.size) {\n                    end = file.size; // Adjust for the last chunk to include the last byte\n                }\n                headers['content-range'] = `bytes ${start}-${end - 1}/${file.size}`;\n                const chunk = file.slice(start, end);\n                let payload = Object.assign({}, originalPayload);\n                payload[fileParam] = new File([chunk], file.name);\n                response = yield this.call(method, url, headers, payload);\n                if (onProgress && typeof onProgress === 'function') {\n                    onProgress({\n                        $id: response.$id,\n                        progress: Math.round((end / file.size) * 100),\n                        sizeUploaded: end,\n                        chunksTotal: Math.ceil(file.size / Client.CHUNK_SIZE),\n                        chunksUploaded: Math.ceil(end / Client.CHUNK_SIZE)\n                    });\n                }\n                if (response && response.$id) {\n                    headers['x-appwrite-id'] = response.$id;\n                }\n                start = end;\n            }\n            return response;\n        });\n    }\n    ping() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.call('GET', new URL(this.config.endpoint + '/ping'));\n        });\n    }\n    call(method, url, headers = {}, params = {}, responseType = 'json') {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const { uri, options } = this.prepareRequest(method, url, headers, params);\n            let data = null;\n            const response = yield fetch(uri, options);\n            // type opaque: No-CORS, different-origin response (CORS-issue)\n            if (response.type === 'opaque') {\n                throw new AppwriteException(`Invalid Origin. Register your new client (${window.location.host}) as a new Web platform on your project console dashboard`, 403, \"forbidden\", \"\");\n            }\n            const warnings = response.headers.get('x-appwrite-warning');\n            if (warnings) {\n                warnings.split(';').forEach((warning) => console.warn('Warning: ' + warning));\n            }\n            if ((_a = response.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('application/json')) {\n                data = yield response.json();\n            }\n            else if (responseType === 'arrayBuffer') {\n                data = yield response.arrayBuffer();\n            }\n            else {\n                data = {\n                    message: yield response.text()\n                };\n            }\n            if (400 <= response.status) {\n                let responseText = '';\n                if (((_b = response.headers.get('content-type')) === null || _b === void 0 ? void 0 : _b.includes('application/json')) || responseType === 'arrayBuffer') {\n                    responseText = JSON.stringify(data);\n                }\n                else {\n                    responseText = data === null || data === void 0 ? void 0 : data.message;\n                }\n                throw new AppwriteException(data === null || data === void 0 ? void 0 : data.message, response.status, data === null || data === void 0 ? void 0 : data.type, responseText);\n            }\n            const cookieFallback = response.headers.get('X-Fallback-Cookies');\n            if (typeof window !== 'undefined' && window.localStorage && cookieFallback) {\n                window.console.warn('Appwrite is using localStorage for session management. Increase your security by adding a custom domain as your API endpoint.');\n                window.localStorage.setItem('cookieFallback', cookieFallback);\n            }\n            return data;\n        });\n    }\n    static flatten(data, prefix = '') {\n        let output = {};\n        for (const [key, value] of Object.entries(data)) {\n            let finalKey = prefix ? prefix + '[' + key + ']' : key;\n            if (Array.isArray(value)) {\n                output = Object.assign(Object.assign({}, output), Client.flatten(value, finalKey));\n            }\n            else {\n                output[finalKey] = value;\n            }\n        }\n        return output;\n    }\n}\nClient.CHUNK_SIZE = 1024 * 1024 * 5;\n\nclass Service {\n    constructor(client) {\n        this.client = client;\n    }\n    static flatten(data, prefix = '') {\n        let output = {};\n        for (const [key, value] of Object.entries(data)) {\n            let finalKey = prefix ? prefix + '[' + key + ']' : key;\n            if (Array.isArray(value)) {\n                output = Object.assign(Object.assign({}, output), Service.flatten(value, finalKey));\n            }\n            else {\n                output[finalKey] = value;\n            }\n        }\n        return output;\n    }\n}\n/**\n * The size for chunked uploads in bytes.\n */\nService.CHUNK_SIZE = 5 * 1024 * 1024; // 5MB\n\nclass Account {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Get the currently logged in user.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.User<Preferences>>}\n     */\n    get() {\n        const apiPath = '/account';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    create(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                email: rest[0],\n                password: rest[1],\n                name: rest[2]\n            };\n        }\n        const userId = params.userId;\n        const email = params.email;\n        const password = params.password;\n        const name = params.name;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        const apiPath = '/account';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updateEmail(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                email: paramsOrFirst,\n                password: rest[0]\n            };\n        }\n        const email = params.email;\n        const password = params.password;\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        const apiPath = '/account/email';\n        const payload = {};\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    listIdentities(paramsOrFirst, ...rest) {\n        let params;\n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                queries: paramsOrFirst,\n                total: rest[0]\n            };\n        }\n        const queries = params.queries;\n        const total = params.total;\n        const apiPath = '/account/identities';\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    deleteIdentity(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                identityId: paramsOrFirst\n            };\n        }\n        const identityId = params.identityId;\n        if (typeof identityId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"identityId\"');\n        }\n        const apiPath = '/account/identities/{identityId}'.replace('{identityId}', identityId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    /**\n     * Use this endpoint to create a JSON Web Token. You can use the resulting JWT to authenticate on behalf of the current user when working with the Appwrite server-side API and SDKs. The JWT secret is valid for 15 minutes from its creation and will be invalid if the user will logout in that time frame.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Jwt>}\n     */\n    createJWT() {\n        const apiPath = '/account/jwts';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    listLogs(paramsOrFirst, ...rest) {\n        let params;\n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                queries: paramsOrFirst,\n                total: rest[0]\n            };\n        }\n        const queries = params.queries;\n        const total = params.total;\n        const apiPath = '/account/logs';\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updateMFA(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                mfa: paramsOrFirst\n            };\n        }\n        const mfa = params.mfa;\n        if (typeof mfa === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"mfa\"');\n        }\n        const apiPath = '/account/mfa';\n        const payload = {};\n        if (typeof mfa !== 'undefined') {\n            payload['mfa'] = mfa;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    createMfaAuthenticator(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                type: paramsOrFirst\n            };\n        }\n        const type = params.type;\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    createMFAAuthenticator(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                type: paramsOrFirst\n            };\n        }\n        const type = params.type;\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updateMfaAuthenticator(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                type: paramsOrFirst,\n                otp: rest[0]\n            };\n        }\n        const type = params.type;\n        const otp = params.otp;\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n        if (typeof otp === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"otp\"');\n        }\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        const payload = {};\n        if (typeof otp !== 'undefined') {\n            payload['otp'] = otp;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    updateMFAAuthenticator(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                type: paramsOrFirst,\n                otp: rest[0]\n            };\n        }\n        const type = params.type;\n        const otp = params.otp;\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n        if (typeof otp === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"otp\"');\n        }\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        const payload = {};\n        if (typeof otp !== 'undefined') {\n            payload['otp'] = otp;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    deleteMfaAuthenticator(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                type: paramsOrFirst\n            };\n        }\n        const type = params.type;\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    deleteMFAAuthenticator(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                type: paramsOrFirst\n            };\n        }\n        const type = params.type;\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    createMfaChallenge(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'factor' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                factor: paramsOrFirst\n            };\n        }\n        const factor = params.factor;\n        if (typeof factor === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"factor\"');\n        }\n        const apiPath = '/account/mfa/challenges';\n        const payload = {};\n        if (typeof factor !== 'undefined') {\n            payload['factor'] = factor;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    createMFAChallenge(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'factor' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                factor: paramsOrFirst\n            };\n        }\n        const factor = params.factor;\n        if (typeof factor === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"factor\"');\n        }\n        const apiPath = '/account/mfa/challenges';\n        const payload = {};\n        if (typeof factor !== 'undefined') {\n            payload['factor'] = factor;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updateMfaChallenge(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                challengeId: paramsOrFirst,\n                otp: rest[0]\n            };\n        }\n        const challengeId = params.challengeId;\n        const otp = params.otp;\n        if (typeof challengeId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"challengeId\"');\n        }\n        if (typeof otp === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"otp\"');\n        }\n        const apiPath = '/account/mfa/challenges';\n        const payload = {};\n        if (typeof challengeId !== 'undefined') {\n            payload['challengeId'] = challengeId;\n        }\n        if (typeof otp !== 'undefined') {\n            payload['otp'] = otp;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    updateMFAChallenge(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                challengeId: paramsOrFirst,\n                otp: rest[0]\n            };\n        }\n        const challengeId = params.challengeId;\n        const otp = params.otp;\n        if (typeof challengeId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"challengeId\"');\n        }\n        if (typeof otp === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"otp\"');\n        }\n        const apiPath = '/account/mfa/challenges';\n        const payload = {};\n        if (typeof challengeId !== 'undefined') {\n            payload['challengeId'] = challengeId;\n        }\n        if (typeof otp !== 'undefined') {\n            payload['otp'] = otp;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    /**\n     * List the factors available on the account to be used as a MFA challange.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaFactors>}\n     * @deprecated This API has been deprecated since 1.8.0. Please use `Account.listMFAFactors` instead.\n     */\n    listMfaFactors() {\n        const apiPath = '/account/mfa/factors';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List the factors available on the account to be used as a MFA challange.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaFactors>}\n     */\n    listMFAFactors() {\n        const apiPath = '/account/mfa/factors';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * Get recovery codes that can be used as backup for MFA flow. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to read recovery codes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaRecoveryCodes>}\n     * @deprecated This API has been deprecated since 1.8.0. Please use `Account.getMFARecoveryCodes` instead.\n     */\n    getMfaRecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * Get recovery codes that can be used as backup for MFA flow. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to read recovery codes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaRecoveryCodes>}\n     */\n    getMFARecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * Generate recovery codes as backup for MFA flow. It's recommended to generate and show then immediately after user successfully adds their authehticator. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaRecoveryCodes>}\n     * @deprecated This API has been deprecated since 1.8.0. Please use `Account.createMFARecoveryCodes` instead.\n     */\n    createMfaRecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    /**\n     * Generate recovery codes as backup for MFA flow. It's recommended to generate and show then immediately after user successfully adds their authehticator. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaRecoveryCodes>}\n     */\n    createMFARecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    /**\n     * Regenerate recovery codes that can be used as backup for MFA flow. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to regenreate recovery codes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaRecoveryCodes>}\n     * @deprecated This API has been deprecated since 1.8.0. Please use `Account.updateMFARecoveryCodes` instead.\n     */\n    updateMfaRecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    /**\n     * Regenerate recovery codes that can be used as backup for MFA flow. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to regenreate recovery codes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaRecoveryCodes>}\n     */\n    updateMFARecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    updateName(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                name: paramsOrFirst\n            };\n        }\n        const name = params.name;\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        const apiPath = '/account/name';\n        const payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    updatePassword(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                password: paramsOrFirst,\n                oldPassword: rest[0]\n            };\n        }\n        const password = params.password;\n        const oldPassword = params.oldPassword;\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        const apiPath = '/account/password';\n        const payload = {};\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        if (typeof oldPassword !== 'undefined') {\n            payload['oldPassword'] = oldPassword;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    updatePhone(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                phone: paramsOrFirst,\n                password: rest[0]\n            };\n        }\n        const phone = params.phone;\n        const password = params.password;\n        if (typeof phone === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"phone\"');\n        }\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        const apiPath = '/account/phone';\n        const payload = {};\n        if (typeof phone !== 'undefined') {\n            payload['phone'] = phone;\n        }\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    /**\n     * Get the preferences as a key-value object for the currently logged in user.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Preferences>}\n     */\n    getPrefs() {\n        const apiPath = '/account/prefs';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updatePrefs(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'prefs' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                prefs: paramsOrFirst\n            };\n        }\n        const prefs = params.prefs;\n        if (typeof prefs === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"prefs\"');\n        }\n        const apiPath = '/account/prefs';\n        const payload = {};\n        if (typeof prefs !== 'undefined') {\n            payload['prefs'] = prefs;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    createRecovery(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                email: paramsOrFirst,\n                url: rest[0]\n            };\n        }\n        const email = params.email;\n        const url = params.url;\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n        const apiPath = '/account/recovery';\n        const payload = {};\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updateRecovery(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                secret: rest[0],\n                password: rest[1]\n            };\n        }\n        const userId = params.userId;\n        const secret = params.secret;\n        const password = params.password;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        const apiPath = '/account/recovery';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    /**\n     * Get the list of active sessions across different devices for the currently logged in user.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.SessionList>}\n     */\n    listSessions() {\n        const apiPath = '/account/sessions';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * Delete all sessions from the user account and remove any sessions cookies from the end client.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<{}>}\n     */\n    deleteSessions() {\n        const apiPath = '/account/sessions';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    /**\n     * Use this endpoint to allow a new user to register an anonymous account in your project. This route will also create a new session for the user. To allow the new user to convert an anonymous account to a normal account, you need to update its [email and password](https://appwrite.io/docs/references/cloud/client-web/account#updateEmail) or create an [OAuth2 session](https://appwrite.io/docs/references/cloud/client-web/account#CreateOAuth2Session).\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Session>}\n     */\n    createAnonymousSession() {\n        const apiPath = '/account/sessions/anonymous';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    createEmailPasswordSession(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                email: paramsOrFirst,\n                password: rest[0]\n            };\n        }\n        const email = params.email;\n        const password = params.password;\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        const apiPath = '/account/sessions/email';\n        const payload = {};\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updateMagicURLSession(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                secret: rest[0]\n            };\n        }\n        const userId = params.userId;\n        const secret = params.secret;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        const apiPath = '/account/sessions/magic-url';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    createOAuth2Session(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'provider' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                provider: paramsOrFirst,\n                success: rest[0],\n                failure: rest[1],\n                scopes: rest[2]\n            };\n        }\n        const provider = params.provider;\n        const success = params.success;\n        const failure = params.failure;\n        const scopes = params.scopes;\n        if (typeof provider === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"provider\"');\n        }\n        const apiPath = '/account/sessions/oauth2/{provider}'.replace('{provider}', provider);\n        const payload = {};\n        if (typeof success !== 'undefined') {\n            payload['success'] = success;\n        }\n        if (typeof failure !== 'undefined') {\n            payload['failure'] = failure;\n        }\n        if (typeof scopes !== 'undefined') {\n            payload['scopes'] = scopes;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        if (typeof window !== 'undefined' && (window === null || window === void 0 ? void 0 : window.location)) {\n            window.location.href = uri.toString();\n            return;\n        }\n        else {\n            return uri.toString();\n        }\n    }\n    updatePhoneSession(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                secret: rest[0]\n            };\n        }\n        const userId = params.userId;\n        const secret = params.secret;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        const apiPath = '/account/sessions/phone';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    createSession(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                secret: rest[0]\n            };\n        }\n        const userId = params.userId;\n        const secret = params.secret;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        const apiPath = '/account/sessions/token';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    getSession(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                sessionId: paramsOrFirst\n            };\n        }\n        const sessionId = params.sessionId;\n        if (typeof sessionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"sessionId\"');\n        }\n        const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updateSession(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                sessionId: paramsOrFirst\n            };\n        }\n        const sessionId = params.sessionId;\n        if (typeof sessionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"sessionId\"');\n        }\n        const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    deleteSession(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                sessionId: paramsOrFirst\n            };\n        }\n        const sessionId = params.sessionId;\n        if (typeof sessionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"sessionId\"');\n        }\n        const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    /**\n     * Block the currently logged in user account. Behind the scene, the user record is not deleted but permanently blocked from any access. To completely delete a user, use the Users API instead.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.User<Preferences>>}\n     */\n    updateStatus() {\n        const apiPath = '/account/status';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    createPushTarget(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                targetId: paramsOrFirst,\n                identifier: rest[0],\n                providerId: rest[1]\n            };\n        }\n        const targetId = params.targetId;\n        const identifier = params.identifier;\n        const providerId = params.providerId;\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n        if (typeof identifier === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"identifier\"');\n        }\n        const apiPath = '/account/targets/push';\n        const payload = {};\n        if (typeof targetId !== 'undefined') {\n            payload['targetId'] = targetId;\n        }\n        if (typeof identifier !== 'undefined') {\n            payload['identifier'] = identifier;\n        }\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updatePushTarget(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                targetId: paramsOrFirst,\n                identifier: rest[0]\n            };\n        }\n        const targetId = params.targetId;\n        const identifier = params.identifier;\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n        if (typeof identifier === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"identifier\"');\n        }\n        const apiPath = '/account/targets/{targetId}/push'.replace('{targetId}', targetId);\n        const payload = {};\n        if (typeof identifier !== 'undefined') {\n            payload['identifier'] = identifier;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    deletePushTarget(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                targetId: paramsOrFirst\n            };\n        }\n        const targetId = params.targetId;\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n        const apiPath = '/account/targets/{targetId}/push'.replace('{targetId}', targetId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    createEmailToken(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                email: rest[0],\n                phrase: rest[1]\n            };\n        }\n        const userId = params.userId;\n        const email = params.email;\n        const phrase = params.phrase;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        const apiPath = '/account/tokens/email';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n        if (typeof phrase !== 'undefined') {\n            payload['phrase'] = phrase;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    createMagicURLToken(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                email: rest[0],\n                url: rest[1],\n                phrase: rest[2]\n            };\n        }\n        const userId = params.userId;\n        const email = params.email;\n        const url = params.url;\n        const phrase = params.phrase;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        const apiPath = '/account/tokens/magic-url';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        if (typeof phrase !== 'undefined') {\n            payload['phrase'] = phrase;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    createOAuth2Token(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'provider' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                provider: paramsOrFirst,\n                success: rest[0],\n                failure: rest[1],\n                scopes: rest[2]\n            };\n        }\n        const provider = params.provider;\n        const success = params.success;\n        const failure = params.failure;\n        const scopes = params.scopes;\n        if (typeof provider === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"provider\"');\n        }\n        const apiPath = '/account/tokens/oauth2/{provider}'.replace('{provider}', provider);\n        const payload = {};\n        if (typeof success !== 'undefined') {\n            payload['success'] = success;\n        }\n        if (typeof failure !== 'undefined') {\n            payload['failure'] = failure;\n        }\n        if (typeof scopes !== 'undefined') {\n            payload['scopes'] = scopes;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        if (typeof window !== 'undefined' && (window === null || window === void 0 ? void 0 : window.location)) {\n            window.location.href = uri.toString();\n            return;\n        }\n        else {\n            return uri.toString();\n        }\n    }\n    createPhoneToken(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                phone: rest[0]\n            };\n        }\n        const userId = params.userId;\n        const phone = params.phone;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof phone === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"phone\"');\n        }\n        const apiPath = '/account/tokens/phone';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof phone !== 'undefined') {\n            payload['phone'] = phone;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    createEmailVerification(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                url: paramsOrFirst\n            };\n        }\n        const url = params.url;\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n        const apiPath = '/account/verifications/email';\n        const payload = {};\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    createVerification(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                url: paramsOrFirst\n            };\n        }\n        const url = params.url;\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n        const apiPath = '/account/verifications/email';\n        const payload = {};\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updateEmailVerification(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                secret: rest[0]\n            };\n        }\n        const userId = params.userId;\n        const secret = params.secret;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        const apiPath = '/account/verifications/email';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    updateVerification(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                secret: rest[0]\n            };\n        }\n        const userId = params.userId;\n        const secret = params.secret;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        const apiPath = '/account/verifications/email';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    /**\n     * Use this endpoint to send a verification SMS to the currently logged in user. This endpoint is meant for use after updating a user's phone number using the [accountUpdatePhone](https://appwrite.io/docs/references/cloud/client-web/account#updatePhone) endpoint. Learn more about how to [complete the verification process](https://appwrite.io/docs/references/cloud/client-web/account#updatePhoneVerification). The verification code sent to the user's phone number is valid for 15 minutes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Token>}\n     */\n    createPhoneVerification() {\n        const apiPath = '/account/verifications/phone';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updatePhoneVerification(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                secret: rest[0]\n            };\n        }\n        const userId = params.userId;\n        const secret = params.secret;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        const apiPath = '/account/verifications/phone';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n}\n\nclass Avatars {\n    constructor(client) {\n        this.client = client;\n    }\n    getBrowser(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'code' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                code: paramsOrFirst,\n                width: rest[0],\n                height: rest[1],\n                quality: rest[2]\n            };\n        }\n        const code = params.code;\n        const width = params.width;\n        const height = params.height;\n        const quality = params.quality;\n        if (typeof code === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n        const apiPath = '/avatars/browsers/{code}'.replace('{code}', code);\n        const payload = {};\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getCreditCard(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'code' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                code: paramsOrFirst,\n                width: rest[0],\n                height: rest[1],\n                quality: rest[2]\n            };\n        }\n        const code = params.code;\n        const width = params.width;\n        const height = params.height;\n        const quality = params.quality;\n        if (typeof code === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n        const apiPath = '/avatars/credit-cards/{code}'.replace('{code}', code);\n        const payload = {};\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getFavicon(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                url: paramsOrFirst\n            };\n        }\n        const url = params.url;\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n        const apiPath = '/avatars/favicon';\n        const payload = {};\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getFlag(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'code' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                code: paramsOrFirst,\n                width: rest[0],\n                height: rest[1],\n                quality: rest[2]\n            };\n        }\n        const code = params.code;\n        const width = params.width;\n        const height = params.height;\n        const quality = params.quality;\n        if (typeof code === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n        const apiPath = '/avatars/flags/{code}'.replace('{code}', code);\n        const payload = {};\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getImage(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                url: paramsOrFirst,\n                width: rest[0],\n                height: rest[1]\n            };\n        }\n        const url = params.url;\n        const width = params.width;\n        const height = params.height;\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n        const apiPath = '/avatars/image';\n        const payload = {};\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getInitials(paramsOrFirst, ...rest) {\n        let params;\n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                name: paramsOrFirst,\n                width: rest[0],\n                height: rest[1],\n                background: rest[2]\n            };\n        }\n        const name = params.name;\n        const width = params.width;\n        const height = params.height;\n        const background = params.background;\n        const apiPath = '/avatars/initials';\n        const payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        if (typeof background !== 'undefined') {\n            payload['background'] = background;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getQR(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                text: paramsOrFirst,\n                size: rest[0],\n                margin: rest[1],\n                download: rest[2]\n            };\n        }\n        const text = params.text;\n        const size = params.size;\n        const margin = params.margin;\n        const download = params.download;\n        if (typeof text === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"text\"');\n        }\n        const apiPath = '/avatars/qr';\n        const payload = {};\n        if (typeof text !== 'undefined') {\n            payload['text'] = text;\n        }\n        if (typeof size !== 'undefined') {\n            payload['size'] = size;\n        }\n        if (typeof margin !== 'undefined') {\n            payload['margin'] = margin;\n        }\n        if (typeof download !== 'undefined') {\n            payload['download'] = download;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getScreenshot(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                url: paramsOrFirst,\n                headers: rest[0],\n                viewportWidth: rest[1],\n                viewportHeight: rest[2],\n                scale: rest[3],\n                theme: rest[4],\n                userAgent: rest[5],\n                fullpage: rest[6],\n                locale: rest[7],\n                timezone: rest[8],\n                latitude: rest[9],\n                longitude: rest[10],\n                accuracy: rest[11],\n                touch: rest[12],\n                permissions: rest[13],\n                sleep: rest[14],\n                width: rest[15],\n                height: rest[16],\n                quality: rest[17],\n                output: rest[18]\n            };\n        }\n        const url = params.url;\n        const headers = params.headers;\n        const viewportWidth = params.viewportWidth;\n        const viewportHeight = params.viewportHeight;\n        const scale = params.scale;\n        const theme = params.theme;\n        const userAgent = params.userAgent;\n        const fullpage = params.fullpage;\n        const locale = params.locale;\n        const timezone = params.timezone;\n        const latitude = params.latitude;\n        const longitude = params.longitude;\n        const accuracy = params.accuracy;\n        const touch = params.touch;\n        const permissions = params.permissions;\n        const sleep = params.sleep;\n        const width = params.width;\n        const height = params.height;\n        const quality = params.quality;\n        const output = params.output;\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n        const apiPath = '/avatars/screenshots';\n        const payload = {};\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        if (typeof headers !== 'undefined') {\n            payload['headers'] = headers;\n        }\n        if (typeof viewportWidth !== 'undefined') {\n            payload['viewportWidth'] = viewportWidth;\n        }\n        if (typeof viewportHeight !== 'undefined') {\n            payload['viewportHeight'] = viewportHeight;\n        }\n        if (typeof scale !== 'undefined') {\n            payload['scale'] = scale;\n        }\n        if (typeof theme !== 'undefined') {\n            payload['theme'] = theme;\n        }\n        if (typeof userAgent !== 'undefined') {\n            payload['userAgent'] = userAgent;\n        }\n        if (typeof fullpage !== 'undefined') {\n            payload['fullpage'] = fullpage;\n        }\n        if (typeof locale !== 'undefined') {\n            payload['locale'] = locale;\n        }\n        if (typeof timezone !== 'undefined') {\n            payload['timezone'] = timezone;\n        }\n        if (typeof latitude !== 'undefined') {\n            payload['latitude'] = latitude;\n        }\n        if (typeof longitude !== 'undefined') {\n            payload['longitude'] = longitude;\n        }\n        if (typeof accuracy !== 'undefined') {\n            payload['accuracy'] = accuracy;\n        }\n        if (typeof touch !== 'undefined') {\n            payload['touch'] = touch;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        if (typeof sleep !== 'undefined') {\n            payload['sleep'] = sleep;\n        }\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n        if (typeof output !== 'undefined') {\n            payload['output'] = output;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n}\n\nclass Databases {\n    constructor(client) {\n        this.client = client;\n    }\n    listTransactions(paramsOrFirst) {\n        let params;\n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                queries: paramsOrFirst\n            };\n        }\n        const queries = params.queries;\n        const apiPath = '/databases/transactions';\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    createTransaction(paramsOrFirst) {\n        let params;\n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                ttl: paramsOrFirst\n            };\n        }\n        const ttl = params.ttl;\n        const apiPath = '/databases/transactions';\n        const payload = {};\n        if (typeof ttl !== 'undefined') {\n            payload['ttl'] = ttl;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    getTransaction(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                transactionId: paramsOrFirst\n            };\n        }\n        const transactionId = params.transactionId;\n        if (typeof transactionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"transactionId\"');\n        }\n        const apiPath = '/databases/transactions/{transactionId}'.replace('{transactionId}', transactionId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updateTransaction(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                transactionId: paramsOrFirst,\n                commit: rest[0],\n                rollback: rest[1]\n            };\n        }\n        const transactionId = params.transactionId;\n        const commit = params.commit;\n        const rollback = params.rollback;\n        if (typeof transactionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"transactionId\"');\n        }\n        const apiPath = '/databases/transactions/{transactionId}'.replace('{transactionId}', transactionId);\n        const payload = {};\n        if (typeof commit !== 'undefined') {\n            payload['commit'] = commit;\n        }\n        if (typeof rollback !== 'undefined') {\n            payload['rollback'] = rollback;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    deleteTransaction(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                transactionId: paramsOrFirst\n            };\n        }\n        const transactionId = params.transactionId;\n        if (typeof transactionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"transactionId\"');\n        }\n        const apiPath = '/databases/transactions/{transactionId}'.replace('{transactionId}', transactionId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    createOperations(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                transactionId: paramsOrFirst,\n                operations: rest[0]\n            };\n        }\n        const transactionId = params.transactionId;\n        const operations = params.operations;\n        if (typeof transactionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"transactionId\"');\n        }\n        const apiPath = '/databases/transactions/{transactionId}/operations'.replace('{transactionId}', transactionId);\n        const payload = {};\n        if (typeof operations !== 'undefined') {\n            payload['operations'] = operations;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    listDocuments(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                queries: rest[1],\n                transactionId: rest[2],\n                total: rest[3]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const queries = params.queries;\n        const transactionId = params.transactionId;\n        const total = params.total;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    createDocument(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                documentId: rest[1],\n                data: rest[2],\n                permissions: rest[3],\n                transactionId: rest[4]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const documentId = params.documentId;\n        const data = params.data;\n        const permissions = params.permissions;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        if (typeof data === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"data\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        const payload = {};\n        if (typeof documentId !== 'undefined') {\n            payload['documentId'] = documentId;\n        }\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    getDocument(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                documentId: rest[1],\n                queries: rest[2],\n                transactionId: rest[3]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const documentId = params.documentId;\n        const queries = params.queries;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    upsertDocument(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                documentId: rest[1],\n                data: rest[2],\n                permissions: rest[3],\n                transactionId: rest[4]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const documentId = params.documentId;\n        const data = params.data;\n        const permissions = params.permissions;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        if (typeof data === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"data\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n        const payload = {};\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    updateDocument(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                documentId: rest[1],\n                data: rest[2],\n                permissions: rest[3],\n                transactionId: rest[4]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const documentId = params.documentId;\n        const data = params.data;\n        const permissions = params.permissions;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n        const payload = {};\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    deleteDocument(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                documentId: rest[1],\n                transactionId: rest[2]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const documentId = params.documentId;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n        const payload = {};\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    decrementDocumentAttribute(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                documentId: rest[1],\n                attribute: rest[2],\n                value: rest[3],\n                min: rest[4],\n                transactionId: rest[5]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const documentId = params.documentId;\n        const attribute = params.attribute;\n        const value = params.value;\n        const min = params.min;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        if (typeof attribute === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"attribute\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}/{attribute}/decrement'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId).replace('{attribute}', attribute);\n        const payload = {};\n        if (typeof value !== 'undefined') {\n            payload['value'] = value;\n        }\n        if (typeof min !== 'undefined') {\n            payload['min'] = min;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    incrementDocumentAttribute(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                documentId: rest[1],\n                attribute: rest[2],\n                value: rest[3],\n                max: rest[4],\n                transactionId: rest[5]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const documentId = params.documentId;\n        const attribute = params.attribute;\n        const value = params.value;\n        const max = params.max;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        if (typeof attribute === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"attribute\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}/{attribute}/increment'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId).replace('{attribute}', attribute);\n        const payload = {};\n        if (typeof value !== 'undefined') {\n            payload['value'] = value;\n        }\n        if (typeof max !== 'undefined') {\n            payload['max'] = max;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n}\n\nclass Functions {\n    constructor(client) {\n        this.client = client;\n    }\n    listExecutions(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                functionId: paramsOrFirst,\n                queries: rest[0],\n                total: rest[1]\n            };\n        }\n        const functionId = params.functionId;\n        const queries = params.queries;\n        const total = params.total;\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        const apiPath = '/functions/{functionId}/executions'.replace('{functionId}', functionId);\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    createExecution(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                functionId: paramsOrFirst,\n                body: rest[0],\n                async: rest[1],\n                xpath: rest[2],\n                method: rest[3],\n                headers: rest[4],\n                scheduledAt: rest[5]\n            };\n        }\n        const functionId = params.functionId;\n        const body = params.body;\n        const async = params.async;\n        const xpath = params.xpath;\n        const method = params.method;\n        const headers = params.headers;\n        const scheduledAt = params.scheduledAt;\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        const apiPath = '/functions/{functionId}/executions'.replace('{functionId}', functionId);\n        const payload = {};\n        if (typeof body !== 'undefined') {\n            payload['body'] = body;\n        }\n        if (typeof async !== 'undefined') {\n            payload['async'] = async;\n        }\n        if (typeof xpath !== 'undefined') {\n            payload['path'] = xpath;\n        }\n        if (typeof method !== 'undefined') {\n            payload['method'] = method;\n        }\n        if (typeof headers !== 'undefined') {\n            payload['headers'] = headers;\n        }\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    getExecution(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                functionId: paramsOrFirst,\n                executionId: rest[0]\n            };\n        }\n        const functionId = params.functionId;\n        const executionId = params.executionId;\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        if (typeof executionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"executionId\"');\n        }\n        const apiPath = '/functions/{functionId}/executions/{executionId}'.replace('{functionId}', functionId).replace('{executionId}', executionId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n}\n\nclass Graphql {\n    constructor(client) {\n        this.client = client;\n    }\n    query(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'query' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                query: paramsOrFirst\n            };\n        }\n        const query = params.query;\n        if (typeof query === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"query\"');\n        }\n        const apiPath = '/graphql';\n        const payload = {};\n        if (typeof query !== 'undefined') {\n            payload['query'] = query;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'x-sdk-graphql': 'true',\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    mutation(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'query' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                query: paramsOrFirst\n            };\n        }\n        const query = params.query;\n        if (typeof query === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"query\"');\n        }\n        const apiPath = '/graphql/mutation';\n        const payload = {};\n        if (typeof query !== 'undefined') {\n            payload['query'] = query;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'x-sdk-graphql': 'true',\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n}\n\nclass Locale {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Get the current user location based on IP. Returns an object with user country code, country name, continent name, continent code, ip address and suggested currency. You can use the locale header to get the data in a supported language.\n     *\n     * ([IP Geolocation by DB-IP](https://db-ip.com))\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Locale>}\n     */\n    get() {\n        const apiPath = '/locale';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List of all locale codes in [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.LocaleCodeList>}\n     */\n    listCodes() {\n        const apiPath = '/locale/codes';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List of all continents. You can use the locale header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.ContinentList>}\n     */\n    listContinents() {\n        const apiPath = '/locale/continents';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List of all countries. You can use the locale header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.CountryList>}\n     */\n    listCountries() {\n        const apiPath = '/locale/countries';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List of all countries that are currently members of the EU. You can use the locale header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.CountryList>}\n     */\n    listCountriesEU() {\n        const apiPath = '/locale/countries/eu';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List of all countries phone codes. You can use the locale header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.PhoneList>}\n     */\n    listCountriesPhones() {\n        const apiPath = '/locale/countries/phones';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List of all currencies, including currency symbol, name, plural, and decimal digits for all major and minor currencies. You can use the locale header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.CurrencyList>}\n     */\n    listCurrencies() {\n        const apiPath = '/locale/currencies';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List of all languages classified by ISO 639-1 including 2-letter code, name in English, and name in the respective language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.LanguageList>}\n     */\n    listLanguages() {\n        const apiPath = '/locale/languages';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n}\n\nclass Messaging {\n    constructor(client) {\n        this.client = client;\n    }\n    createSubscriber(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                topicId: paramsOrFirst,\n                subscriberId: rest[0],\n                targetId: rest[1]\n            };\n        }\n        const topicId = params.topicId;\n        const subscriberId = params.subscriberId;\n        const targetId = params.targetId;\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n        if (typeof subscriberId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"subscriberId\"');\n        }\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n        const apiPath = '/messaging/topics/{topicId}/subscribers'.replace('{topicId}', topicId);\n        const payload = {};\n        if (typeof subscriberId !== 'undefined') {\n            payload['subscriberId'] = subscriberId;\n        }\n        if (typeof targetId !== 'undefined') {\n            payload['targetId'] = targetId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    deleteSubscriber(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                topicId: paramsOrFirst,\n                subscriberId: rest[0]\n            };\n        }\n        const topicId = params.topicId;\n        const subscriberId = params.subscriberId;\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n        if (typeof subscriberId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"subscriberId\"');\n        }\n        const apiPath = '/messaging/topics/{topicId}/subscribers/{subscriberId}'.replace('{topicId}', topicId).replace('{subscriberId}', subscriberId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n}\n\nclass Storage {\n    constructor(client) {\n        this.client = client;\n    }\n    listFiles(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                queries: rest[0],\n                search: rest[1],\n                total: rest[2]\n            };\n        }\n        const bucketId = params.bucketId;\n        const queries = params.queries;\n        const search = params.search;\n        const total = params.total;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files'.replace('{bucketId}', bucketId);\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    createFile(paramsOrFirst, ...rest) {\n        let params;\n        let onProgress;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n            onProgress = paramsOrFirst === null || paramsOrFirst === void 0 ? void 0 : paramsOrFirst.onProgress;\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                fileId: rest[0],\n                file: rest[1],\n                permissions: rest[2]\n            };\n            onProgress = rest[3];\n        }\n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        const file = params.file;\n        const permissions = params.permissions;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        if (typeof file === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"file\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files'.replace('{bucketId}', bucketId);\n        const payload = {};\n        if (typeof fileId !== 'undefined') {\n            payload['fileId'] = fileId;\n        }\n        if (typeof file !== 'undefined') {\n            payload['file'] = file;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'multipart/form-data',\n        };\n        return this.client.chunkedUpload('post', uri, apiHeaders, payload, onProgress);\n    }\n    getFile(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                fileId: rest[0]\n            };\n        }\n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updateFile(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                fileId: rest[0],\n                name: rest[1],\n                permissions: rest[2]\n            };\n        }\n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        const name = params.name;\n        const permissions = params.permissions;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    deleteFile(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                fileId: rest[0]\n            };\n        }\n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    getFileDownload(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                fileId: rest[0],\n                token: rest[1]\n            };\n        }\n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        const token = params.token;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/download'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload = {};\n        if (typeof token !== 'undefined') {\n            payload['token'] = token;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getFilePreview(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                fileId: rest[0],\n                width: rest[1],\n                height: rest[2],\n                gravity: rest[3],\n                quality: rest[4],\n                borderWidth: rest[5],\n                borderColor: rest[6],\n                borderRadius: rest[7],\n                opacity: rest[8],\n                rotation: rest[9],\n                background: rest[10],\n                output: rest[11],\n                token: rest[12]\n            };\n        }\n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        const width = params.width;\n        const height = params.height;\n        const gravity = params.gravity;\n        const quality = params.quality;\n        const borderWidth = params.borderWidth;\n        const borderColor = params.borderColor;\n        const borderRadius = params.borderRadius;\n        const opacity = params.opacity;\n        const rotation = params.rotation;\n        const background = params.background;\n        const output = params.output;\n        const token = params.token;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/preview'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload = {};\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        if (typeof gravity !== 'undefined') {\n            payload['gravity'] = gravity;\n        }\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n        if (typeof borderWidth !== 'undefined') {\n            payload['borderWidth'] = borderWidth;\n        }\n        if (typeof borderColor !== 'undefined') {\n            payload['borderColor'] = borderColor;\n        }\n        if (typeof borderRadius !== 'undefined') {\n            payload['borderRadius'] = borderRadius;\n        }\n        if (typeof opacity !== 'undefined') {\n            payload['opacity'] = opacity;\n        }\n        if (typeof rotation !== 'undefined') {\n            payload['rotation'] = rotation;\n        }\n        if (typeof background !== 'undefined') {\n            payload['background'] = background;\n        }\n        if (typeof output !== 'undefined') {\n            payload['output'] = output;\n        }\n        if (typeof token !== 'undefined') {\n            payload['token'] = token;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getFileView(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                fileId: rest[0],\n                token: rest[1]\n            };\n        }\n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        const token = params.token;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/view'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload = {};\n        if (typeof token !== 'undefined') {\n            payload['token'] = token;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n}\n\nclass TablesDB {\n    constructor(client) {\n        this.client = client;\n    }\n    listTransactions(paramsOrFirst) {\n        let params;\n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                queries: paramsOrFirst\n            };\n        }\n        const queries = params.queries;\n        const apiPath = '/tablesdb/transactions';\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    createTransaction(paramsOrFirst) {\n        let params;\n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                ttl: paramsOrFirst\n            };\n        }\n        const ttl = params.ttl;\n        const apiPath = '/tablesdb/transactions';\n        const payload = {};\n        if (typeof ttl !== 'undefined') {\n            payload['ttl'] = ttl;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    getTransaction(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                transactionId: paramsOrFirst\n            };\n        }\n        const transactionId = params.transactionId;\n        if (typeof transactionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"transactionId\"');\n        }\n        const apiPath = '/tablesdb/transactions/{transactionId}'.replace('{transactionId}', transactionId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updateTransaction(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                transactionId: paramsOrFirst,\n                commit: rest[0],\n                rollback: rest[1]\n            };\n        }\n        const transactionId = params.transactionId;\n        const commit = params.commit;\n        const rollback = params.rollback;\n        if (typeof transactionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"transactionId\"');\n        }\n        const apiPath = '/tablesdb/transactions/{transactionId}'.replace('{transactionId}', transactionId);\n        const payload = {};\n        if (typeof commit !== 'undefined') {\n            payload['commit'] = commit;\n        }\n        if (typeof rollback !== 'undefined') {\n            payload['rollback'] = rollback;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    deleteTransaction(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                transactionId: paramsOrFirst\n            };\n        }\n        const transactionId = params.transactionId;\n        if (typeof transactionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"transactionId\"');\n        }\n        const apiPath = '/tablesdb/transactions/{transactionId}'.replace('{transactionId}', transactionId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    createOperations(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                transactionId: paramsOrFirst,\n                operations: rest[0]\n            };\n        }\n        const transactionId = params.transactionId;\n        const operations = params.operations;\n        if (typeof transactionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"transactionId\"');\n        }\n        const apiPath = '/tablesdb/transactions/{transactionId}/operations'.replace('{transactionId}', transactionId);\n        const payload = {};\n        if (typeof operations !== 'undefined') {\n            payload['operations'] = operations;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    listRows(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                queries: rest[1],\n                transactionId: rest[2],\n                total: rest[3]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const queries = params.queries;\n        const transactionId = params.transactionId;\n        const total = params.total;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    createRow(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                rowId: rest[1],\n                data: rest[2],\n                permissions: rest[3],\n                transactionId: rest[4]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const rowId = params.rowId;\n        const data = params.data;\n        const permissions = params.permissions;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        if (typeof rowId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"rowId\"');\n        }\n        if (typeof data === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"data\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);\n        const payload = {};\n        if (typeof rowId !== 'undefined') {\n            payload['rowId'] = rowId;\n        }\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    getRow(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                rowId: rest[1],\n                queries: rest[2],\n                transactionId: rest[3]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const rowId = params.rowId;\n        const queries = params.queries;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        if (typeof rowId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"rowId\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId);\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    upsertRow(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                rowId: rest[1],\n                data: rest[2],\n                permissions: rest[3],\n                transactionId: rest[4]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const rowId = params.rowId;\n        const data = params.data;\n        const permissions = params.permissions;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        if (typeof rowId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"rowId\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId);\n        const payload = {};\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    updateRow(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                rowId: rest[1],\n                data: rest[2],\n                permissions: rest[3],\n                transactionId: rest[4]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const rowId = params.rowId;\n        const data = params.data;\n        const permissions = params.permissions;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        if (typeof rowId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"rowId\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId);\n        const payload = {};\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    deleteRow(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                rowId: rest[1],\n                transactionId: rest[2]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const rowId = params.rowId;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        if (typeof rowId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"rowId\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId);\n        const payload = {};\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    decrementRowColumn(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                rowId: rest[1],\n                column: rest[2],\n                value: rest[3],\n                min: rest[4],\n                transactionId: rest[5]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const rowId = params.rowId;\n        const column = params.column;\n        const value = params.value;\n        const min = params.min;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        if (typeof rowId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"rowId\"');\n        }\n        if (typeof column === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"column\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}/{column}/decrement'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId).replace('{column}', column);\n        const payload = {};\n        if (typeof value !== 'undefined') {\n            payload['value'] = value;\n        }\n        if (typeof min !== 'undefined') {\n            payload['min'] = min;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    incrementRowColumn(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                rowId: rest[1],\n                column: rest[2],\n                value: rest[3],\n                max: rest[4],\n                transactionId: rest[5]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const rowId = params.rowId;\n        const column = params.column;\n        const value = params.value;\n        const max = params.max;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        if (typeof rowId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"rowId\"');\n        }\n        if (typeof column === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"column\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}/{column}/increment'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId).replace('{column}', column);\n        const payload = {};\n        if (typeof value !== 'undefined') {\n            payload['value'] = value;\n        }\n        if (typeof max !== 'undefined') {\n            payload['max'] = max;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n}\n\nclass Teams {\n    constructor(client) {\n        this.client = client;\n    }\n    list(paramsOrFirst, ...rest) {\n        let params;\n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                queries: paramsOrFirst,\n                search: rest[0],\n                total: rest[1]\n            };\n        }\n        const queries = params.queries;\n        const search = params.search;\n        const total = params.total;\n        const apiPath = '/teams';\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    create(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                name: rest[0],\n                roles: rest[1]\n            };\n        }\n        const teamId = params.teamId;\n        const name = params.name;\n        const roles = params.roles;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        const apiPath = '/teams';\n        const payload = {};\n        if (typeof teamId !== 'undefined') {\n            payload['teamId'] = teamId;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof roles !== 'undefined') {\n            payload['roles'] = roles;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    get(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst\n            };\n        }\n        const teamId = params.teamId;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updateName(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                name: rest[0]\n            };\n        }\n        const teamId = params.teamId;\n        const name = params.name;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);\n        const payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    delete(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst\n            };\n        }\n        const teamId = params.teamId;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    listMemberships(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                queries: rest[0],\n                search: rest[1],\n                total: rest[2]\n            };\n        }\n        const teamId = params.teamId;\n        const queries = params.queries;\n        const search = params.search;\n        const total = params.total;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        const apiPath = '/teams/{teamId}/memberships'.replace('{teamId}', teamId);\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    createMembership(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                roles: rest[0],\n                email: rest[1],\n                userId: rest[2],\n                phone: rest[3],\n                url: rest[4],\n                name: rest[5]\n            };\n        }\n        const teamId = params.teamId;\n        const roles = params.roles;\n        const email = params.email;\n        const userId = params.userId;\n        const phone = params.phone;\n        const url = params.url;\n        const name = params.name;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof roles === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"roles\"');\n        }\n        const apiPath = '/teams/{teamId}/memberships'.replace('{teamId}', teamId);\n        const payload = {};\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof phone !== 'undefined') {\n            payload['phone'] = phone;\n        }\n        if (typeof roles !== 'undefined') {\n            payload['roles'] = roles;\n        }\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    getMembership(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                membershipId: rest[0]\n            };\n        }\n        const teamId = params.teamId;\n        const membershipId = params.membershipId;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof membershipId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n        const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updateMembership(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                membershipId: rest[0],\n                roles: rest[1]\n            };\n        }\n        const teamId = params.teamId;\n        const membershipId = params.membershipId;\n        const roles = params.roles;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof membershipId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n        if (typeof roles === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"roles\"');\n        }\n        const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n        const payload = {};\n        if (typeof roles !== 'undefined') {\n            payload['roles'] = roles;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    deleteMembership(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                membershipId: rest[0]\n            };\n        }\n        const teamId = params.teamId;\n        const membershipId = params.membershipId;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof membershipId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n        const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    updateMembershipStatus(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                membershipId: rest[0],\n                userId: rest[1],\n                secret: rest[2]\n            };\n        }\n        const teamId = params.teamId;\n        const membershipId = params.membershipId;\n        const userId = params.userId;\n        const secret = params.secret;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof membershipId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        const apiPath = '/teams/{teamId}/memberships/{membershipId}/status'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    getPrefs(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst\n            };\n        }\n        const teamId = params.teamId;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        const apiPath = '/teams/{teamId}/prefs'.replace('{teamId}', teamId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updatePrefs(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                prefs: rest[0]\n            };\n        }\n        const teamId = params.teamId;\n        const prefs = params.prefs;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof prefs === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"prefs\"');\n        }\n        const apiPath = '/teams/{teamId}/prefs'.replace('{teamId}', teamId);\n        const payload = {};\n        if (typeof prefs !== 'undefined') {\n            payload['prefs'] = prefs;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n}\n\nvar RealtimeCode;\n(function (RealtimeCode) {\n    RealtimeCode[RealtimeCode[\"NORMAL_CLOSURE\"] = 1000] = \"NORMAL_CLOSURE\";\n    RealtimeCode[RealtimeCode[\"POLICY_VIOLATION\"] = 1008] = \"POLICY_VIOLATION\";\n    RealtimeCode[RealtimeCode[\"UNKNOWN_ERROR\"] = -1] = \"UNKNOWN_ERROR\";\n})(RealtimeCode || (RealtimeCode = {}));\nclass Realtime {\n    constructor(client) {\n        this.TYPE_ERROR = 'error';\n        this.TYPE_EVENT = 'event';\n        this.TYPE_PONG = 'pong';\n        this.TYPE_CONNECTED = 'connected';\n        this.DEBOUNCE_MS = 1;\n        this.HEARTBEAT_INTERVAL = 20000; // 20 seconds in milliseconds\n        this.activeChannels = new Set();\n        this.activeSubscriptions = new Map();\n        this.subCallDepth = 0;\n        this.reconnectAttempts = 0;\n        this.subscriptionsCounter = 0;\n        this.reconnect = true;\n        this.onErrorCallbacks = [];\n        this.onCloseCallbacks = [];\n        this.onOpenCallbacks = [];\n        this.client = client;\n    }\n    /**\n     * Register a callback function to be called when an error occurs\n     *\n     * @param {Function} callback - Callback function to handle errors\n     * @returns {void}\n     */\n    onError(callback) {\n        this.onErrorCallbacks.push(callback);\n    }\n    /**\n     * Register a callback function to be called when the connection closes\n     *\n     * @param {Function} callback - Callback function to handle connection close\n     * @returns {void}\n     */\n    onClose(callback) {\n        this.onCloseCallbacks.push(callback);\n    }\n    /**\n     * Register a callback function to be called when the connection opens\n     *\n     * @param {Function} callback - Callback function to handle connection open\n     * @returns {void}\n     */\n    onOpen(callback) {\n        this.onOpenCallbacks.push(callback);\n    }\n    startHeartbeat() {\n        this.stopHeartbeat();\n        this.heartbeatTimer = window.setInterval(() => {\n            if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n                this.socket.send(JSON.stringify({ type: 'ping' }));\n            }\n        }, this.HEARTBEAT_INTERVAL);\n    }\n    stopHeartbeat() {\n        if (this.heartbeatTimer) {\n            window.clearInterval(this.heartbeatTimer);\n            this.heartbeatTimer = undefined;\n        }\n    }\n    createSocket() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.activeChannels.size === 0) {\n                this.reconnect = false;\n                yield this.closeSocket();\n                return;\n            }\n            const projectId = this.client.config.project;\n            if (!projectId) {\n                throw new AppwriteException('Missing project ID');\n            }\n            let queryParams = `project=${projectId}`;\n            for (const channel of this.activeChannels) {\n                queryParams += `&channels[]=${encodeURIComponent(channel)}`;\n            }\n            const endpoint = this.client.config.endpointRealtime !== ''\n                ? this.client.config.endpointRealtime\n                : this.client.config.endpoint || '';\n            const realtimeEndpoint = endpoint\n                .replace('https://', 'wss://')\n                .replace('http://', 'ws://');\n            const url = `${realtimeEndpoint}/realtime?${queryParams}`;\n            if (this.socket) {\n                this.reconnect = false;\n                yield this.closeSocket();\n            }\n            return new Promise((resolve, reject) => {\n                try {\n                    this.socket = new WebSocket(url);\n                    this.socket.addEventListener('open', () => {\n                        this.reconnectAttempts = 0;\n                        this.onOpenCallbacks.forEach(callback => callback());\n                        this.startHeartbeat();\n                        resolve();\n                    });\n                    this.socket.addEventListener('message', (event) => {\n                        try {\n                            const message = JSON.parse(event.data);\n                            this.handleMessage(message);\n                        }\n                        catch (error) {\n                            console.error('Failed to parse message:', error);\n                        }\n                    });\n                    this.socket.addEventListener('close', (event) => __awaiter(this, void 0, void 0, function* () {\n                        this.stopHeartbeat();\n                        this.onCloseCallbacks.forEach(callback => callback());\n                        if (!this.reconnect || event.code === RealtimeCode.POLICY_VIOLATION) {\n                            this.reconnect = true;\n                            return;\n                        }\n                        const timeout = this.getTimeout();\n                        console.log(`Realtime disconnected. Re-connecting in ${timeout / 1000} seconds.`);\n                        yield this.sleep(timeout);\n                        this.reconnectAttempts++;\n                        try {\n                            yield this.createSocket();\n                        }\n                        catch (error) {\n                            console.error('Failed to reconnect:', error);\n                        }\n                    }));\n                    this.socket.addEventListener('error', (event) => {\n                        this.stopHeartbeat();\n                        const error = new Error('WebSocket error');\n                        console.error('WebSocket error:', error.message);\n                        this.onErrorCallbacks.forEach(callback => callback(error));\n                        reject(error);\n                    });\n                }\n                catch (error) {\n                    reject(error);\n                }\n            });\n        });\n    }\n    closeSocket() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.stopHeartbeat();\n            if (this.socket) {\n                return new Promise((resolve) => {\n                    if (!this.socket) {\n                        resolve();\n                        return;\n                    }\n                    if (this.socket.readyState === WebSocket.OPEN ||\n                        this.socket.readyState === WebSocket.CONNECTING) {\n                        this.socket.addEventListener('close', () => {\n                            resolve();\n                        }, { once: true });\n                        this.socket.close(RealtimeCode.NORMAL_CLOSURE);\n                    }\n                    else {\n                        resolve();\n                    }\n                });\n            }\n        });\n    }\n    getTimeout() {\n        if (this.reconnectAttempts < 5) {\n            return 1000;\n        }\n        else if (this.reconnectAttempts < 15) {\n            return 5000;\n        }\n        else if (this.reconnectAttempts < 100) {\n            return 10000;\n        }\n        else {\n            return 60000;\n        }\n    }\n    sleep(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n    subscribe(channelsOrChannel, callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const channels = Array.isArray(channelsOrChannel)\n                ? new Set(channelsOrChannel)\n                : new Set([channelsOrChannel]);\n            this.subscriptionsCounter++;\n            const count = this.subscriptionsCounter;\n            for (const channel of channels) {\n                this.activeChannels.add(channel);\n            }\n            this.activeSubscriptions.set(count, {\n                channels,\n                callback\n            });\n            this.subCallDepth++;\n            yield this.sleep(this.DEBOUNCE_MS);\n            if (this.subCallDepth === 1) {\n                yield this.createSocket();\n            }\n            this.subCallDepth--;\n            return {\n                close: () => __awaiter(this, void 0, void 0, function* () {\n                    this.activeSubscriptions.delete(count);\n                    this.cleanUp(channels);\n                    yield this.createSocket();\n                })\n            };\n        });\n    }\n    cleanUp(channels) {\n        this.activeChannels = new Set(Array.from(this.activeChannels).filter(channel => {\n            if (!channels.has(channel)) {\n                return true;\n            }\n            const subsWithChannel = Array.from(this.activeSubscriptions.values())\n                .filter(sub => sub.channels.has(channel));\n            return subsWithChannel.length > 0;\n        }));\n    }\n    handleMessage(message) {\n        if (!message.type) {\n            return;\n        }\n        switch (message.type) {\n            case this.TYPE_CONNECTED:\n                this.handleResponseConnected(message);\n                break;\n            case this.TYPE_ERROR:\n                this.handleResponseError(message);\n                break;\n            case this.TYPE_EVENT:\n                this.handleResponseEvent(message);\n                break;\n            case this.TYPE_PONG:\n                // Handle pong response if needed\n                break;\n        }\n    }\n    handleResponseConnected(message) {\n        var _a, _b;\n        if (!message.data) {\n            return;\n        }\n        const messageData = message.data;\n        let session = this.client.config.session;\n        if (!session) {\n            try {\n                const cookie = JSON.parse((_a = window.localStorage.getItem('cookieFallback')) !== null && _a !== void 0 ? _a : '{}');\n                session = cookie === null || cookie === void 0 ? void 0 : cookie[`a_session_${this.client.config.project}`];\n            }\n            catch (error) {\n                console.error('Failed to parse cookie fallback:', error);\n            }\n        }\n        if (session && !messageData.user) {\n            (_b = this.socket) === null || _b === void 0 ? void 0 : _b.send(JSON.stringify({\n                type: 'authentication',\n                data: {\n                    session\n                }\n            }));\n        }\n    }\n    handleResponseError(message) {\n        var _a, _b;\n        const error = new AppwriteException(((_a = message.data) === null || _a === void 0 ? void 0 : _a.message) || 'Unknown error');\n        const statusCode = (_b = message.data) === null || _b === void 0 ? void 0 : _b.code;\n        this.onErrorCallbacks.forEach(callback => callback(error, statusCode));\n    }\n    handleResponseEvent(message) {\n        const data = message.data;\n        if (!data) {\n            return;\n        }\n        const channels = data.channels;\n        const events = data.events;\n        const payload = data.payload;\n        const timestamp = data.timestamp;\n        if (!channels || !events || !payload) {\n            return;\n        }\n        const hasActiveChannel = channels.some(channel => this.activeChannels.has(channel));\n        if (!hasActiveChannel) {\n            return;\n        }\n        for (const [_, subscription] of this.activeSubscriptions) {\n            const hasSubscribedChannel = channels.some(channel => subscription.channels.has(channel));\n            if (hasSubscribedChannel) {\n                const response = {\n                    events,\n                    channels,\n                    timestamp,\n                    payload\n                };\n                subscription.callback(response);\n            }\n        }\n    }\n}\n\n/**\n * Helper class to generate permission strings for resources.\n */\nclass Permission {\n}\n/**\n * Generate read permission string for the provided role.\n *\n * @param {string} role\n * @returns {string}\n */\nPermission.read = (role) => {\n    return `read(\"${role}\")`;\n};\n/**\n * Generate write permission string for the provided role.\n *\n * This is an alias of update, delete, and possibly create.\n * Don't use write in combination with update, delete, or create.\n *\n * @param {string} role\n * @returns {string}\n */\nPermission.write = (role) => {\n    return `write(\"${role}\")`;\n};\n/**\n * Generate create permission string for the provided role.\n *\n * @param {string} role\n * @returns {string}\n */\nPermission.create = (role) => {\n    return `create(\"${role}\")`;\n};\n/**\n * Generate update permission string for the provided role.\n *\n * @param {string} role\n * @returns {string}\n */\nPermission.update = (role) => {\n    return `update(\"${role}\")`;\n};\n/**\n * Generate delete permission string for the provided role.\n *\n * @param {string} role\n * @returns {string}\n */\nPermission.delete = (role) => {\n    return `delete(\"${role}\")`;\n};\n\n/**\n * Helper class to generate role strings for `Permission`.\n */\nclass Role {\n    /**\n     * Grants access to anyone.\n     *\n     * This includes authenticated and unauthenticated users.\n     *\n     * @returns {string}\n     */\n    static any() {\n        return 'any';\n    }\n    /**\n     * Grants access to a specific user by user ID.\n     *\n     * You can optionally pass verified or unverified for\n     * `status` to target specific types of users.\n     *\n     * @param {string} id\n     * @param {string} status\n     * @returns {string}\n     */\n    static user(id, status = '') {\n        if (status === '') {\n            return `user:${id}`;\n        }\n        return `user:${id}/${status}`;\n    }\n    /**\n     * Grants access to any authenticated or anonymous user.\n     *\n     * You can optionally pass verified or unverified for\n     * `status` to target specific types of users.\n     *\n     * @param {string} status\n     * @returns {string}\n     */\n    static users(status = '') {\n        if (status === '') {\n            return 'users';\n        }\n        return `users/${status}`;\n    }\n    /**\n     * Grants access to any guest user without a session.\n     *\n     * Authenticated users don't have access to this role.\n     *\n     * @returns {string}\n     */\n    static guests() {\n        return 'guests';\n    }\n    /**\n     * Grants access to a team by team ID.\n     *\n     * You can optionally pass a role for `role` to target\n     * team members with the specified role.\n     *\n     * @param {string} id\n     * @param {string} role\n     * @returns {string}\n     */\n    static team(id, role = '') {\n        if (role === '') {\n            return `team:${id}`;\n        }\n        return `team:${id}/${role}`;\n    }\n    /**\n     * Grants access to a specific member of a team.\n     *\n     * When the member is removed from the team, they will\n     * no longer have access.\n     *\n     * @param {string} id\n     * @returns {string}\n     */\n    static member(id) {\n        return `member:${id}`;\n    }\n    /**\n     * Grants access to a user with the specified label.\n     *\n     * @param {string} name\n     * @returns  {string}\n     */\n    static label(name) {\n        return `label:${name}`;\n    }\n}\n\nvar _a, _ID_hexTimestamp;\n/**\n * Helper class to generate ID strings for resources.\n */\nclass ID {\n    /**\n     * Uses the provided ID as the ID for the resource.\n     *\n     * @param {string} id\n     * @returns {string}\n     */\n    static custom(id) {\n        return id;\n    }\n    /**\n     * Have Appwrite generate a unique ID for you.\n     *\n     * @param {number} padding. Default is 7.\n     * @returns {string}\n     */\n    static unique(padding = 7) {\n        // Generate a unique ID with padding to have a longer ID\n        const baseId = __classPrivateFieldGet(ID, _a, \"m\", _ID_hexTimestamp).call(ID);\n        let randomPadding = '';\n        for (let i = 0; i < padding; i++) {\n            const randomHexDigit = Math.floor(Math.random() * 16).toString(16);\n            randomPadding += randomHexDigit;\n        }\n        return baseId + randomPadding;\n    }\n}\n_a = ID, _ID_hexTimestamp = function _ID_hexTimestamp() {\n    const now = new Date();\n    const sec = Math.floor(now.getTime() / 1000);\n    const msec = now.getMilliseconds();\n    // Convert to hexadecimal\n    const hexTimestamp = sec.toString(16) + msec.toString(16).padStart(5, '0');\n    return hexTimestamp;\n};\n\nvar Condition;\n(function (Condition) {\n    Condition[\"Equal\"] = \"equal\";\n    Condition[\"NotEqual\"] = \"notEqual\";\n    Condition[\"GreaterThan\"] = \"greaterThan\";\n    Condition[\"GreaterThanEqual\"] = \"greaterThanEqual\";\n    Condition[\"LessThan\"] = \"lessThan\";\n    Condition[\"LessThanEqual\"] = \"lessThanEqual\";\n    Condition[\"Contains\"] = \"contains\";\n    Condition[\"IsNull\"] = \"isNull\";\n    Condition[\"IsNotNull\"] = \"isNotNull\";\n})(Condition || (Condition = {}));\n/**\n * Helper class to generate operator strings for atomic operations.\n */\nclass Operator {\n    /**\n     * Constructor for Operator class.\n     *\n     * @param {string} method\n     * @param {OperatorValues} values\n     */\n    constructor(method, values) {\n        this.method = method;\n        if (values !== undefined) {\n            if (Array.isArray(values)) {\n                this.values = values;\n            }\n            else {\n                this.values = [values];\n            }\n        }\n    }\n    /**\n     * Convert the operator object to a JSON string.\n     *\n     * @returns {string}\n     */\n    toString() {\n        return JSON.stringify({\n            method: this.method,\n            values: this.values,\n        });\n    }\n}\n/**\n * Increment a numeric attribute by a specified value.\n *\n * @param {number} value\n * @param {number} max\n * @returns {string}\n */\nOperator.increment = (value = 1, max) => {\n    if (isNaN(value) || !isFinite(value)) {\n        throw new Error(\"Value cannot be NaN or Infinity\");\n    }\n    if (max !== undefined && (isNaN(max) || !isFinite(max))) {\n        throw new Error(\"Max cannot be NaN or Infinity\");\n    }\n    const values = [value];\n    if (max !== undefined) {\n        values.push(max);\n    }\n    return new Operator(\"increment\", values).toString();\n};\n/**\n * Decrement a numeric attribute by a specified value.\n *\n * @param {number} value\n * @param {number} min\n * @returns {string}\n */\nOperator.decrement = (value = 1, min) => {\n    if (isNaN(value) || !isFinite(value)) {\n        throw new Error(\"Value cannot be NaN or Infinity\");\n    }\n    if (min !== undefined && (isNaN(min) || !isFinite(min))) {\n        throw new Error(\"Min cannot be NaN or Infinity\");\n    }\n    const values = [value];\n    if (min !== undefined) {\n        values.push(min);\n    }\n    return new Operator(\"decrement\", values).toString();\n};\n/**\n * Multiply a numeric attribute by a specified factor.\n *\n * @param {number} factor\n * @param {number} max\n * @returns {string}\n */\nOperator.multiply = (factor, max) => {\n    if (isNaN(factor) || !isFinite(factor)) {\n        throw new Error(\"Factor cannot be NaN or Infinity\");\n    }\n    if (max !== undefined && (isNaN(max) || !isFinite(max))) {\n        throw new Error(\"Max cannot be NaN or Infinity\");\n    }\n    const values = [factor];\n    if (max !== undefined) {\n        values.push(max);\n    }\n    return new Operator(\"multiply\", values).toString();\n};\n/**\n * Divide a numeric attribute by a specified divisor.\n *\n * @param {number} divisor\n * @param {number} min\n * @returns {string}\n */\nOperator.divide = (divisor, min) => {\n    if (isNaN(divisor) || !isFinite(divisor)) {\n        throw new Error(\"Divisor cannot be NaN or Infinity\");\n    }\n    if (min !== undefined && (isNaN(min) || !isFinite(min))) {\n        throw new Error(\"Min cannot be NaN or Infinity\");\n    }\n    if (divisor === 0) {\n        throw new Error(\"Divisor cannot be zero\");\n    }\n    const values = [divisor];\n    if (min !== undefined) {\n        values.push(min);\n    }\n    return new Operator(\"divide\", values).toString();\n};\n/**\n * Apply modulo operation on a numeric attribute.\n *\n * @param {number} divisor\n * @returns {string}\n */\nOperator.modulo = (divisor) => {\n    if (isNaN(divisor) || !isFinite(divisor)) {\n        throw new Error(\"Divisor cannot be NaN or Infinity\");\n    }\n    if (divisor === 0) {\n        throw new Error(\"Divisor cannot be zero\");\n    }\n    return new Operator(\"modulo\", [divisor]).toString();\n};\n/**\n * Raise a numeric attribute to a specified power.\n *\n * @param {number} exponent\n * @param {number} max\n * @returns {string}\n */\nOperator.power = (exponent, max) => {\n    if (isNaN(exponent) || !isFinite(exponent)) {\n        throw new Error(\"Exponent cannot be NaN or Infinity\");\n    }\n    if (max !== undefined && (isNaN(max) || !isFinite(max))) {\n        throw new Error(\"Max cannot be NaN or Infinity\");\n    }\n    const values = [exponent];\n    if (max !== undefined) {\n        values.push(max);\n    }\n    return new Operator(\"power\", values).toString();\n};\n/**\n * Append values to an array attribute.\n *\n * @param {any[]} values\n * @returns {string}\n */\nOperator.arrayAppend = (values) => new Operator(\"arrayAppend\", values).toString();\n/**\n * Prepend values to an array attribute.\n *\n * @param {any[]} values\n * @returns {string}\n */\nOperator.arrayPrepend = (values) => new Operator(\"arrayPrepend\", values).toString();\n/**\n * Insert a value at a specific index in an array attribute.\n *\n * @param {number} index\n * @param {any} value\n * @returns {string}\n */\nOperator.arrayInsert = (index, value) => new Operator(\"arrayInsert\", [index, value]).toString();\n/**\n * Remove a value from an array attribute.\n *\n * @param {any} value\n * @returns {string}\n */\nOperator.arrayRemove = (value) => new Operator(\"arrayRemove\", [value]).toString();\n/**\n * Remove duplicate values from an array attribute.\n *\n * @returns {string}\n */\nOperator.arrayUnique = () => new Operator(\"arrayUnique\", []).toString();\n/**\n * Keep only values that exist in both the current array and the provided array.\n *\n * @param {any[]} values\n * @returns {string}\n */\nOperator.arrayIntersect = (values) => new Operator(\"arrayIntersect\", values).toString();\n/**\n * Remove values from the array that exist in the provided array.\n *\n * @param {any[]} values\n * @returns {string}\n */\nOperator.arrayDiff = (values) => new Operator(\"arrayDiff\", values).toString();\n/**\n * Filter array values based on a condition.\n *\n * @param {Condition} condition\n * @param {any} value\n * @returns {string}\n */\nOperator.arrayFilter = (condition, value) => {\n    const values = [condition, value === undefined ? null : value];\n    return new Operator(\"arrayFilter\", values).toString();\n};\n/**\n * Concatenate a value to a string or array attribute.\n *\n * @param {any} value\n * @returns {string}\n */\nOperator.stringConcat = (value) => new Operator(\"stringConcat\", [value]).toString();\n/**\n * Replace occurrences of a search string with a replacement string.\n *\n * @param {string} search\n * @param {string} replace\n * @returns {string}\n */\nOperator.stringReplace = (search, replace) => new Operator(\"stringReplace\", [search, replace]).toString();\n/**\n * Toggle a boolean attribute.\n *\n * @returns {string}\n */\nOperator.toggle = () => new Operator(\"toggle\", []).toString();\n/**\n * Add days to a date attribute.\n *\n * @param {number} days\n * @returns {string}\n */\nOperator.dateAddDays = (days) => new Operator(\"dateAddDays\", [days]).toString();\n/**\n * Subtract days from a date attribute.\n *\n * @param {number} days\n * @returns {string}\n */\nOperator.dateSubDays = (days) => new Operator(\"dateSubDays\", [days]).toString();\n/**\n * Set a date attribute to the current date and time.\n *\n * @returns {string}\n */\nOperator.dateSetNow = () => new Operator(\"dateSetNow\", []).toString();\n\nvar AuthenticatorType;\n(function (AuthenticatorType) {\n    AuthenticatorType[\"Totp\"] = \"totp\";\n})(AuthenticatorType || (AuthenticatorType = {}));\n\nvar AuthenticationFactor;\n(function (AuthenticationFactor) {\n    AuthenticationFactor[\"Email\"] = \"email\";\n    AuthenticationFactor[\"Phone\"] = \"phone\";\n    AuthenticationFactor[\"Totp\"] = \"totp\";\n    AuthenticationFactor[\"Recoverycode\"] = \"recoverycode\";\n})(AuthenticationFactor || (AuthenticationFactor = {}));\n\nvar OAuthProvider;\n(function (OAuthProvider) {\n    OAuthProvider[\"Amazon\"] = \"amazon\";\n    OAuthProvider[\"Apple\"] = \"apple\";\n    OAuthProvider[\"Auth0\"] = \"auth0\";\n    OAuthProvider[\"Authentik\"] = \"authentik\";\n    OAuthProvider[\"Autodesk\"] = \"autodesk\";\n    OAuthProvider[\"Bitbucket\"] = \"bitbucket\";\n    OAuthProvider[\"Bitly\"] = \"bitly\";\n    OAuthProvider[\"Box\"] = \"box\";\n    OAuthProvider[\"Dailymotion\"] = \"dailymotion\";\n    OAuthProvider[\"Discord\"] = \"discord\";\n    OAuthProvider[\"Disqus\"] = \"disqus\";\n    OAuthProvider[\"Dropbox\"] = \"dropbox\";\n    OAuthProvider[\"Etsy\"] = \"etsy\";\n    OAuthProvider[\"Facebook\"] = \"facebook\";\n    OAuthProvider[\"Figma\"] = \"figma\";\n    OAuthProvider[\"Github\"] = \"github\";\n    OAuthProvider[\"Gitlab\"] = \"gitlab\";\n    OAuthProvider[\"Google\"] = \"google\";\n    OAuthProvider[\"Linkedin\"] = \"linkedin\";\n    OAuthProvider[\"Microsoft\"] = \"microsoft\";\n    OAuthProvider[\"Notion\"] = \"notion\";\n    OAuthProvider[\"Oidc\"] = \"oidc\";\n    OAuthProvider[\"Okta\"] = \"okta\";\n    OAuthProvider[\"Paypal\"] = \"paypal\";\n    OAuthProvider[\"PaypalSandbox\"] = \"paypalSandbox\";\n    OAuthProvider[\"Podio\"] = \"podio\";\n    OAuthProvider[\"Salesforce\"] = \"salesforce\";\n    OAuthProvider[\"Slack\"] = \"slack\";\n    OAuthProvider[\"Spotify\"] = \"spotify\";\n    OAuthProvider[\"Stripe\"] = \"stripe\";\n    OAuthProvider[\"Tradeshift\"] = \"tradeshift\";\n    OAuthProvider[\"TradeshiftBox\"] = \"tradeshiftBox\";\n    OAuthProvider[\"Twitch\"] = \"twitch\";\n    OAuthProvider[\"Wordpress\"] = \"wordpress\";\n    OAuthProvider[\"Yahoo\"] = \"yahoo\";\n    OAuthProvider[\"Yammer\"] = \"yammer\";\n    OAuthProvider[\"Yandex\"] = \"yandex\";\n    OAuthProvider[\"Zoho\"] = \"zoho\";\n    OAuthProvider[\"Zoom\"] = \"zoom\";\n    OAuthProvider[\"Mock\"] = \"mock\";\n})(OAuthProvider || (OAuthProvider = {}));\n\nvar Browser;\n(function (Browser) {\n    Browser[\"AvantBrowser\"] = \"aa\";\n    Browser[\"AndroidWebViewBeta\"] = \"an\";\n    Browser[\"GoogleChrome\"] = \"ch\";\n    Browser[\"GoogleChromeIOS\"] = \"ci\";\n    Browser[\"GoogleChromeMobile\"] = \"cm\";\n    Browser[\"Chromium\"] = \"cr\";\n    Browser[\"MozillaFirefox\"] = \"ff\";\n    Browser[\"Safari\"] = \"sf\";\n    Browser[\"MobileSafari\"] = \"mf\";\n    Browser[\"MicrosoftEdge\"] = \"ps\";\n    Browser[\"MicrosoftEdgeIOS\"] = \"oi\";\n    Browser[\"OperaMini\"] = \"om\";\n    Browser[\"Opera\"] = \"op\";\n    Browser[\"OperaNext\"] = \"on\";\n})(Browser || (Browser = {}));\n\nvar CreditCard;\n(function (CreditCard) {\n    CreditCard[\"AmericanExpress\"] = \"amex\";\n    CreditCard[\"Argencard\"] = \"argencard\";\n    CreditCard[\"Cabal\"] = \"cabal\";\n    CreditCard[\"Cencosud\"] = \"cencosud\";\n    CreditCard[\"DinersClub\"] = \"diners\";\n    CreditCard[\"Discover\"] = \"discover\";\n    CreditCard[\"Elo\"] = \"elo\";\n    CreditCard[\"Hipercard\"] = \"hipercard\";\n    CreditCard[\"JCB\"] = \"jcb\";\n    CreditCard[\"Mastercard\"] = \"mastercard\";\n    CreditCard[\"Naranja\"] = \"naranja\";\n    CreditCard[\"TarjetaShopping\"] = \"targeta-shopping\";\n    CreditCard[\"UnionPay\"] = \"unionpay\";\n    CreditCard[\"Visa\"] = \"visa\";\n    CreditCard[\"MIR\"] = \"mir\";\n    CreditCard[\"Maestro\"] = \"maestro\";\n    CreditCard[\"Rupay\"] = \"rupay\";\n})(CreditCard || (CreditCard = {}));\n\nvar Flag;\n(function (Flag) {\n    Flag[\"Afghanistan\"] = \"af\";\n    Flag[\"Angola\"] = \"ao\";\n    Flag[\"Albania\"] = \"al\";\n    Flag[\"Andorra\"] = \"ad\";\n    Flag[\"UnitedArabEmirates\"] = \"ae\";\n    Flag[\"Argentina\"] = \"ar\";\n    Flag[\"Armenia\"] = \"am\";\n    Flag[\"AntiguaAndBarbuda\"] = \"ag\";\n    Flag[\"Australia\"] = \"au\";\n    Flag[\"Austria\"] = \"at\";\n    Flag[\"Azerbaijan\"] = \"az\";\n    Flag[\"Burundi\"] = \"bi\";\n    Flag[\"Belgium\"] = \"be\";\n    Flag[\"Benin\"] = \"bj\";\n    Flag[\"BurkinaFaso\"] = \"bf\";\n    Flag[\"Bangladesh\"] = \"bd\";\n    Flag[\"Bulgaria\"] = \"bg\";\n    Flag[\"Bahrain\"] = \"bh\";\n    Flag[\"Bahamas\"] = \"bs\";\n    Flag[\"BosniaAndHerzegovina\"] = \"ba\";\n    Flag[\"Belarus\"] = \"by\";\n    Flag[\"Belize\"] = \"bz\";\n    Flag[\"Bolivia\"] = \"bo\";\n    Flag[\"Brazil\"] = \"br\";\n    Flag[\"Barbados\"] = \"bb\";\n    Flag[\"BruneiDarussalam\"] = \"bn\";\n    Flag[\"Bhutan\"] = \"bt\";\n    Flag[\"Botswana\"] = \"bw\";\n    Flag[\"CentralAfricanRepublic\"] = \"cf\";\n    Flag[\"Canada\"] = \"ca\";\n    Flag[\"Switzerland\"] = \"ch\";\n    Flag[\"Chile\"] = \"cl\";\n    Flag[\"China\"] = \"cn\";\n    Flag[\"CoteDIvoire\"] = \"ci\";\n    Flag[\"Cameroon\"] = \"cm\";\n    Flag[\"DemocraticRepublicOfTheCongo\"] = \"cd\";\n    Flag[\"RepublicOfTheCongo\"] = \"cg\";\n    Flag[\"Colombia\"] = \"co\";\n    Flag[\"Comoros\"] = \"km\";\n    Flag[\"CapeVerde\"] = \"cv\";\n    Flag[\"CostaRica\"] = \"cr\";\n    Flag[\"Cuba\"] = \"cu\";\n    Flag[\"Cyprus\"] = \"cy\";\n    Flag[\"CzechRepublic\"] = \"cz\";\n    Flag[\"Germany\"] = \"de\";\n    Flag[\"Djibouti\"] = \"dj\";\n    Flag[\"Dominica\"] = \"dm\";\n    Flag[\"Denmark\"] = \"dk\";\n    Flag[\"DominicanRepublic\"] = \"do\";\n    Flag[\"Algeria\"] = \"dz\";\n    Flag[\"Ecuador\"] = \"ec\";\n    Flag[\"Egypt\"] = \"eg\";\n    Flag[\"Eritrea\"] = \"er\";\n    Flag[\"Spain\"] = \"es\";\n    Flag[\"Estonia\"] = \"ee\";\n    Flag[\"Ethiopia\"] = \"et\";\n    Flag[\"Finland\"] = \"fi\";\n    Flag[\"Fiji\"] = \"fj\";\n    Flag[\"France\"] = \"fr\";\n    Flag[\"MicronesiaFederatedStatesOf\"] = \"fm\";\n    Flag[\"Gabon\"] = \"ga\";\n    Flag[\"UnitedKingdom\"] = \"gb\";\n    Flag[\"Georgia\"] = \"ge\";\n    Flag[\"Ghana\"] = \"gh\";\n    Flag[\"Guinea\"] = \"gn\";\n    Flag[\"Gambia\"] = \"gm\";\n    Flag[\"GuineaBissau\"] = \"gw\";\n    Flag[\"EquatorialGuinea\"] = \"gq\";\n    Flag[\"Greece\"] = \"gr\";\n    Flag[\"Grenada\"] = \"gd\";\n    Flag[\"Guatemala\"] = \"gt\";\n    Flag[\"Guyana\"] = \"gy\";\n    Flag[\"Honduras\"] = \"hn\";\n    Flag[\"Croatia\"] = \"hr\";\n    Flag[\"Haiti\"] = \"ht\";\n    Flag[\"Hungary\"] = \"hu\";\n    Flag[\"Indonesia\"] = \"id\";\n    Flag[\"India\"] = \"in\";\n    Flag[\"Ireland\"] = \"ie\";\n    Flag[\"IranIslamicRepublicOf\"] = \"ir\";\n    Flag[\"Iraq\"] = \"iq\";\n    Flag[\"Iceland\"] = \"is\";\n    Flag[\"Israel\"] = \"il\";\n    Flag[\"Italy\"] = \"it\";\n    Flag[\"Jamaica\"] = \"jm\";\n    Flag[\"Jordan\"] = \"jo\";\n    Flag[\"Japan\"] = \"jp\";\n    Flag[\"Kazakhstan\"] = \"kz\";\n    Flag[\"Kenya\"] = \"ke\";\n    Flag[\"Kyrgyzstan\"] = \"kg\";\n    Flag[\"Cambodia\"] = \"kh\";\n    Flag[\"Kiribati\"] = \"ki\";\n    Flag[\"SaintKittsAndNevis\"] = \"kn\";\n    Flag[\"SouthKorea\"] = \"kr\";\n    Flag[\"Kuwait\"] = \"kw\";\n    Flag[\"LaoPeopleSDemocraticRepublic\"] = \"la\";\n    Flag[\"Lebanon\"] = \"lb\";\n    Flag[\"Liberia\"] = \"lr\";\n    Flag[\"Libya\"] = \"ly\";\n    Flag[\"SaintLucia\"] = \"lc\";\n    Flag[\"Liechtenstein\"] = \"li\";\n    Flag[\"SriLanka\"] = \"lk\";\n    Flag[\"Lesotho\"] = \"ls\";\n    Flag[\"Lithuania\"] = \"lt\";\n    Flag[\"Luxembourg\"] = \"lu\";\n    Flag[\"Latvia\"] = \"lv\";\n    Flag[\"Morocco\"] = \"ma\";\n    Flag[\"Monaco\"] = \"mc\";\n    Flag[\"Moldova\"] = \"md\";\n    Flag[\"Madagascar\"] = \"mg\";\n    Flag[\"Maldives\"] = \"mv\";\n    Flag[\"Mexico\"] = \"mx\";\n    Flag[\"MarshallIslands\"] = \"mh\";\n    Flag[\"NorthMacedonia\"] = \"mk\";\n    Flag[\"Mali\"] = \"ml\";\n    Flag[\"Malta\"] = \"mt\";\n    Flag[\"Myanmar\"] = \"mm\";\n    Flag[\"Montenegro\"] = \"me\";\n    Flag[\"Mongolia\"] = \"mn\";\n    Flag[\"Mozambique\"] = \"mz\";\n    Flag[\"Mauritania\"] = \"mr\";\n    Flag[\"Mauritius\"] = \"mu\";\n    Flag[\"Malawi\"] = \"mw\";\n    Flag[\"Malaysia\"] = \"my\";\n    Flag[\"Namibia\"] = \"na\";\n    Flag[\"Niger\"] = \"ne\";\n    Flag[\"Nigeria\"] = \"ng\";\n    Flag[\"Nicaragua\"] = \"ni\";\n    Flag[\"Netherlands\"] = \"nl\";\n    Flag[\"Norway\"] = \"no\";\n    Flag[\"Nepal\"] = \"np\";\n    Flag[\"Nauru\"] = \"nr\";\n    Flag[\"NewZealand\"] = \"nz\";\n    Flag[\"Oman\"] = \"om\";\n    Flag[\"Pakistan\"] = \"pk\";\n    Flag[\"Panama\"] = \"pa\";\n    Flag[\"Peru\"] = \"pe\";\n    Flag[\"Philippines\"] = \"ph\";\n    Flag[\"Palau\"] = \"pw\";\n    Flag[\"PapuaNewGuinea\"] = \"pg\";\n    Flag[\"Poland\"] = \"pl\";\n    Flag[\"FrenchPolynesia\"] = \"pf\";\n    Flag[\"NorthKorea\"] = \"kp\";\n    Flag[\"Portugal\"] = \"pt\";\n    Flag[\"Paraguay\"] = \"py\";\n    Flag[\"Qatar\"] = \"qa\";\n    Flag[\"Romania\"] = \"ro\";\n    Flag[\"Russia\"] = \"ru\";\n    Flag[\"Rwanda\"] = \"rw\";\n    Flag[\"SaudiArabia\"] = \"sa\";\n    Flag[\"Sudan\"] = \"sd\";\n    Flag[\"Senegal\"] = \"sn\";\n    Flag[\"Singapore\"] = \"sg\";\n    Flag[\"SolomonIslands\"] = \"sb\";\n    Flag[\"SierraLeone\"] = \"sl\";\n    Flag[\"ElSalvador\"] = \"sv\";\n    Flag[\"SanMarino\"] = \"sm\";\n    Flag[\"Somalia\"] = \"so\";\n    Flag[\"Serbia\"] = \"rs\";\n    Flag[\"SouthSudan\"] = \"ss\";\n    Flag[\"SaoTomeAndPrincipe\"] = \"st\";\n    Flag[\"Suriname\"] = \"sr\";\n    Flag[\"Slovakia\"] = \"sk\";\n    Flag[\"Slovenia\"] = \"si\";\n    Flag[\"Sweden\"] = \"se\";\n    Flag[\"Eswatini\"] = \"sz\";\n    Flag[\"Seychelles\"] = \"sc\";\n    Flag[\"Syria\"] = \"sy\";\n    Flag[\"Chad\"] = \"td\";\n    Flag[\"Togo\"] = \"tg\";\n    Flag[\"Thailand\"] = \"th\";\n    Flag[\"Tajikistan\"] = \"tj\";\n    Flag[\"Turkmenistan\"] = \"tm\";\n    Flag[\"TimorLeste\"] = \"tl\";\n    Flag[\"Tonga\"] = \"to\";\n    Flag[\"TrinidadAndTobago\"] = \"tt\";\n    Flag[\"Tunisia\"] = \"tn\";\n    Flag[\"Turkey\"] = \"tr\";\n    Flag[\"Tuvalu\"] = \"tv\";\n    Flag[\"Tanzania\"] = \"tz\";\n    Flag[\"Uganda\"] = \"ug\";\n    Flag[\"Ukraine\"] = \"ua\";\n    Flag[\"Uruguay\"] = \"uy\";\n    Flag[\"UnitedStates\"] = \"us\";\n    Flag[\"Uzbekistan\"] = \"uz\";\n    Flag[\"VaticanCity\"] = \"va\";\n    Flag[\"SaintVincentAndTheGrenadines\"] = \"vc\";\n    Flag[\"Venezuela\"] = \"ve\";\n    Flag[\"Vietnam\"] = \"vn\";\n    Flag[\"Vanuatu\"] = \"vu\";\n    Flag[\"Samoa\"] = \"ws\";\n    Flag[\"Yemen\"] = \"ye\";\n    Flag[\"SouthAfrica\"] = \"za\";\n    Flag[\"Zambia\"] = \"zm\";\n    Flag[\"Zimbabwe\"] = \"zw\";\n})(Flag || (Flag = {}));\n\nvar Theme;\n(function (Theme) {\n    Theme[\"Light\"] = \"light\";\n    Theme[\"Dark\"] = \"dark\";\n})(Theme || (Theme = {}));\n\nvar Timezone;\n(function (Timezone) {\n    Timezone[\"AfricaAbidjan\"] = \"africa/abidjan\";\n    Timezone[\"AfricaAccra\"] = \"africa/accra\";\n    Timezone[\"AfricaAddisAbaba\"] = \"africa/addis_ababa\";\n    Timezone[\"AfricaAlgiers\"] = \"africa/algiers\";\n    Timezone[\"AfricaAsmara\"] = \"africa/asmara\";\n    Timezone[\"AfricaBamako\"] = \"africa/bamako\";\n    Timezone[\"AfricaBangui\"] = \"africa/bangui\";\n    Timezone[\"AfricaBanjul\"] = \"africa/banjul\";\n    Timezone[\"AfricaBissau\"] = \"africa/bissau\";\n    Timezone[\"AfricaBlantyre\"] = \"africa/blantyre\";\n    Timezone[\"AfricaBrazzaville\"] = \"africa/brazzaville\";\n    Timezone[\"AfricaBujumbura\"] = \"africa/bujumbura\";\n    Timezone[\"AfricaCairo\"] = \"africa/cairo\";\n    Timezone[\"AfricaCasablanca\"] = \"africa/casablanca\";\n    Timezone[\"AfricaCeuta\"] = \"africa/ceuta\";\n    Timezone[\"AfricaConakry\"] = \"africa/conakry\";\n    Timezone[\"AfricaDakar\"] = \"africa/dakar\";\n    Timezone[\"AfricaDarEsSalaam\"] = \"africa/dar_es_salaam\";\n    Timezone[\"AfricaDjibouti\"] = \"africa/djibouti\";\n    Timezone[\"AfricaDouala\"] = \"africa/douala\";\n    Timezone[\"AfricaElAaiun\"] = \"africa/el_aaiun\";\n    Timezone[\"AfricaFreetown\"] = \"africa/freetown\";\n    Timezone[\"AfricaGaborone\"] = \"africa/gaborone\";\n    Timezone[\"AfricaHarare\"] = \"africa/harare\";\n    Timezone[\"AfricaJohannesburg\"] = \"africa/johannesburg\";\n    Timezone[\"AfricaJuba\"] = \"africa/juba\";\n    Timezone[\"AfricaKampala\"] = \"africa/kampala\";\n    Timezone[\"AfricaKhartoum\"] = \"africa/khartoum\";\n    Timezone[\"AfricaKigali\"] = \"africa/kigali\";\n    Timezone[\"AfricaKinshasa\"] = \"africa/kinshasa\";\n    Timezone[\"AfricaLagos\"] = \"africa/lagos\";\n    Timezone[\"AfricaLibreville\"] = \"africa/libreville\";\n    Timezone[\"AfricaLome\"] = \"africa/lome\";\n    Timezone[\"AfricaLuanda\"] = \"africa/luanda\";\n    Timezone[\"AfricaLubumbashi\"] = \"africa/lubumbashi\";\n    Timezone[\"AfricaLusaka\"] = \"africa/lusaka\";\n    Timezone[\"AfricaMalabo\"] = \"africa/malabo\";\n    Timezone[\"AfricaMaputo\"] = \"africa/maputo\";\n    Timezone[\"AfricaMaseru\"] = \"africa/maseru\";\n    Timezone[\"AfricaMbabane\"] = \"africa/mbabane\";\n    Timezone[\"AfricaMogadishu\"] = \"africa/mogadishu\";\n    Timezone[\"AfricaMonrovia\"] = \"africa/monrovia\";\n    Timezone[\"AfricaNairobi\"] = \"africa/nairobi\";\n    Timezone[\"AfricaNdjamena\"] = \"africa/ndjamena\";\n    Timezone[\"AfricaNiamey\"] = \"africa/niamey\";\n    Timezone[\"AfricaNouakchott\"] = \"africa/nouakchott\";\n    Timezone[\"AfricaOuagadougou\"] = \"africa/ouagadougou\";\n    Timezone[\"AfricaPortonovo\"] = \"africa/porto-novo\";\n    Timezone[\"AfricaSaoTome\"] = \"africa/sao_tome\";\n    Timezone[\"AfricaTripoli\"] = \"africa/tripoli\";\n    Timezone[\"AfricaTunis\"] = \"africa/tunis\";\n    Timezone[\"AfricaWindhoek\"] = \"africa/windhoek\";\n    Timezone[\"AmericaAdak\"] = \"america/adak\";\n    Timezone[\"AmericaAnchorage\"] = \"america/anchorage\";\n    Timezone[\"AmericaAnguilla\"] = \"america/anguilla\";\n    Timezone[\"AmericaAntigua\"] = \"america/antigua\";\n    Timezone[\"AmericaAraguaina\"] = \"america/araguaina\";\n    Timezone[\"AmericaArgentinaBuenosAires\"] = \"america/argentina/buenos_aires\";\n    Timezone[\"AmericaArgentinaCatamarca\"] = \"america/argentina/catamarca\";\n    Timezone[\"AmericaArgentinaCordoba\"] = \"america/argentina/cordoba\";\n    Timezone[\"AmericaArgentinaJujuy\"] = \"america/argentina/jujuy\";\n    Timezone[\"AmericaArgentinaLaRioja\"] = \"america/argentina/la_rioja\";\n    Timezone[\"AmericaArgentinaMendoza\"] = \"america/argentina/mendoza\";\n    Timezone[\"AmericaArgentinaRioGallegos\"] = \"america/argentina/rio_gallegos\";\n    Timezone[\"AmericaArgentinaSalta\"] = \"america/argentina/salta\";\n    Timezone[\"AmericaArgentinaSanJuan\"] = \"america/argentina/san_juan\";\n    Timezone[\"AmericaArgentinaSanLuis\"] = \"america/argentina/san_luis\";\n    Timezone[\"AmericaArgentinaTucuman\"] = \"america/argentina/tucuman\";\n    Timezone[\"AmericaArgentinaUshuaia\"] = \"america/argentina/ushuaia\";\n    Timezone[\"AmericaAruba\"] = \"america/aruba\";\n    Timezone[\"AmericaAsuncion\"] = \"america/asuncion\";\n    Timezone[\"AmericaAtikokan\"] = \"america/atikokan\";\n    Timezone[\"AmericaBahia\"] = \"america/bahia\";\n    Timezone[\"AmericaBahiaBanderas\"] = \"america/bahia_banderas\";\n    Timezone[\"AmericaBarbados\"] = \"america/barbados\";\n    Timezone[\"AmericaBelem\"] = \"america/belem\";\n    Timezone[\"AmericaBelize\"] = \"america/belize\";\n    Timezone[\"AmericaBlancsablon\"] = \"america/blanc-sablon\";\n    Timezone[\"AmericaBoaVista\"] = \"america/boa_vista\";\n    Timezone[\"AmericaBogota\"] = \"america/bogota\";\n    Timezone[\"AmericaBoise\"] = \"america/boise\";\n    Timezone[\"AmericaCambridgeBay\"] = \"america/cambridge_bay\";\n    Timezone[\"AmericaCampoGrande\"] = \"america/campo_grande\";\n    Timezone[\"AmericaCancun\"] = \"america/cancun\";\n    Timezone[\"AmericaCaracas\"] = \"america/caracas\";\n    Timezone[\"AmericaCayenne\"] = \"america/cayenne\";\n    Timezone[\"AmericaCayman\"] = \"america/cayman\";\n    Timezone[\"AmericaChicago\"] = \"america/chicago\";\n    Timezone[\"AmericaChihuahua\"] = \"america/chihuahua\";\n    Timezone[\"AmericaCiudadJuarez\"] = \"america/ciudad_juarez\";\n    Timezone[\"AmericaCostaRica\"] = \"america/costa_rica\";\n    Timezone[\"AmericaCoyhaique\"] = \"america/coyhaique\";\n    Timezone[\"AmericaCreston\"] = \"america/creston\";\n    Timezone[\"AmericaCuiaba\"] = \"america/cuiaba\";\n    Timezone[\"AmericaCuracao\"] = \"america/curacao\";\n    Timezone[\"AmericaDanmarkshavn\"] = \"america/danmarkshavn\";\n    Timezone[\"AmericaDawson\"] = \"america/dawson\";\n    Timezone[\"AmericaDawsonCreek\"] = \"america/dawson_creek\";\n    Timezone[\"AmericaDenver\"] = \"america/denver\";\n    Timezone[\"AmericaDetroit\"] = \"america/detroit\";\n    Timezone[\"AmericaDominica\"] = \"america/dominica\";\n    Timezone[\"AmericaEdmonton\"] = \"america/edmonton\";\n    Timezone[\"AmericaEirunepe\"] = \"america/eirunepe\";\n    Timezone[\"AmericaElSalvador\"] = \"america/el_salvador\";\n    Timezone[\"AmericaFortNelson\"] = \"america/fort_nelson\";\n    Timezone[\"AmericaFortaleza\"] = \"america/fortaleza\";\n    Timezone[\"AmericaGlaceBay\"] = \"america/glace_bay\";\n    Timezone[\"AmericaGooseBay\"] = \"america/goose_bay\";\n    Timezone[\"AmericaGrandTurk\"] = \"america/grand_turk\";\n    Timezone[\"AmericaGrenada\"] = \"america/grenada\";\n    Timezone[\"AmericaGuadeloupe\"] = \"america/guadeloupe\";\n    Timezone[\"AmericaGuatemala\"] = \"america/guatemala\";\n    Timezone[\"AmericaGuayaquil\"] = \"america/guayaquil\";\n    Timezone[\"AmericaGuyana\"] = \"america/guyana\";\n    Timezone[\"AmericaHalifax\"] = \"america/halifax\";\n    Timezone[\"AmericaHavana\"] = \"america/havana\";\n    Timezone[\"AmericaHermosillo\"] = \"america/hermosillo\";\n    Timezone[\"AmericaIndianaIndianapolis\"] = \"america/indiana/indianapolis\";\n    Timezone[\"AmericaIndianaKnox\"] = \"america/indiana/knox\";\n    Timezone[\"AmericaIndianaMarengo\"] = \"america/indiana/marengo\";\n    Timezone[\"AmericaIndianaPetersburg\"] = \"america/indiana/petersburg\";\n    Timezone[\"AmericaIndianaTellCity\"] = \"america/indiana/tell_city\";\n    Timezone[\"AmericaIndianaVevay\"] = \"america/indiana/vevay\";\n    Timezone[\"AmericaIndianaVincennes\"] = \"america/indiana/vincennes\";\n    Timezone[\"AmericaIndianaWinamac\"] = \"america/indiana/winamac\";\n    Timezone[\"AmericaInuvik\"] = \"america/inuvik\";\n    Timezone[\"AmericaIqaluit\"] = \"america/iqaluit\";\n    Timezone[\"AmericaJamaica\"] = \"america/jamaica\";\n    Timezone[\"AmericaJuneau\"] = \"america/juneau\";\n    Timezone[\"AmericaKentuckyLouisville\"] = \"america/kentucky/louisville\";\n    Timezone[\"AmericaKentuckyMonticello\"] = \"america/kentucky/monticello\";\n    Timezone[\"AmericaKralendijk\"] = \"america/kralendijk\";\n    Timezone[\"AmericaLaPaz\"] = \"america/la_paz\";\n    Timezone[\"AmericaLima\"] = \"america/lima\";\n    Timezone[\"AmericaLosAngeles\"] = \"america/los_angeles\";\n    Timezone[\"AmericaLowerPrinces\"] = \"america/lower_princes\";\n    Timezone[\"AmericaMaceio\"] = \"america/maceio\";\n    Timezone[\"AmericaManagua\"] = \"america/managua\";\n    Timezone[\"AmericaManaus\"] = \"america/manaus\";\n    Timezone[\"AmericaMarigot\"] = \"america/marigot\";\n    Timezone[\"AmericaMartinique\"] = \"america/martinique\";\n    Timezone[\"AmericaMatamoros\"] = \"america/matamoros\";\n    Timezone[\"AmericaMazatlan\"] = \"america/mazatlan\";\n    Timezone[\"AmericaMenominee\"] = \"america/menominee\";\n    Timezone[\"AmericaMerida\"] = \"america/merida\";\n    Timezone[\"AmericaMetlakatla\"] = \"america/metlakatla\";\n    Timezone[\"AmericaMexicoCity\"] = \"america/mexico_city\";\n    Timezone[\"AmericaMiquelon\"] = \"america/miquelon\";\n    Timezone[\"AmericaMoncton\"] = \"america/moncton\";\n    Timezone[\"AmericaMonterrey\"] = \"america/monterrey\";\n    Timezone[\"AmericaMontevideo\"] = \"america/montevideo\";\n    Timezone[\"AmericaMontserrat\"] = \"america/montserrat\";\n    Timezone[\"AmericaNassau\"] = \"america/nassau\";\n    Timezone[\"AmericaNewYork\"] = \"america/new_york\";\n    Timezone[\"AmericaNome\"] = \"america/nome\";\n    Timezone[\"AmericaNoronha\"] = \"america/noronha\";\n    Timezone[\"AmericaNorthDakotaBeulah\"] = \"america/north_dakota/beulah\";\n    Timezone[\"AmericaNorthDakotaCenter\"] = \"america/north_dakota/center\";\n    Timezone[\"AmericaNorthDakotaNewSalem\"] = \"america/north_dakota/new_salem\";\n    Timezone[\"AmericaNuuk\"] = \"america/nuuk\";\n    Timezone[\"AmericaOjinaga\"] = \"america/ojinaga\";\n    Timezone[\"AmericaPanama\"] = \"america/panama\";\n    Timezone[\"AmericaParamaribo\"] = \"america/paramaribo\";\n    Timezone[\"AmericaPhoenix\"] = \"america/phoenix\";\n    Timezone[\"AmericaPortauprince\"] = \"america/port-au-prince\";\n    Timezone[\"AmericaPortOfSpain\"] = \"america/port_of_spain\";\n    Timezone[\"AmericaPortoVelho\"] = \"america/porto_velho\";\n    Timezone[\"AmericaPuertoRico\"] = \"america/puerto_rico\";\n    Timezone[\"AmericaPuntaArenas\"] = \"america/punta_arenas\";\n    Timezone[\"AmericaRankinInlet\"] = \"america/rankin_inlet\";\n    Timezone[\"AmericaRecife\"] = \"america/recife\";\n    Timezone[\"AmericaRegina\"] = \"america/regina\";\n    Timezone[\"AmericaResolute\"] = \"america/resolute\";\n    Timezone[\"AmericaRioBranco\"] = \"america/rio_branco\";\n    Timezone[\"AmericaSantarem\"] = \"america/santarem\";\n    Timezone[\"AmericaSantiago\"] = \"america/santiago\";\n    Timezone[\"AmericaSantoDomingo\"] = \"america/santo_domingo\";\n    Timezone[\"AmericaSaoPaulo\"] = \"america/sao_paulo\";\n    Timezone[\"AmericaScoresbysund\"] = \"america/scoresbysund\";\n    Timezone[\"AmericaSitka\"] = \"america/sitka\";\n    Timezone[\"AmericaStBarthelemy\"] = \"america/st_barthelemy\";\n    Timezone[\"AmericaStJohns\"] = \"america/st_johns\";\n    Timezone[\"AmericaStKitts\"] = \"america/st_kitts\";\n    Timezone[\"AmericaStLucia\"] = \"america/st_lucia\";\n    Timezone[\"AmericaStThomas\"] = \"america/st_thomas\";\n    Timezone[\"AmericaStVincent\"] = \"america/st_vincent\";\n    Timezone[\"AmericaSwiftCurrent\"] = \"america/swift_current\";\n    Timezone[\"AmericaTegucigalpa\"] = \"america/tegucigalpa\";\n    Timezone[\"AmericaThule\"] = \"america/thule\";\n    Timezone[\"AmericaTijuana\"] = \"america/tijuana\";\n    Timezone[\"AmericaToronto\"] = \"america/toronto\";\n    Timezone[\"AmericaTortola\"] = \"america/tortola\";\n    Timezone[\"AmericaVancouver\"] = \"america/vancouver\";\n    Timezone[\"AmericaWhitehorse\"] = \"america/whitehorse\";\n    Timezone[\"AmericaWinnipeg\"] = \"america/winnipeg\";\n    Timezone[\"AmericaYakutat\"] = \"america/yakutat\";\n    Timezone[\"AntarcticaCasey\"] = \"antarctica/casey\";\n    Timezone[\"AntarcticaDavis\"] = \"antarctica/davis\";\n    Timezone[\"AntarcticaDumontdurville\"] = \"antarctica/dumontdurville\";\n    Timezone[\"AntarcticaMacquarie\"] = \"antarctica/macquarie\";\n    Timezone[\"AntarcticaMawson\"] = \"antarctica/mawson\";\n    Timezone[\"AntarcticaMcmurdo\"] = \"antarctica/mcmurdo\";\n    Timezone[\"AntarcticaPalmer\"] = \"antarctica/palmer\";\n    Timezone[\"AntarcticaRothera\"] = \"antarctica/rothera\";\n    Timezone[\"AntarcticaSyowa\"] = \"antarctica/syowa\";\n    Timezone[\"AntarcticaTroll\"] = \"antarctica/troll\";\n    Timezone[\"AntarcticaVostok\"] = \"antarctica/vostok\";\n    Timezone[\"ArcticLongyearbyen\"] = \"arctic/longyearbyen\";\n    Timezone[\"AsiaAden\"] = \"asia/aden\";\n    Timezone[\"AsiaAlmaty\"] = \"asia/almaty\";\n    Timezone[\"AsiaAmman\"] = \"asia/amman\";\n    Timezone[\"AsiaAnadyr\"] = \"asia/anadyr\";\n    Timezone[\"AsiaAqtau\"] = \"asia/aqtau\";\n    Timezone[\"AsiaAqtobe\"] = \"asia/aqtobe\";\n    Timezone[\"AsiaAshgabat\"] = \"asia/ashgabat\";\n    Timezone[\"AsiaAtyrau\"] = \"asia/atyrau\";\n    Timezone[\"AsiaBaghdad\"] = \"asia/baghdad\";\n    Timezone[\"AsiaBahrain\"] = \"asia/bahrain\";\n    Timezone[\"AsiaBaku\"] = \"asia/baku\";\n    Timezone[\"AsiaBangkok\"] = \"asia/bangkok\";\n    Timezone[\"AsiaBarnaul\"] = \"asia/barnaul\";\n    Timezone[\"AsiaBeirut\"] = \"asia/beirut\";\n    Timezone[\"AsiaBishkek\"] = \"asia/bishkek\";\n    Timezone[\"AsiaBrunei\"] = \"asia/brunei\";\n    Timezone[\"AsiaChita\"] = \"asia/chita\";\n    Timezone[\"AsiaColombo\"] = \"asia/colombo\";\n    Timezone[\"AsiaDamascus\"] = \"asia/damascus\";\n    Timezone[\"AsiaDhaka\"] = \"asia/dhaka\";\n    Timezone[\"AsiaDili\"] = \"asia/dili\";\n    Timezone[\"AsiaDubai\"] = \"asia/dubai\";\n    Timezone[\"AsiaDushanbe\"] = \"asia/dushanbe\";\n    Timezone[\"AsiaFamagusta\"] = \"asia/famagusta\";\n    Timezone[\"AsiaGaza\"] = \"asia/gaza\";\n    Timezone[\"AsiaHebron\"] = \"asia/hebron\";\n    Timezone[\"AsiaHoChiMinh\"] = \"asia/ho_chi_minh\";\n    Timezone[\"AsiaHongKong\"] = \"asia/hong_kong\";\n    Timezone[\"AsiaHovd\"] = \"asia/hovd\";\n    Timezone[\"AsiaIrkutsk\"] = \"asia/irkutsk\";\n    Timezone[\"AsiaJakarta\"] = \"asia/jakarta\";\n    Timezone[\"AsiaJayapura\"] = \"asia/jayapura\";\n    Timezone[\"AsiaJerusalem\"] = \"asia/jerusalem\";\n    Timezone[\"AsiaKabul\"] = \"asia/kabul\";\n    Timezone[\"AsiaKamchatka\"] = \"asia/kamchatka\";\n    Timezone[\"AsiaKarachi\"] = \"asia/karachi\";\n    Timezone[\"AsiaKathmandu\"] = \"asia/kathmandu\";\n    Timezone[\"AsiaKhandyga\"] = \"asia/khandyga\";\n    Timezone[\"AsiaKolkata\"] = \"asia/kolkata\";\n    Timezone[\"AsiaKrasnoyarsk\"] = \"asia/krasnoyarsk\";\n    Timezone[\"AsiaKualaLumpur\"] = \"asia/kuala_lumpur\";\n    Timezone[\"AsiaKuching\"] = \"asia/kuching\";\n    Timezone[\"AsiaKuwait\"] = \"asia/kuwait\";\n    Timezone[\"AsiaMacau\"] = \"asia/macau\";\n    Timezone[\"AsiaMagadan\"] = \"asia/magadan\";\n    Timezone[\"AsiaMakassar\"] = \"asia/makassar\";\n    Timezone[\"AsiaManila\"] = \"asia/manila\";\n    Timezone[\"AsiaMuscat\"] = \"asia/muscat\";\n    Timezone[\"AsiaNicosia\"] = \"asia/nicosia\";\n    Timezone[\"AsiaNovokuznetsk\"] = \"asia/novokuznetsk\";\n    Timezone[\"AsiaNovosibirsk\"] = \"asia/novosibirsk\";\n    Timezone[\"AsiaOmsk\"] = \"asia/omsk\";\n    Timezone[\"AsiaOral\"] = \"asia/oral\";\n    Timezone[\"AsiaPhnomPenh\"] = \"asia/phnom_penh\";\n    Timezone[\"AsiaPontianak\"] = \"asia/pontianak\";\n    Timezone[\"AsiaPyongyang\"] = \"asia/pyongyang\";\n    Timezone[\"AsiaQatar\"] = \"asia/qatar\";\n    Timezone[\"AsiaQostanay\"] = \"asia/qostanay\";\n    Timezone[\"AsiaQyzylorda\"] = \"asia/qyzylorda\";\n    Timezone[\"AsiaRiyadh\"] = \"asia/riyadh\";\n    Timezone[\"AsiaSakhalin\"] = \"asia/sakhalin\";\n    Timezone[\"AsiaSamarkand\"] = \"asia/samarkand\";\n    Timezone[\"AsiaSeoul\"] = \"asia/seoul\";\n    Timezone[\"AsiaShanghai\"] = \"asia/shanghai\";\n    Timezone[\"AsiaSingapore\"] = \"asia/singapore\";\n    Timezone[\"AsiaSrednekolymsk\"] = \"asia/srednekolymsk\";\n    Timezone[\"AsiaTaipei\"] = \"asia/taipei\";\n    Timezone[\"AsiaTashkent\"] = \"asia/tashkent\";\n    Timezone[\"AsiaTbilisi\"] = \"asia/tbilisi\";\n    Timezone[\"AsiaTehran\"] = \"asia/tehran\";\n    Timezone[\"AsiaThimphu\"] = \"asia/thimphu\";\n    Timezone[\"AsiaTokyo\"] = \"asia/tokyo\";\n    Timezone[\"AsiaTomsk\"] = \"asia/tomsk\";\n    Timezone[\"AsiaUlaanbaatar\"] = \"asia/ulaanbaatar\";\n    Timezone[\"AsiaUrumqi\"] = \"asia/urumqi\";\n    Timezone[\"AsiaUstnera\"] = \"asia/ust-nera\";\n    Timezone[\"AsiaVientiane\"] = \"asia/vientiane\";\n    Timezone[\"AsiaVladivostok\"] = \"asia/vladivostok\";\n    Timezone[\"AsiaYakutsk\"] = \"asia/yakutsk\";\n    Timezone[\"AsiaYangon\"] = \"asia/yangon\";\n    Timezone[\"AsiaYekaterinburg\"] = \"asia/yekaterinburg\";\n    Timezone[\"AsiaYerevan\"] = \"asia/yerevan\";\n    Timezone[\"AtlanticAzores\"] = \"atlantic/azores\";\n    Timezone[\"AtlanticBermuda\"] = \"atlantic/bermuda\";\n    Timezone[\"AtlanticCanary\"] = \"atlantic/canary\";\n    Timezone[\"AtlanticCapeVerde\"] = \"atlantic/cape_verde\";\n    Timezone[\"AtlanticFaroe\"] = \"atlantic/faroe\";\n    Timezone[\"AtlanticMadeira\"] = \"atlantic/madeira\";\n    Timezone[\"AtlanticReykjavik\"] = \"atlantic/reykjavik\";\n    Timezone[\"AtlanticSouthGeorgia\"] = \"atlantic/south_georgia\";\n    Timezone[\"AtlanticStHelena\"] = \"atlantic/st_helena\";\n    Timezone[\"AtlanticStanley\"] = \"atlantic/stanley\";\n    Timezone[\"AustraliaAdelaide\"] = \"australia/adelaide\";\n    Timezone[\"AustraliaBrisbane\"] = \"australia/brisbane\";\n    Timezone[\"AustraliaBrokenHill\"] = \"australia/broken_hill\";\n    Timezone[\"AustraliaDarwin\"] = \"australia/darwin\";\n    Timezone[\"AustraliaEucla\"] = \"australia/eucla\";\n    Timezone[\"AustraliaHobart\"] = \"australia/hobart\";\n    Timezone[\"AustraliaLindeman\"] = \"australia/lindeman\";\n    Timezone[\"AustraliaLordHowe\"] = \"australia/lord_howe\";\n    Timezone[\"AustraliaMelbourne\"] = \"australia/melbourne\";\n    Timezone[\"AustraliaPerth\"] = \"australia/perth\";\n    Timezone[\"AustraliaSydney\"] = \"australia/sydney\";\n    Timezone[\"EuropeAmsterdam\"] = \"europe/amsterdam\";\n    Timezone[\"EuropeAndorra\"] = \"europe/andorra\";\n    Timezone[\"EuropeAstrakhan\"] = \"europe/astrakhan\";\n    Timezone[\"EuropeAthens\"] = \"europe/athens\";\n    Timezone[\"EuropeBelgrade\"] = \"europe/belgrade\";\n    Timezone[\"EuropeBerlin\"] = \"europe/berlin\";\n    Timezone[\"EuropeBratislava\"] = \"europe/bratislava\";\n    Timezone[\"EuropeBrussels\"] = \"europe/brussels\";\n    Timezone[\"EuropeBucharest\"] = \"europe/bucharest\";\n    Timezone[\"EuropeBudapest\"] = \"europe/budapest\";\n    Timezone[\"EuropeBusingen\"] = \"europe/busingen\";\n    Timezone[\"EuropeChisinau\"] = \"europe/chisinau\";\n    Timezone[\"EuropeCopenhagen\"] = \"europe/copenhagen\";\n    Timezone[\"EuropeDublin\"] = \"europe/dublin\";\n    Timezone[\"EuropeGibraltar\"] = \"europe/gibraltar\";\n    Timezone[\"EuropeGuernsey\"] = \"europe/guernsey\";\n    Timezone[\"EuropeHelsinki\"] = \"europe/helsinki\";\n    Timezone[\"EuropeIsleOfMan\"] = \"europe/isle_of_man\";\n    Timezone[\"EuropeIstanbul\"] = \"europe/istanbul\";\n    Timezone[\"EuropeJersey\"] = \"europe/jersey\";\n    Timezone[\"EuropeKaliningrad\"] = \"europe/kaliningrad\";\n    Timezone[\"EuropeKirov\"] = \"europe/kirov\";\n    Timezone[\"EuropeKyiv\"] = \"europe/kyiv\";\n    Timezone[\"EuropeLisbon\"] = \"europe/lisbon\";\n    Timezone[\"EuropeLjubljana\"] = \"europe/ljubljana\";\n    Timezone[\"EuropeLondon\"] = \"europe/london\";\n    Timezone[\"EuropeLuxembourg\"] = \"europe/luxembourg\";\n    Timezone[\"EuropeMadrid\"] = \"europe/madrid\";\n    Timezone[\"EuropeMalta\"] = \"europe/malta\";\n    Timezone[\"EuropeMariehamn\"] = \"europe/mariehamn\";\n    Timezone[\"EuropeMinsk\"] = \"europe/minsk\";\n    Timezone[\"EuropeMonaco\"] = \"europe/monaco\";\n    Timezone[\"EuropeMoscow\"] = \"europe/moscow\";\n    Timezone[\"EuropeOslo\"] = \"europe/oslo\";\n    Timezone[\"EuropeParis\"] = \"europe/paris\";\n    Timezone[\"EuropePodgorica\"] = \"europe/podgorica\";\n    Timezone[\"EuropePrague\"] = \"europe/prague\";\n    Timezone[\"EuropeRiga\"] = \"europe/riga\";\n    Timezone[\"EuropeRome\"] = \"europe/rome\";\n    Timezone[\"EuropeSamara\"] = \"europe/samara\";\n    Timezone[\"EuropeSanMarino\"] = \"europe/san_marino\";\n    Timezone[\"EuropeSarajevo\"] = \"europe/sarajevo\";\n    Timezone[\"EuropeSaratov\"] = \"europe/saratov\";\n    Timezone[\"EuropeSimferopol\"] = \"europe/simferopol\";\n    Timezone[\"EuropeSkopje\"] = \"europe/skopje\";\n    Timezone[\"EuropeSofia\"] = \"europe/sofia\";\n    Timezone[\"EuropeStockholm\"] = \"europe/stockholm\";\n    Timezone[\"EuropeTallinn\"] = \"europe/tallinn\";\n    Timezone[\"EuropeTirane\"] = \"europe/tirane\";\n    Timezone[\"EuropeUlyanovsk\"] = \"europe/ulyanovsk\";\n    Timezone[\"EuropeVaduz\"] = \"europe/vaduz\";\n    Timezone[\"EuropeVatican\"] = \"europe/vatican\";\n    Timezone[\"EuropeVienna\"] = \"europe/vienna\";\n    Timezone[\"EuropeVilnius\"] = \"europe/vilnius\";\n    Timezone[\"EuropeVolgograd\"] = \"europe/volgograd\";\n    Timezone[\"EuropeWarsaw\"] = \"europe/warsaw\";\n    Timezone[\"EuropeZagreb\"] = \"europe/zagreb\";\n    Timezone[\"EuropeZurich\"] = \"europe/zurich\";\n    Timezone[\"IndianAntananarivo\"] = \"indian/antananarivo\";\n    Timezone[\"IndianChagos\"] = \"indian/chagos\";\n    Timezone[\"IndianChristmas\"] = \"indian/christmas\";\n    Timezone[\"IndianCocos\"] = \"indian/cocos\";\n    Timezone[\"IndianComoro\"] = \"indian/comoro\";\n    Timezone[\"IndianKerguelen\"] = \"indian/kerguelen\";\n    Timezone[\"IndianMahe\"] = \"indian/mahe\";\n    Timezone[\"IndianMaldives\"] = \"indian/maldives\";\n    Timezone[\"IndianMauritius\"] = \"indian/mauritius\";\n    Timezone[\"IndianMayotte\"] = \"indian/mayotte\";\n    Timezone[\"IndianReunion\"] = \"indian/reunion\";\n    Timezone[\"PacificApia\"] = \"pacific/apia\";\n    Timezone[\"PacificAuckland\"] = \"pacific/auckland\";\n    Timezone[\"PacificBougainville\"] = \"pacific/bougainville\";\n    Timezone[\"PacificChatham\"] = \"pacific/chatham\";\n    Timezone[\"PacificChuuk\"] = \"pacific/chuuk\";\n    Timezone[\"PacificEaster\"] = \"pacific/easter\";\n    Timezone[\"PacificEfate\"] = \"pacific/efate\";\n    Timezone[\"PacificFakaofo\"] = \"pacific/fakaofo\";\n    Timezone[\"PacificFiji\"] = \"pacific/fiji\";\n    Timezone[\"PacificFunafuti\"] = \"pacific/funafuti\";\n    Timezone[\"PacificGalapagos\"] = \"pacific/galapagos\";\n    Timezone[\"PacificGambier\"] = \"pacific/gambier\";\n    Timezone[\"PacificGuadalcanal\"] = \"pacific/guadalcanal\";\n    Timezone[\"PacificGuam\"] = \"pacific/guam\";\n    Timezone[\"PacificHonolulu\"] = \"pacific/honolulu\";\n    Timezone[\"PacificKanton\"] = \"pacific/kanton\";\n    Timezone[\"PacificKiritimati\"] = \"pacific/kiritimati\";\n    Timezone[\"PacificKosrae\"] = \"pacific/kosrae\";\n    Timezone[\"PacificKwajalein\"] = \"pacific/kwajalein\";\n    Timezone[\"PacificMajuro\"] = \"pacific/majuro\";\n    Timezone[\"PacificMarquesas\"] = \"pacific/marquesas\";\n    Timezone[\"PacificMidway\"] = \"pacific/midway\";\n    Timezone[\"PacificNauru\"] = \"pacific/nauru\";\n    Timezone[\"PacificNiue\"] = \"pacific/niue\";\n    Timezone[\"PacificNorfolk\"] = \"pacific/norfolk\";\n    Timezone[\"PacificNoumea\"] = \"pacific/noumea\";\n    Timezone[\"PacificPagoPago\"] = \"pacific/pago_pago\";\n    Timezone[\"PacificPalau\"] = \"pacific/palau\";\n    Timezone[\"PacificPitcairn\"] = \"pacific/pitcairn\";\n    Timezone[\"PacificPohnpei\"] = \"pacific/pohnpei\";\n    Timezone[\"PacificPortMoresby\"] = \"pacific/port_moresby\";\n    Timezone[\"PacificRarotonga\"] = \"pacific/rarotonga\";\n    Timezone[\"PacificSaipan\"] = \"pacific/saipan\";\n    Timezone[\"PacificTahiti\"] = \"pacific/tahiti\";\n    Timezone[\"PacificTarawa\"] = \"pacific/tarawa\";\n    Timezone[\"PacificTongatapu\"] = \"pacific/tongatapu\";\n    Timezone[\"PacificWake\"] = \"pacific/wake\";\n    Timezone[\"PacificWallis\"] = \"pacific/wallis\";\n    Timezone[\"Utc\"] = \"utc\";\n})(Timezone || (Timezone = {}));\n\nvar Output;\n(function (Output) {\n    Output[\"Jpg\"] = \"jpg\";\n    Output[\"Jpeg\"] = \"jpeg\";\n    Output[\"Png\"] = \"png\";\n    Output[\"Webp\"] = \"webp\";\n    Output[\"Heic\"] = \"heic\";\n    Output[\"Avif\"] = \"avif\";\n    Output[\"Gif\"] = \"gif\";\n})(Output || (Output = {}));\n\nvar ExecutionMethod;\n(function (ExecutionMethod) {\n    ExecutionMethod[\"GET\"] = \"GET\";\n    ExecutionMethod[\"POST\"] = \"POST\";\n    ExecutionMethod[\"PUT\"] = \"PUT\";\n    ExecutionMethod[\"PATCH\"] = \"PATCH\";\n    ExecutionMethod[\"DELETE\"] = \"DELETE\";\n    ExecutionMethod[\"OPTIONS\"] = \"OPTIONS\";\n    ExecutionMethod[\"HEAD\"] = \"HEAD\";\n})(ExecutionMethod || (ExecutionMethod = {}));\n\nvar ImageGravity;\n(function (ImageGravity) {\n    ImageGravity[\"Center\"] = \"center\";\n    ImageGravity[\"Topleft\"] = \"top-left\";\n    ImageGravity[\"Top\"] = \"top\";\n    ImageGravity[\"Topright\"] = \"top-right\";\n    ImageGravity[\"Left\"] = \"left\";\n    ImageGravity[\"Right\"] = \"right\";\n    ImageGravity[\"Bottomleft\"] = \"bottom-left\";\n    ImageGravity[\"Bottom\"] = \"bottom\";\n    ImageGravity[\"Bottomright\"] = \"bottom-right\";\n})(ImageGravity || (ImageGravity = {}));\n\nvar ImageFormat;\n(function (ImageFormat) {\n    ImageFormat[\"Jpg\"] = \"jpg\";\n    ImageFormat[\"Jpeg\"] = \"jpeg\";\n    ImageFormat[\"Png\"] = \"png\";\n    ImageFormat[\"Webp\"] = \"webp\";\n    ImageFormat[\"Heic\"] = \"heic\";\n    ImageFormat[\"Avif\"] = \"avif\";\n    ImageFormat[\"Gif\"] = \"gif\";\n})(ImageFormat || (ImageFormat = {}));\n\nvar ExecutionTrigger;\n(function (ExecutionTrigger) {\n    ExecutionTrigger[\"Http\"] = \"http\";\n    ExecutionTrigger[\"Schedule\"] = \"schedule\";\n    ExecutionTrigger[\"Event\"] = \"event\";\n})(ExecutionTrigger || (ExecutionTrigger = {}));\n\nvar ExecutionStatus;\n(function (ExecutionStatus) {\n    ExecutionStatus[\"Waiting\"] = \"waiting\";\n    ExecutionStatus[\"Processing\"] = \"processing\";\n    ExecutionStatus[\"Completed\"] = \"completed\";\n    ExecutionStatus[\"Failed\"] = \"failed\";\n    ExecutionStatus[\"Scheduled\"] = \"scheduled\";\n})(ExecutionStatus || (ExecutionStatus = {}));\n\n\n//# sourceMappingURL=sdk.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBwd3JpdGUvZGlzdC9lc20vc2RrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyxnQkFBZ0I7QUFDbkg7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSkFBbUo7QUFDbkosOEdBQThHLG9CQUFvQjtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELElBQUk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDJDQUEyQyxzQkFBc0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0Esb0RBQW9ELE1BQU0sR0FBRyxRQUFRLEdBQUcsVUFBVTtBQUNsRjtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYscUJBQXFCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsV0FBVyxZQUFZLFdBQVc7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsS0FBSyxZQUFZLEtBQUs7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsS0FBSyxZQUFZLEtBQUs7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELEtBQUssWUFBWSxLQUFLO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxLQUFLLFlBQVksS0FBSztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxLQUFLLFlBQVksS0FBSztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxLQUFLLFlBQVksS0FBSztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUyxZQUFZLFNBQVM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVSxZQUFZLFVBQVU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxVQUFVLFlBQVksVUFBVTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxVQUFVLFlBQVksVUFBVTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVMsaUJBQWlCLFNBQVM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUyxpQkFBaUIsU0FBUztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUyxZQUFZLFNBQVM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsS0FBSyxZQUFZLEtBQUs7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxLQUFLLFlBQVksS0FBSztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUssWUFBWSxLQUFLO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYyxZQUFZLGNBQWM7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWMsWUFBWSxjQUFjO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWMsWUFBWSxjQUFjO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjLHVCQUF1QixjQUFjO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxXQUFXLGNBQWMsYUFBYSxzQkFBc0IsV0FBVyx5QkFBeUIsYUFBYTtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsV0FBVyxjQUFjLGFBQWEsc0JBQXNCLFdBQVcseUJBQXlCLGFBQWE7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFdBQVcsY0FBYyxhQUFhLFlBQVksV0FBVyxZQUFZLFdBQVcseUJBQXlCLGFBQWEsMkJBQTJCLFdBQVc7QUFDck07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFdBQVcsY0FBYyxhQUFhLFlBQVksV0FBVyxZQUFZLFdBQVcseUJBQXlCLGFBQWEsMkJBQTJCLFdBQVc7QUFDck07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxXQUFXLGNBQWMsYUFBYSxZQUFZLFdBQVcsWUFBWSxXQUFXLHlCQUF5QixhQUFhLDJCQUEyQixXQUFXO0FBQ3JNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFdBQVcsY0FBYyxhQUFhLFlBQVksV0FBVyxZQUFZLFdBQVcseUJBQXlCLGFBQWEsMkJBQTJCLFdBQVc7QUFDck07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FB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QUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUSx3QkFBd0IsUUFBUTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPLFlBQVksT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPLFlBQVksT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPLFlBQVksT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlD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O0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLEtBQUs7QUFDaEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4Qzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvREFBb0Q7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQkFBc0I7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDOztBQUUrVTtBQUMxWCIsInNvdXJjZXMiOlsiL1VzZXJzL25pc2FyZ3BhdGVsL1dlYiBEZXZlbG9wbWVudC9Qcm9qZWN0L21lbnRvci1tZW50ZWUgcHJvamVjdC9tZWV0aW5ncy9ub2RlX21vZHVsZXMvYXBwd3JpdGUvZGlzdC9lc20vc2RrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB0byBnZW5lcmF0ZSBxdWVyeSBzdHJpbmdzLlxuICovXG5jbGFzcyBRdWVyeSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIFF1ZXJ5IGNsYXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuICAgICAqIEBwYXJhbSB7QXR0cmlidXRlc1R5cGVzfSBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0ge1F1ZXJ5VHlwZXN9IHZhbHVlc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgYXR0cmlidXRlLCB2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlID0gYXR0cmlidXRlO1xuICAgICAgICBpZiAodmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzID0gW3ZhbHVlc107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgcXVlcnkgb2JqZWN0IHRvIGEgSlNPTiBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgICAgICAgIGF0dHJpYnV0ZTogdGhpcy5hdHRyaWJ1dGUsXG4gICAgICAgICAgICB2YWx1ZXM6IHRoaXMudmFsdWVzLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGlzIGVxdWFsIHRvIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7UXVlcnlUeXBlc30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmVxdWFsID0gKGF0dHJpYnV0ZSwgdmFsdWUpID0+IG5ldyBRdWVyeShcImVxdWFsXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGlzIG5vdCBlcXVhbCB0byB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge1F1ZXJ5VHlwZXN9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5ub3RFcXVhbCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJub3RFcXVhbFwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBpcyBsZXNzIHRoYW4gdmFsdWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtRdWVyeVR5cGVzfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkubGVzc1RoYW4gPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT4gbmV3IFF1ZXJ5KFwibGVzc1RoYW5cIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7UXVlcnlUeXBlc30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5Lmxlc3NUaGFuRXF1YWwgPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT4gbmV3IFF1ZXJ5KFwibGVzc1RoYW5FcXVhbFwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBpcyBncmVhdGVyIHRoYW4gdmFsdWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtRdWVyeVR5cGVzfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuZ3JlYXRlclRoYW4gPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT4gbmV3IFF1ZXJ5KFwiZ3JlYXRlclRoYW5cIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7UXVlcnlUeXBlc30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmdyZWF0ZXJUaGFuRXF1YWwgPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT4gbmV3IFF1ZXJ5KFwiZ3JlYXRlclRoYW5FcXVhbFwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBpcyBudWxsLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmlzTnVsbCA9IChhdHRyaWJ1dGUpID0+IG5ldyBRdWVyeShcImlzTnVsbFwiLCBhdHRyaWJ1dGUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGlzIG5vdCBudWxsLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmlzTm90TnVsbCA9IChhdHRyaWJ1dGUpID0+IG5ldyBRdWVyeShcImlzTm90TnVsbFwiLCBhdHRyaWJ1dGUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGlzIGJldHdlZW4gc3RhcnQgYW5kIGVuZCAoaW5jbHVzaXZlKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBlbmRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmJldHdlZW4gPSAoYXR0cmlidXRlLCBzdGFydCwgZW5kKSA9PiBuZXcgUXVlcnkoXCJiZXR3ZWVuXCIsIGF0dHJpYnV0ZSwgW3N0YXJ0LCBlbmRdKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBzdGFydHMgd2l0aCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LnN0YXJ0c1dpdGggPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT4gbmV3IFF1ZXJ5KFwic3RhcnRzV2l0aFwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBlbmRzIHdpdGggdmFsdWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5lbmRzV2l0aCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJlbmRzV2l0aFwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpO1xuLyoqXG4gKiBTcGVjaWZ5IHdoaWNoIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIHJldHVybmVkIGJ5IHRoZSBBUEkgY2FsbC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5zZWxlY3QgPSAoYXR0cmlidXRlcykgPT4gbmV3IFF1ZXJ5KFwic2VsZWN0XCIsIHVuZGVmaW5lZCwgYXR0cmlidXRlcykudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyBieSBzZWFyY2hpbmcgYXR0cmlidXRlIGZvciB2YWx1ZS5cbiAqIEEgZnVsbHRleHQgaW5kZXggb24gYXR0cmlidXRlIGlzIHJlcXVpcmVkIGZvciB0aGlzIHF1ZXJ5IHRvIHdvcmsuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5zZWFyY2ggPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT4gbmV3IFF1ZXJ5KFwic2VhcmNoXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIFNvcnQgcmVzdWx0cyBieSBhdHRyaWJ1dGUgZGVzY2VuZGluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5vcmRlckRlc2MgPSAoYXR0cmlidXRlKSA9PiBuZXcgUXVlcnkoXCJvcmRlckRlc2NcIiwgYXR0cmlidXRlKS50b1N0cmluZygpO1xuLyoqXG4gKiBTb3J0IHJlc3VsdHMgYnkgYXR0cmlidXRlIGFzY2VuZGluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5vcmRlckFzYyA9IChhdHRyaWJ1dGUpID0+IG5ldyBRdWVyeShcIm9yZGVyQXNjXCIsIGF0dHJpYnV0ZSkudG9TdHJpbmcoKTtcbi8qKlxuICogU29ydCByZXN1bHRzIHJhbmRvbWx5LlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5Lm9yZGVyUmFuZG9tID0gKCkgPT4gbmV3IFF1ZXJ5KFwib3JkZXJSYW5kb21cIikudG9TdHJpbmcoKTtcbi8qKlxuICogUmV0dXJuIHJlc3VsdHMgYWZ0ZXIgZG9jdW1lbnRJZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZG9jdW1lbnRJZFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuY3Vyc29yQWZ0ZXIgPSAoZG9jdW1lbnRJZCkgPT4gbmV3IFF1ZXJ5KFwiY3Vyc29yQWZ0ZXJcIiwgdW5kZWZpbmVkLCBkb2N1bWVudElkKS50b1N0cmluZygpO1xuLyoqXG4gKiBSZXR1cm4gcmVzdWx0cyBiZWZvcmUgZG9jdW1lbnRJZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZG9jdW1lbnRJZFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuY3Vyc29yQmVmb3JlID0gKGRvY3VtZW50SWQpID0+IG5ldyBRdWVyeShcImN1cnNvckJlZm9yZVwiLCB1bmRlZmluZWQsIGRvY3VtZW50SWQpLnRvU3RyaW5nKCk7XG4vKipcbiAqIFJldHVybiBvbmx5IGxpbWl0IHJlc3VsdHMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5saW1pdCA9IChsaW1pdCkgPT4gbmV3IFF1ZXJ5KFwibGltaXRcIiwgdW5kZWZpbmVkLCBsaW1pdCkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyBieSBza2lwcGluZyB0aGUgZmlyc3Qgb2Zmc2V0IHJlc3VsdHMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkub2Zmc2V0ID0gKG9mZnNldCkgPT4gbmV3IFF1ZXJ5KFwib2Zmc2V0XCIsIHVuZGVmaW5lZCwgb2Zmc2V0KS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBjb250YWlucyB0aGUgc3BlY2lmaWVkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5jb250YWlucyA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJjb250YWluc1wiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBkb2VzIG5vdCBjb250YWluIHRoZSBzcGVjaWZpZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmcgfCBhbnlbXX0gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5Lm5vdENvbnRhaW5zID0gKGF0dHJpYnV0ZSwgdmFsdWUpID0+IG5ldyBRdWVyeShcIm5vdENvbnRhaW5zXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgYnkgc2VhcmNoaW5nIGF0dHJpYnV0ZSBmb3IgdmFsdWUgKGludmVyc2Ugb2Ygc2VhcmNoKS5cbiAqIEEgZnVsbHRleHQgaW5kZXggb24gYXR0cmlidXRlIGlzIHJlcXVpcmVkIGZvciB0aGlzIHF1ZXJ5IHRvIHdvcmsuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5ub3RTZWFyY2ggPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT4gbmV3IFF1ZXJ5KFwibm90U2VhcmNoXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGlzIG5vdCBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgKGV4Y2x1c2l2ZSkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gZW5kXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5ub3RCZXR3ZWVuID0gKGF0dHJpYnV0ZSwgc3RhcnQsIGVuZCkgPT4gbmV3IFF1ZXJ5KFwibm90QmV0d2VlblwiLCBhdHRyaWJ1dGUsIFtzdGFydCwgZW5kXSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgZG9lcyBub3Qgc3RhcnQgd2l0aCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5Lm5vdFN0YXJ0c1dpdGggPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT4gbmV3IFF1ZXJ5KFwibm90U3RhcnRzV2l0aFwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBkb2VzIG5vdCBlbmQgd2l0aCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5Lm5vdEVuZHNXaXRoID0gKGF0dHJpYnV0ZSwgdmFsdWUpID0+IG5ldyBRdWVyeShcIm5vdEVuZHNXaXRoXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgZG9jdW1lbnQgd2FzIGNyZWF0ZWQgYmVmb3JlIGRhdGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5jcmVhdGVkQmVmb3JlID0gKHZhbHVlKSA9PiBRdWVyeS5sZXNzVGhhbihcIiRjcmVhdGVkQXRcIiwgdmFsdWUpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGRvY3VtZW50IHdhcyBjcmVhdGVkIGFmdGVyIGRhdGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5jcmVhdGVkQWZ0ZXIgPSAodmFsdWUpID0+IFF1ZXJ5LmdyZWF0ZXJUaGFuKFwiJGNyZWF0ZWRBdFwiLCB2YWx1ZSk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgZG9jdW1lbnQgd2FzIGNyZWF0ZWQgYmV0d2VlbiBkYXRlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RhcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmNyZWF0ZWRCZXR3ZWVuID0gKHN0YXJ0LCBlbmQpID0+IFF1ZXJ5LmJldHdlZW4oXCIkY3JlYXRlZEF0XCIsIHN0YXJ0LCBlbmQpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGRvY3VtZW50IHdhcyB1cGRhdGVkIGJlZm9yZSBkYXRlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkudXBkYXRlZEJlZm9yZSA9ICh2YWx1ZSkgPT4gUXVlcnkubGVzc1RoYW4oXCIkdXBkYXRlZEF0XCIsIHZhbHVlKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBkb2N1bWVudCB3YXMgdXBkYXRlZCBhZnRlciBkYXRlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkudXBkYXRlZEFmdGVyID0gKHZhbHVlKSA9PiBRdWVyeS5ncmVhdGVyVGhhbihcIiR1cGRhdGVkQXRcIiwgdmFsdWUpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGRvY3VtZW50IHdhcyB1cGRhdGVkIGJldHdlZW4gZGF0ZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0YXJ0XG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS51cGRhdGVkQmV0d2VlbiA9IChzdGFydCwgZW5kKSA9PiBRdWVyeS5iZXR3ZWVuKFwiJHVwZGF0ZWRBdFwiLCBzdGFydCwgZW5kKTtcbi8qKlxuICogQ29tYmluZSBtdWx0aXBsZSBxdWVyaWVzIHVzaW5nIGxvZ2ljYWwgT1Igb3BlcmF0b3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkub3IgPSAocXVlcmllcykgPT4gbmV3IFF1ZXJ5KFwib3JcIiwgdW5kZWZpbmVkLCBxdWVyaWVzLm1hcCgocXVlcnkpID0+IEpTT04ucGFyc2UocXVlcnkpKSkudG9TdHJpbmcoKTtcbi8qKlxuICogQ29tYmluZSBtdWx0aXBsZSBxdWVyaWVzIHVzaW5nIGxvZ2ljYWwgQU5EIG9wZXJhdG9yLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmFuZCA9IChxdWVyaWVzKSA9PiBuZXcgUXVlcnkoXCJhbmRcIiwgdW5kZWZpbmVkLCBxdWVyaWVzLm1hcCgocXVlcnkpID0+IEpTT04ucGFyc2UocXVlcnkpKSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgaXMgYXQgYSBzcGVjaWZpYyBkaXN0YW5jZSBmcm9tIHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge2FueVtdfSB2YWx1ZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICogQHBhcmFtIHtib29sZWFufSBtZXRlcnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmRpc3RhbmNlRXF1YWwgPSAoYXR0cmlidXRlLCB2YWx1ZXMsIGRpc3RhbmNlLCBtZXRlcnMgPSB0cnVlKSA9PiBuZXcgUXVlcnkoXCJkaXN0YW5jZUVxdWFsXCIsIGF0dHJpYnV0ZSwgW1t2YWx1ZXMsIGRpc3RhbmNlLCBtZXRlcnNdXSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgaXMgbm90IGF0IGEgc3BlY2lmaWMgZGlzdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHthbnlbXX0gdmFsdWVzXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbWV0ZXJzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5kaXN0YW5jZU5vdEVxdWFsID0gKGF0dHJpYnV0ZSwgdmFsdWVzLCBkaXN0YW5jZSwgbWV0ZXJzID0gdHJ1ZSkgPT4gbmV3IFF1ZXJ5KFwiZGlzdGFuY2VOb3RFcXVhbFwiLCBhdHRyaWJ1dGUsIFtbdmFsdWVzLCBkaXN0YW5jZSwgbWV0ZXJzXV0pLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGlzIGF0IGEgZGlzdGFuY2UgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHthbnlbXX0gdmFsdWVzXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbWV0ZXJzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5kaXN0YW5jZUdyZWF0ZXJUaGFuID0gKGF0dHJpYnV0ZSwgdmFsdWVzLCBkaXN0YW5jZSwgbWV0ZXJzID0gdHJ1ZSkgPT4gbmV3IFF1ZXJ5KFwiZGlzdGFuY2VHcmVhdGVyVGhhblwiLCBhdHRyaWJ1dGUsIFtbdmFsdWVzLCBkaXN0YW5jZSwgbWV0ZXJzXV0pLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGlzIGF0IGEgZGlzdGFuY2UgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHthbnlbXX0gdmFsdWVzXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbWV0ZXJzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5kaXN0YW5jZUxlc3NUaGFuID0gKGF0dHJpYnV0ZSwgdmFsdWVzLCBkaXN0YW5jZSwgbWV0ZXJzID0gdHJ1ZSkgPT4gbmV3IFF1ZXJ5KFwiZGlzdGFuY2VMZXNzVGhhblwiLCBhdHRyaWJ1dGUsIFtbdmFsdWVzLCBkaXN0YW5jZSwgbWV0ZXJzXV0pLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGludGVyc2VjdHMgd2l0aCB0aGUgZ2l2ZW4gZ2VvbWV0cnkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHthbnlbXX0gdmFsdWVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5pbnRlcnNlY3RzID0gKGF0dHJpYnV0ZSwgdmFsdWVzKSA9PiBuZXcgUXVlcnkoXCJpbnRlcnNlY3RzXCIsIGF0dHJpYnV0ZSwgW3ZhbHVlc10pLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGRvZXMgbm90IGludGVyc2VjdCB3aXRoIHRoZSBnaXZlbiBnZW9tZXRyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge2FueVtdfSB2YWx1ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5Lm5vdEludGVyc2VjdHMgPSAoYXR0cmlidXRlLCB2YWx1ZXMpID0+IG5ldyBRdWVyeShcIm5vdEludGVyc2VjdHNcIiwgYXR0cmlidXRlLCBbdmFsdWVzXSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgY3Jvc3NlcyB0aGUgZ2l2ZW4gZ2VvbWV0cnkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHthbnlbXX0gdmFsdWVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5jcm9zc2VzID0gKGF0dHJpYnV0ZSwgdmFsdWVzKSA9PiBuZXcgUXVlcnkoXCJjcm9zc2VzXCIsIGF0dHJpYnV0ZSwgW3ZhbHVlc10pLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGRvZXMgbm90IGNyb3NzIHRoZSBnaXZlbiBnZW9tZXRyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge2FueVtdfSB2YWx1ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5Lm5vdENyb3NzZXMgPSAoYXR0cmlidXRlLCB2YWx1ZXMpID0+IG5ldyBRdWVyeShcIm5vdENyb3NzZXNcIiwgYXR0cmlidXRlLCBbdmFsdWVzXSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgb3ZlcmxhcHMgd2l0aCB0aGUgZ2l2ZW4gZ2VvbWV0cnkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHthbnlbXX0gdmFsdWVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5vdmVybGFwcyA9IChhdHRyaWJ1dGUsIHZhbHVlcykgPT4gbmV3IFF1ZXJ5KFwib3ZlcmxhcHNcIiwgYXR0cmlidXRlLCBbdmFsdWVzXSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgZG9lcyBub3Qgb3ZlcmxhcCB3aXRoIHRoZSBnaXZlbiBnZW9tZXRyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge2FueVtdfSB2YWx1ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5Lm5vdE92ZXJsYXBzID0gKGF0dHJpYnV0ZSwgdmFsdWVzKSA9PiBuZXcgUXVlcnkoXCJub3RPdmVybGFwc1wiLCBhdHRyaWJ1dGUsIFt2YWx1ZXNdKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSB0b3VjaGVzIHRoZSBnaXZlbiBnZW9tZXRyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge2FueVtdfSB2YWx1ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LnRvdWNoZXMgPSAoYXR0cmlidXRlLCB2YWx1ZXMpID0+IG5ldyBRdWVyeShcInRvdWNoZXNcIiwgYXR0cmlidXRlLCBbdmFsdWVzXSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgZG9lcyBub3QgdG91Y2ggdGhlIGdpdmVuIGdlb21ldHJ5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7YW55W119IHZhbHVlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkubm90VG91Y2hlcyA9IChhdHRyaWJ1dGUsIHZhbHVlcykgPT4gbmV3IFF1ZXJ5KFwibm90VG91Y2hlc1wiLCBhdHRyaWJ1dGUsIFt2YWx1ZXNdKS50b1N0cmluZygpO1xuXG4vKipcbiAqIEV4Y2VwdGlvbiB0aHJvd24gYnkgdGhlICBwYWNrYWdlXG4gKi9cbmNsYXNzIEFwcHdyaXRlRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgQXBwd3JpdGUgRXhjZXB0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29kZSAtIFRoZSBlcnJvciBjb2RlLiBEZWZhdWx0IGlzIDAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgZXJyb3IgdHlwZS4gRGVmYXVsdCBpcyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlc3BvbnNlIC0gVGhlIHJlc3BvbnNlIHN0cmluZy4gRGVmYXVsdCBpcyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSA9IDAsIHR5cGUgPSAnJywgcmVzcG9uc2UgPSAnJykge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0FwcHdyaXRlRXhjZXB0aW9uJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIH1cbn1cbi8qKlxuICogQ2xpZW50IHRoYXQgaGFuZGxlcyByZXF1ZXN0cyB0byBBcHB3cml0ZVxuICovXG5jbGFzcyBDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSG9sZHMgY29uZmlndXJhdGlvbiBzdWNoIGFzIHByb2plY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgICAgIGVuZHBvaW50OiAnaHR0cHM6Ly9jbG91ZC5hcHB3cml0ZS5pby92MScsXG4gICAgICAgICAgICBlbmRwb2ludFJlYWx0aW1lOiAnJyxcbiAgICAgICAgICAgIHByb2plY3Q6ICcnLFxuICAgICAgICAgICAgand0OiAnJyxcbiAgICAgICAgICAgIGxvY2FsZTogJycsXG4gICAgICAgICAgICBzZXNzaW9uOiAnJyxcbiAgICAgICAgICAgIGRldmtleTogJycsXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXN0b20gaGVhZGVycyBmb3IgQVBJIHJlcXVlc3RzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oZWFkZXJzID0ge1xuICAgICAgICAgICAgJ3gtc2RrLW5hbWUnOiAnV2ViJyxcbiAgICAgICAgICAgICd4LXNkay1wbGF0Zm9ybSc6ICdjbGllbnQnLFxuICAgICAgICAgICAgJ3gtc2RrLWxhbmd1YWdlJzogJ3dlYicsXG4gICAgICAgICAgICAneC1zZGstdmVyc2lvbic6ICcyMS41LjAnLFxuICAgICAgICAgICAgJ1gtQXBwd3JpdGUtUmVzcG9uc2UtRm9ybWF0JzogJzEuOC4wJyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZWFsdGltZSA9IHtcbiAgICAgICAgICAgIHNvY2tldDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdGltZW91dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaGVhcnRiZWF0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB1cmw6ICcnLFxuICAgICAgICAgICAgY2hhbm5lbHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnNDb3VudGVyOiAwLFxuICAgICAgICAgICAgcmVjb25uZWN0OiB0cnVlLFxuICAgICAgICAgICAgcmVjb25uZWN0QXR0ZW1wdHM6IDAsXG4gICAgICAgICAgICBsYXN0TWVzc2FnZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29ubmVjdDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlYWx0aW1lLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUudGltZW91dCA9IHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5jcmVhdGVTb2NrZXQoKTtcbiAgICAgICAgICAgICAgICB9LCA1MCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0VGltZW91dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMucmVhbHRpbWUucmVjb25uZWN0QXR0ZW1wdHMgPCA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5yZWFsdGltZS5yZWNvbm5lY3RBdHRlbXB0cyA8IDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDUwMDA7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5yZWFsdGltZS5yZWNvbm5lY3RBdHRlbXB0cyA8IDEwMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA2MDAwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3JlYXRlSGVhcnRiZWF0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhbHRpbWUuaGVhcnRiZWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlYWx0aW1lLmhlYXJ0YmVhdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuaGVhcnRiZWF0ID0gd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LnNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnJlYWx0aW1lLnNvY2tldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BpbmcnXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9LCAyMDAwMCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3JlYXRlU29ja2V0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhbHRpbWUuY2hhbm5lbHMuc2l6ZSA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5yZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5yZWFsdGltZS5zb2NrZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxzID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5wcm9qZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxzLnNldCgncHJvamVjdCcsIHRoaXMuY29uZmlnLnByb2plY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLmZvckVhY2goY2hhbm5lbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxzLmFwcGVuZCgnY2hhbm5lbHNbXScsIGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IHRoaXMuY29uZmlnLmVuZHBvaW50UmVhbHRpbWUgKyAnL3JlYWx0aW1lPycgKyBjaGFubmVscy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmICh1cmwgIT09IHRoaXMucmVhbHRpbWUudXJsIHx8IC8vIENoZWNrIGlmIFVSTCBpcyBwcmVzZW50XG4gICAgICAgICAgICAgICAgICAgICF0aGlzLnJlYWx0aW1lLnNvY2tldCB8fCAvLyBDaGVjayBpZiBXZWJTb2NrZXQgaGFzIG5vdCBiZWVuIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgKChfYiA9IHRoaXMucmVhbHRpbWUuc29ja2V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVhZHlTdGF0ZSkgPiBXZWJTb2NrZXQuT1BFTiAvLyBDaGVjayBpZiBXZWJTb2NrZXQgaXMgQ0xPU0lORyAoMykgb3IgQ0xPU0VEICg0KVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFsdGltZS5zb2NrZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICgoX2MgPSB0aGlzLnJlYWx0aW1lLnNvY2tldCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlYWR5U3RhdGUpIDwgV2ViU29ja2V0LkNMT1NJTkcgLy8gQ2xvc2UgV2ViU29ja2V0IGlmIGl0IGlzIENPTk5FQ1RJTkcgKDApIG9yIE9QRU4gKDEpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5yZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS51cmwgPSB1cmw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuc29ja2V0ID0gbmV3IFdlYlNvY2tldCh1cmwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5yZWFsdGltZS5vbk1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgX2V2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5jcmVhdGVIZWFydGJlYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVhbHRpbWUucmVjb25uZWN0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCgoX2IgPSAoX2EgPSB0aGlzLnJlYWx0aW1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFzdE1lc3NhZ2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50eXBlKSA9PT0gJ2Vycm9yJyAmJiAvLyBDaGVjayBpZiBsYXN0IG1lc3NhZ2Ugd2FzIG9mIHR5cGUgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYyA9IHRoaXMucmVhbHRpbWUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sYXN0TWVzc2FnZS5kYXRhKS5jb2RlID09PSAxMDA4IC8vIENoZWNrIGZvciBwb2xpY3kgdmlvbGF0aW9uIDEwMDhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5yZWNvbm5lY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLnJlYWx0aW1lLmdldFRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFJlYWx0aW1lIGdvdCBkaXNjb25uZWN0ZWQuIFJlY29ubmVjdCB3aWxsIGJlIGF0dGVtcHRlZCBpbiAke3RpbWVvdXQgLyAxMDAwfSBzZWNvbmRzLmAsIGV2ZW50LnJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLnJlY29ubmVjdEF0dGVtcHRzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5jcmVhdGVTb2NrZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25NZXNzYWdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLmxhc3RNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNlc3Npb24gPSB0aGlzLmNvbmZpZy5zZXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb29raWUgPSBKU09OLnBhcnNlKChfYSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnY29va2llRmFsbGJhY2snKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ3t9Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24gPSBjb29raWUgPT09IG51bGwgfHwgY29va2llID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb29raWVbYGFfc2Vzc2lvbl8ke3RoaXMuY29uZmlnLnByb2plY3R9YF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VEYXRhID0gbWVzc2FnZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uICYmICFtZXNzYWdlRGF0YS51c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IHRoaXMucmVhbHRpbWUuc29ja2V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYXV0aGVudGljYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V2ZW50JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IG1lc3NhZ2UuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzU3Vic2NyaWJlZCA9IGRhdGEuY2hhbm5lbHMuc29tZShjaGFubmVsID0+IHRoaXMucmVhbHRpbWUuY2hhbm5lbHMuaGFzKGNoYW5uZWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1N1YnNjcmliZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YnNjcmlwdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5jaGFubmVscy5zb21lKGNoYW5uZWwgPT4gc3Vic2NyaXB0aW9uLmNoYW5uZWxzLmluY2x1ZGVzKGNoYW5uZWwpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc3Vic2NyaXB0aW9uLmNhbGxiYWNrKGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncG9uZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIEhhbmRsZSBwb25nIHJlc3BvbnNlIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG1lc3NhZ2UuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYW5VcDogY2hhbm5lbHMgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuY2hhbm5lbHMuZm9yRWFjaChjaGFubmVsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5uZWxzLmluY2x1ZGVzKGNoYW5uZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBBcnJheS5mcm9tKHRoaXMucmVhbHRpbWUuc3Vic2NyaXB0aW9ucykuc29tZSgoW19rZXksIHN1YnNjcmlwdGlvbl0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uLmNoYW5uZWxzLmluY2x1ZGVzKGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5jaGFubmVscy5kZWxldGUoY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IEVuZHBvaW50XG4gICAgICpcbiAgICAgKiBZb3VyIHByb2plY3QgZW5kcG9pbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludFxuICAgICAqXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgc2V0RW5kcG9pbnQoZW5kcG9pbnQpIHtcbiAgICAgICAgaWYgKCFlbmRwb2ludC5zdGFydHNXaXRoKCdodHRwOi8vJykgJiYgIWVuZHBvaW50LnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignSW52YWxpZCBlbmRwb2ludCBVUkw6ICcgKyBlbmRwb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25maWcuZW5kcG9pbnQgPSBlbmRwb2ludDtcbiAgICAgICAgdGhpcy5jb25maWcuZW5kcG9pbnRSZWFsdGltZSA9IGVuZHBvaW50LnJlcGxhY2UoJ2h0dHBzOi8vJywgJ3dzczovLycpLnJlcGxhY2UoJ2h0dHA6Ly8nLCAnd3M6Ly8nKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBSZWFsdGltZSBFbmRwb2ludFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVuZHBvaW50UmVhbHRpbWVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIHNldEVuZHBvaW50UmVhbHRpbWUoZW5kcG9pbnRSZWFsdGltZSkge1xuICAgICAgICBpZiAoIWVuZHBvaW50UmVhbHRpbWUuc3RhcnRzV2l0aCgnd3M6Ly8nKSAmJiAhZW5kcG9pbnRSZWFsdGltZS5zdGFydHNXaXRoKCd3c3M6Ly8nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdJbnZhbGlkIHJlYWx0aW1lIGVuZHBvaW50IFVSTDogJyArIGVuZHBvaW50UmVhbHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uZmlnLmVuZHBvaW50UmVhbHRpbWUgPSBlbmRwb2ludFJlYWx0aW1lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IFByb2plY3RcbiAgICAgKlxuICAgICAqIFlvdXIgcHJvamVjdCBJRFxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHN0cmluZ1xuICAgICAqXG4gICAgICogQHJldHVybiB7dGhpc31cbiAgICAgKi9cbiAgICBzZXRQcm9qZWN0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyc1snWC1BcHB3cml0ZS1Qcm9qZWN0J10gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jb25maWcucHJvamVjdCA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IEpXVFxuICAgICAqXG4gICAgICogWW91ciBzZWNyZXQgSlNPTiBXZWIgVG9rZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBzdHJpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3RoaXN9XG4gICAgICovXG4gICAgc2V0SldUKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyc1snWC1BcHB3cml0ZS1KV1QnXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNvbmZpZy5qd3QgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBMb2NhbGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBzdHJpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3RoaXN9XG4gICAgICovXG4gICAgc2V0TG9jYWxlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyc1snWC1BcHB3cml0ZS1Mb2NhbGUnXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNvbmZpZy5sb2NhbGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBTZXNzaW9uXG4gICAgICpcbiAgICAgKiBUaGUgdXNlciBzZXNzaW9uIHRvIGF1dGhlbnRpY2F0ZSB3aXRoXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuICAgIHNldFNlc3Npb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzWydYLUFwcHdyaXRlLVNlc3Npb24nXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNvbmZpZy5zZXNzaW9uID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgRGV2S2V5XG4gICAgICpcbiAgICAgKiBZb3VyIHNlY3JldCBkZXYgQVBJIGtleVxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHN0cmluZ1xuICAgICAqXG4gICAgICogQHJldHVybiB7dGhpc31cbiAgICAgKi9cbiAgICBzZXREZXZLZXkodmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzWydYLUFwcHdyaXRlLURldi1LZXknXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNvbmZpZy5kZXZrZXkgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gQXBwd3JpdGUgZXZlbnRzIGFuZCBwYXNzZXMgeW91IHRoZSBwYXlsb2FkIGluIHJlYWx0aW1lLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBSZWFsdGltZSBzZXJ2aWNlIGluc3RlYWQuXG4gICAgICogQHNlZSBSZWFsdGltZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGNoYW5uZWxzXG4gICAgICogQ2hhbm5lbCB0byBzdWJzY3JpYmUgLSBwYXNzIGEgc2luZ2xlIGNoYW5uZWwgYXMgYSBzdHJpbmcgb3IgbXVsdGlwbGUgd2l0aCBhbiBhcnJheSBvZiBzdHJpbmdzLlxuICAgICAqXG4gICAgICogUG9zc2libGUgY2hhbm5lbHMgYXJlOlxuICAgICAqIC0gYWNjb3VudFxuICAgICAqIC0gY29sbGVjdGlvbnNcbiAgICAgKiAtIGNvbGxlY3Rpb25zLltJRF1cbiAgICAgKiAtIGNvbGxlY3Rpb25zLltJRF0uZG9jdW1lbnRzXG4gICAgICogLSBkb2N1bWVudHNcbiAgICAgKiAtIGRvY3VtZW50cy5bSURdXG4gICAgICogLSBmaWxlc1xuICAgICAqIC0gZmlsZXMuW0lEXVxuICAgICAqIC0gZXhlY3V0aW9uc1xuICAgICAqIC0gZXhlY3V0aW9ucy5bSURdXG4gICAgICogLSBmdW5jdGlvbnMuW0lEXVxuICAgICAqIC0gdGVhbXNcbiAgICAgKiAtIHRlYW1zLltJRF1cbiAgICAgKiAtIG1lbWJlcnNoaXBzXG4gICAgICogLSBtZW1iZXJzaGlwcy5bSURdXG4gICAgICogQHBhcmFtIHsocGF5bG9hZDogUmVhbHRpbWVNZXNzYWdlKSA9PiB2b2lkfSBjYWxsYmFjayBJcyBjYWxsZWQgb24gZXZlcnkgcmVhbHRpbWUgdXBkYXRlLlxuICAgICAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfSBVbnN1YnNjcmliZXMgZnJvbSBldmVudHMuXG4gICAgICovXG4gICAgc3Vic2NyaWJlKGNoYW5uZWxzLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgY2hhbm5lbEFycmF5ID0gdHlwZW9mIGNoYW5uZWxzID09PSAnc3RyaW5nJyA/IFtjaGFubmVsc10gOiBjaGFubmVscztcbiAgICAgICAgY2hhbm5lbEFycmF5LmZvckVhY2goY2hhbm5lbCA9PiB0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLmFkZChjaGFubmVsKSk7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSB0aGlzLnJlYWx0aW1lLnN1YnNjcmlwdGlvbnNDb3VudGVyKys7XG4gICAgICAgIHRoaXMucmVhbHRpbWUuc3Vic2NyaXB0aW9ucy5zZXQoY291bnRlciwge1xuICAgICAgICAgICAgY2hhbm5lbHM6IGNoYW5uZWxBcnJheSxcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuc3Vic2NyaXB0aW9ucy5kZWxldGUoY291bnRlcik7XG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lLmNsZWFuVXAoY2hhbm5lbEFycmF5KTtcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBwcmVwYXJlUmVxdWVzdChtZXRob2QsIHVybCwgaGVhZGVycyA9IHt9LCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBtZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycywgaGVhZGVycyk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYWxTdG9yYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBjb29raWVGYWxsYmFjayA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnY29va2llRmFsbGJhY2snKTtcbiAgICAgICAgICAgIGlmIChjb29raWVGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ1gtRmFsbGJhY2stQ29va2llcyddID0gY29va2llRmFsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaGVhZGVyc1snWC1BcHB3cml0ZS1EZXYtS2V5J10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5jcmVkZW50aWFscyA9ICdpbmNsdWRlJztcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoQ2xpZW50LmZsYXR0ZW4ocGFyYW1zKSkpIHtcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaGVhZGVyc1snY29udGVudC10eXBlJ10pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdhcHBsaWNhdGlvbi9qc29uJzpcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSwgdmFsdWUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmVzdGVkVmFsdWUgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke2tleX1bXWAsIG5lc3RlZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gZm9ybURhdGE7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXJzWydjb250ZW50LXR5cGUnXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdXJpOiB1cmwudG9TdHJpbmcoKSwgb3B0aW9ucyB9O1xuICAgIH1cbiAgICBjaHVua2VkVXBsb2FkKG1ldGhvZCwgdXJsLCBoZWFkZXJzID0ge30sIG9yaWdpbmFsUGF5bG9hZCA9IHt9LCBvblByb2dyZXNzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IFtmaWxlUGFyYW0sIGZpbGVdID0gKF9hID0gT2JqZWN0LmVudHJpZXMob3JpZ2luYWxQYXlsb2FkKS5maW5kKChbXywgdmFsdWVdKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIEZpbGUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgICAgIGlmICghZmlsZSB8fCAhZmlsZVBhcmFtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWxlIG5vdCBmb3VuZCBpbiBwYXlsb2FkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlsZS5zaXplIDw9IENsaWVudC5DSFVOS19TSVpFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY2FsbChtZXRob2QsIHVybCwgaGVhZGVycywgb3JpZ2luYWxQYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0IDwgZmlsZS5zaXplKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICsgQ2xpZW50LkNIVU5LX1NJWkU7IC8vIFByZXBhcmUgZW5kIGZvciB0aGUgbmV4dCBjaHVua1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPj0gZmlsZS5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGZpbGUuc2l6ZTsgLy8gQWRqdXN0IGZvciB0aGUgbGFzdCBjaHVuayB0byBpbmNsdWRlIHRoZSBsYXN0IGJ5dGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC1yYW5nZSddID0gYGJ5dGVzICR7c3RhcnR9LSR7ZW5kIC0gMX0vJHtmaWxlLnNpemV9YDtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IGZpbGUuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgbGV0IHBheWxvYWQgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnaW5hbFBheWxvYWQpO1xuICAgICAgICAgICAgICAgIHBheWxvYWRbZmlsZVBhcmFtXSA9IG5ldyBGaWxlKFtjaHVua10sIGZpbGUubmFtZSk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNhbGwobWV0aG9kLCB1cmwsIGhlYWRlcnMsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGlmIChvblByb2dyZXNzICYmIHR5cGVvZiBvblByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgJGlkOiByZXNwb25zZS4kaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogTWF0aC5yb3VuZCgoZW5kIC8gZmlsZS5zaXplKSAqIDEwMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplVXBsb2FkZWQ6IGVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rc1RvdGFsOiBNYXRoLmNlaWwoZmlsZS5zaXplIC8gQ2xpZW50LkNIVU5LX1NJWkUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtzVXBsb2FkZWQ6IE1hdGguY2VpbChlbmQgLyBDbGllbnQuQ0hVTktfU0laRSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS4kaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1sneC1hcHB3cml0ZS1pZCddID0gcmVzcG9uc2UuJGlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBpbmcoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxsKCdHRVQnLCBuZXcgVVJMKHRoaXMuY29uZmlnLmVuZHBvaW50ICsgJy9waW5nJykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2FsbChtZXRob2QsIHVybCwgaGVhZGVycyA9IHt9LCBwYXJhbXMgPSB7fSwgcmVzcG9uc2VUeXBlID0gJ2pzb24nKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHVyaSwgb3B0aW9ucyB9ID0gdGhpcy5wcmVwYXJlUmVxdWVzdChtZXRob2QsIHVybCwgaGVhZGVycywgcGFyYW1zKTtcbiAgICAgICAgICAgIGxldCBkYXRhID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZmV0Y2godXJpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIC8vIHR5cGUgb3BhcXVlOiBOby1DT1JTLCBkaWZmZXJlbnQtb3JpZ2luIHJlc3BvbnNlIChDT1JTLWlzc3VlKVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT09ICdvcGFxdWUnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKGBJbnZhbGlkIE9yaWdpbi4gUmVnaXN0ZXIgeW91ciBuZXcgY2xpZW50ICgke3dpbmRvdy5sb2NhdGlvbi5ob3N0fSkgYXMgYSBuZXcgV2ViIHBsYXRmb3JtIG9uIHlvdXIgcHJvamVjdCBjb25zb2xlIGRhc2hib2FyZGAsIDQwMywgXCJmb3JiaWRkZW5cIiwgXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3YXJuaW5ncyA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LWFwcHdyaXRlLXdhcm5pbmcnKTtcbiAgICAgICAgICAgIGlmICh3YXJuaW5ncykge1xuICAgICAgICAgICAgICAgIHdhcm5pbmdzLnNwbGl0KCc7JykuZm9yRWFjaCgod2FybmluZykgPT4gY29uc29sZS53YXJuKCdXYXJuaW5nOiAnICsgd2FybmluZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChfYSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSAnYXJyYXlCdWZmZXInKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHlpZWxkIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB5aWVsZCByZXNwb25zZS50ZXh0KClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKDQwMCA8PSByZXNwb25zZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2VUZXh0ID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKCgoX2IgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB8fCByZXNwb25zZVR5cGUgPT09ICdhcnJheUJ1ZmZlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVRleHQgPSBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5tZXNzYWdlLCByZXNwb25zZS5zdGF0dXMsIGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS50eXBlLCByZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29va2llRmFsbGJhY2sgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnWC1GYWxsYmFjay1Db29raWVzJyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2FsU3RvcmFnZSAmJiBjb29raWVGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4oJ0FwcHdyaXRlIGlzIHVzaW5nIGxvY2FsU3RvcmFnZSBmb3Igc2Vzc2lvbiBtYW5hZ2VtZW50LiBJbmNyZWFzZSB5b3VyIHNlY3VyaXR5IGJ5IGFkZGluZyBhIGN1c3RvbSBkb21haW4gYXMgeW91ciBBUEkgZW5kcG9pbnQuJyk7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjb29raWVGYWxsYmFjaycsIGNvb2tpZUZhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZsYXR0ZW4oZGF0YSwgcHJlZml4ID0gJycpIHtcbiAgICAgICAgbGV0IG91dHB1dCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhkYXRhKSkge1xuICAgICAgICAgICAgbGV0IGZpbmFsS2V5ID0gcHJlZml4ID8gcHJlZml4ICsgJ1snICsga2V5ICsgJ10nIDoga2V5O1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvdXRwdXQpLCBDbGllbnQuZmxhdHRlbih2YWx1ZSwgZmluYWxLZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dFtmaW5hbEtleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbn1cbkNsaWVudC5DSFVOS19TSVpFID0gMTAyNCAqIDEwMjQgKiA1O1xuXG5jbGFzcyBTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIHN0YXRpYyBmbGF0dGVuKGRhdGEsIHByZWZpeCA9ICcnKSB7XG4gICAgICAgIGxldCBvdXRwdXQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZGF0YSkpIHtcbiAgICAgICAgICAgIGxldCBmaW5hbEtleSA9IHByZWZpeCA/IHByZWZpeCArICdbJyArIGtleSArICddJyA6IGtleTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3V0cHV0KSwgU2VydmljZS5mbGF0dGVuKHZhbHVlLCBmaW5hbEtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2ZpbmFsS2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgc2l6ZSBmb3IgY2h1bmtlZCB1cGxvYWRzIGluIGJ5dGVzLlxuICovXG5TZXJ2aWNlLkNIVU5LX1NJWkUgPSA1ICogMTAyNCAqIDEwMjQ7IC8vIDVNQlxuXG5jbGFzcyBBY2NvdW50IHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLlVzZXI8UHJlZmVyZW5jZXM+Pn1cbiAgICAgKi9cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZShwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXNlcklkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIGVtYWlsOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIG5hbWU6IHJlc3RbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXNlcklkID0gcGFyYW1zLnVzZXJJZDtcbiAgICAgICAgY29uc3QgZW1haWwgPSBwYXJhbXMuZW1haWw7XG4gICAgICAgIGNvbnN0IHBhc3N3b3JkID0gcGFyYW1zLnBhc3N3b3JkO1xuICAgICAgICBjb25zdCBuYW1lID0gcGFyYW1zLm5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudCc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW1haWwnXSA9IGVtYWlsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVFbWFpbChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZW1haWw6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW1haWwgPSBwYXJhbXMuZW1haWw7XG4gICAgICAgIGNvbnN0IHBhc3N3b3JkID0gcGFyYW1zLnBhc3N3b3JkO1xuICAgICAgICBpZiAodHlwZW9mIGVtYWlsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJlbWFpbFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvZW1haWwnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkJ10gPSBwYXNzd29yZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgbGlzdElkZW50aXRpZXMocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoIXBhcmFtc09yRmlyc3QgfHwgKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHF1ZXJpZXM6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgdG90YWw6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVlcmllcyA9IHBhcmFtcy5xdWVyaWVzO1xuICAgICAgICBjb25zdCB0b3RhbCA9IHBhcmFtcy50b3RhbDtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9pZGVudGl0aWVzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG90YWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0b3RhbCddID0gdG90YWw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZGVsZXRlSWRlbnRpdHkocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGlkZW50aXR5SWQ6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWRlbnRpdHlJZCA9IHBhcmFtcy5pZGVudGl0eUlkO1xuICAgICAgICBpZiAodHlwZW9mIGlkZW50aXR5SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImlkZW50aXR5SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvaWRlbnRpdGllcy97aWRlbnRpdHlJZH0nLnJlcGxhY2UoJ3tpZGVudGl0eUlkfScsIGlkZW50aXR5SWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gY3JlYXRlIGEgSlNPTiBXZWIgVG9rZW4uIFlvdSBjYW4gdXNlIHRoZSByZXN1bHRpbmcgSldUIHRvIGF1dGhlbnRpY2F0ZSBvbiBiZWhhbGYgb2YgdGhlIGN1cnJlbnQgdXNlciB3aGVuIHdvcmtpbmcgd2l0aCB0aGUgQXBwd3JpdGUgc2VydmVyLXNpZGUgQVBJIGFuZCBTREtzLiBUaGUgSldUIHNlY3JldCBpcyB2YWxpZCBmb3IgMTUgbWludXRlcyBmcm9tIGl0cyBjcmVhdGlvbiBhbmQgd2lsbCBiZSBpbnZhbGlkIGlmIHRoZSB1c2VyIHdpbGwgbG9nb3V0IGluIHRoYXQgdGltZSBmcmFtZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5Kd3Q+fVxuICAgICAqL1xuICAgIGNyZWF0ZUpXVCgpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9qd3RzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBsaXN0TG9ncyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICghcGFyYW1zT3JGaXJzdCB8fCAocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgcXVlcmllczogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICB0b3RhbDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWVyaWVzID0gcGFyYW1zLnF1ZXJpZXM7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gcGFyYW1zLnRvdGFsO1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L2xvZ3MnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b3RhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RvdGFsJ10gPSB0b3RhbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVNRkEocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIG1mYTogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZmEgPSBwYXJhbXMubWZhO1xuICAgICAgICBpZiAodHlwZW9mIG1mYSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibWZhXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYSc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZmEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtZmEnXSA9IG1mYTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY3JlYXRlTWZhQXV0aGVudGljYXRvcihwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkgJiYgJ3R5cGUnIGluIHBhcmFtc09yRmlyc3QpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gcGFyYW1zLnR5cGU7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidHlwZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvYXV0aGVudGljYXRvcnMve3R5cGV9Jy5yZXBsYWNlKCd7dHlwZX0nLCB0eXBlKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVNRkFBdXRoZW50aWNhdG9yKHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSAmJiAndHlwZScgaW4gcGFyYW1zT3JGaXJzdCkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSBwYXJhbXMudHlwZTtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0eXBlXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9hdXRoZW50aWNhdG9ycy97dHlwZX0nLnJlcGxhY2UoJ3t0eXBlfScsIHR5cGUpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZU1mYUF1dGhlbnRpY2F0b3IocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpICYmICd0eXBlJyBpbiBwYXJhbXNPckZpcnN0KSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgb3RwOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSBwYXJhbXMudHlwZTtcbiAgICAgICAgY29uc3Qgb3RwID0gcGFyYW1zLm90cDtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0eXBlXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG90cCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwib3RwXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9hdXRoZW50aWNhdG9ycy97dHlwZX0nLnJlcGxhY2UoJ3t0eXBlfScsIHR5cGUpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygb3RwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb3RwJ10gPSBvdHA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVNRkFBdXRoZW50aWNhdG9yKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSAmJiAndHlwZScgaW4gcGFyYW1zT3JGaXJzdCkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIG90cDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gcGFyYW1zLnR5cGU7XG4gICAgICAgIGNvbnN0IG90cCA9IHBhcmFtcy5vdHA7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidHlwZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvdHAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm90cFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvYXV0aGVudGljYXRvcnMve3R5cGV9Jy5yZXBsYWNlKCd7dHlwZX0nLCB0eXBlKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG90cCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ290cCddID0gb3RwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncHV0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZGVsZXRlTWZhQXV0aGVudGljYXRvcihwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkgJiYgJ3R5cGUnIGluIHBhcmFtc09yRmlyc3QpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gcGFyYW1zLnR5cGU7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidHlwZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvYXV0aGVudGljYXRvcnMve3R5cGV9Jy5yZXBsYWNlKCd7dHlwZX0nLCB0eXBlKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGRlbGV0ZU1GQUF1dGhlbnRpY2F0b3IocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpICYmICd0eXBlJyBpbiBwYXJhbXNPckZpcnN0KSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZSA9IHBhcmFtcy50eXBlO1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInR5cGVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL2F1dGhlbnRpY2F0b3JzL3t0eXBlfScucmVwbGFjZSgne3R5cGV9JywgdHlwZSk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVNZmFDaGFsbGVuZ2UocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpICYmICdmYWN0b3InIGluIHBhcmFtc09yRmlyc3QpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IHBhcmFtcy5mYWN0b3I7XG4gICAgICAgIGlmICh0eXBlb2YgZmFjdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmYWN0b3JcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL2NoYWxsZW5nZXMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZmFjdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZmFjdG9yJ10gPSBmYWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY3JlYXRlTUZBQ2hhbGxlbmdlKHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSAmJiAnZmFjdG9yJyBpbiBwYXJhbXNPckZpcnN0KSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGZhY3RvcjogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWN0b3IgPSBwYXJhbXMuZmFjdG9yO1xuICAgICAgICBpZiAodHlwZW9mIGZhY3RvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZmFjdG9yXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9jaGFsbGVuZ2VzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZhY3RvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2ZhY3RvciddID0gZmFjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZU1mYUNoYWxsZW5nZShwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY2hhbGxlbmdlSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgb3RwOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYWxsZW5nZUlkID0gcGFyYW1zLmNoYWxsZW5nZUlkO1xuICAgICAgICBjb25zdCBvdHAgPSBwYXJhbXMub3RwO1xuICAgICAgICBpZiAodHlwZW9mIGNoYWxsZW5nZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjaGFsbGVuZ2VJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvdHAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm90cFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvY2hhbGxlbmdlcyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGFsbGVuZ2VJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NoYWxsZW5nZUlkJ10gPSBjaGFsbGVuZ2VJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG90cCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ290cCddID0gb3RwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncHV0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBkYXRlTUZBQ2hhbGxlbmdlKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjaGFsbGVuZ2VJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBvdHA6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhbGxlbmdlSWQgPSBwYXJhbXMuY2hhbGxlbmdlSWQ7XG4gICAgICAgIGNvbnN0IG90cCA9IHBhcmFtcy5vdHA7XG4gICAgICAgIGlmICh0eXBlb2YgY2hhbGxlbmdlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNoYWxsZW5nZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG90cCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwib3RwXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9jaGFsbGVuZ2VzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGNoYWxsZW5nZUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnY2hhbGxlbmdlSWQnXSA9IGNoYWxsZW5nZUlkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3RwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb3RwJ10gPSBvdHA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IHRoZSBmYWN0b3JzIGF2YWlsYWJsZSBvbiB0aGUgYWNjb3VudCB0byBiZSB1c2VkIGFzIGEgTUZBIGNoYWxsYW5nZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5NZmFGYWN0b3JzPn1cbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIEFQSSBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIDEuOC4wLiBQbGVhc2UgdXNlIGBBY2NvdW50Lmxpc3RNRkFGYWN0b3JzYCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGxpc3RNZmFGYWN0b3JzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9mYWN0b3JzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IHRoZSBmYWN0b3JzIGF2YWlsYWJsZSBvbiB0aGUgYWNjb3VudCB0byBiZSB1c2VkIGFzIGEgTUZBIGNoYWxsYW5nZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5NZmFGYWN0b3JzPn1cbiAgICAgKi9cbiAgICBsaXN0TUZBRmFjdG9ycygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvZmFjdG9ycyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHJlY292ZXJ5IGNvZGVzIHRoYXQgY2FuIGJlIHVzZWQgYXMgYmFja3VwIGZvciBNRkEgZmxvdy4gQmVmb3JlIGdldHRpbmcgY29kZXMsIHRoZXkgbXVzdCBiZSBnZW5lcmF0ZWQgdXNpbmcgW2NyZWF0ZU1mYVJlY292ZXJ5Q29kZXNdKC9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2NyZWF0ZU1mYVJlY292ZXJ5Q29kZXMpIG1ldGhvZC4gQW4gT1RQIGNoYWxsZW5nZSBpcyByZXF1aXJlZCB0byByZWFkIHJlY292ZXJ5IGNvZGVzLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLk1mYVJlY292ZXJ5Q29kZXM+fVxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgQVBJIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgMS44LjAuIFBsZWFzZSB1c2UgYEFjY291bnQuZ2V0TUZBUmVjb3ZlcnlDb2Rlc2AgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBnZXRNZmFSZWNvdmVyeUNvZGVzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9yZWNvdmVyeS1jb2Rlcyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHJlY292ZXJ5IGNvZGVzIHRoYXQgY2FuIGJlIHVzZWQgYXMgYmFja3VwIGZvciBNRkEgZmxvdy4gQmVmb3JlIGdldHRpbmcgY29kZXMsIHRoZXkgbXVzdCBiZSBnZW5lcmF0ZWQgdXNpbmcgW2NyZWF0ZU1mYVJlY292ZXJ5Q29kZXNdKC9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2NyZWF0ZU1mYVJlY292ZXJ5Q29kZXMpIG1ldGhvZC4gQW4gT1RQIGNoYWxsZW5nZSBpcyByZXF1aXJlZCB0byByZWFkIHJlY292ZXJ5IGNvZGVzLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLk1mYVJlY292ZXJ5Q29kZXM+fVxuICAgICAqL1xuICAgIGdldE1GQVJlY292ZXJ5Q29kZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL3JlY292ZXJ5LWNvZGVzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSByZWNvdmVyeSBjb2RlcyBhcyBiYWNrdXAgZm9yIE1GQSBmbG93LiBJdCdzIHJlY29tbWVuZGVkIHRvIGdlbmVyYXRlIGFuZCBzaG93IHRoZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgdXNlciBzdWNjZXNzZnVsbHkgYWRkcyB0aGVpciBhdXRoZWh0aWNhdG9yLiBSZWNvdmVyeSBjb2RlcyBjYW4gYmUgdXNlZCBhcyBhIE1GQSB2ZXJpZmljYXRpb24gdHlwZSBpbiBbY3JlYXRlTWZhQ2hhbGxlbmdlXSgvZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNjcmVhdGVNZmFDaGFsbGVuZ2UpIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5NZmFSZWNvdmVyeUNvZGVzPn1cbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIEFQSSBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIDEuOC4wLiBQbGVhc2UgdXNlIGBBY2NvdW50LmNyZWF0ZU1GQVJlY292ZXJ5Q29kZXNgIGluc3RlYWQuXG4gICAgICovXG4gICAgY3JlYXRlTWZhUmVjb3ZlcnlDb2RlcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvcmVjb3ZlcnktY29kZXMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHJlY292ZXJ5IGNvZGVzIGFzIGJhY2t1cCBmb3IgTUZBIGZsb3cuIEl0J3MgcmVjb21tZW5kZWQgdG8gZ2VuZXJhdGUgYW5kIHNob3cgdGhlbiBpbW1lZGlhdGVseSBhZnRlciB1c2VyIHN1Y2Nlc3NmdWxseSBhZGRzIHRoZWlyIGF1dGhlaHRpY2F0b3IuIFJlY292ZXJ5IGNvZGVzIGNhbiBiZSB1c2VkIGFzIGEgTUZBIHZlcmlmaWNhdGlvbiB0eXBlIGluIFtjcmVhdGVNZmFDaGFsbGVuZ2VdKC9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2NyZWF0ZU1mYUNoYWxsZW5nZSkgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLk1mYVJlY292ZXJ5Q29kZXM+fVxuICAgICAqL1xuICAgIGNyZWF0ZU1GQVJlY292ZXJ5Q29kZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL3JlY292ZXJ5LWNvZGVzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdlbmVyYXRlIHJlY292ZXJ5IGNvZGVzIHRoYXQgY2FuIGJlIHVzZWQgYXMgYmFja3VwIGZvciBNRkEgZmxvdy4gQmVmb3JlIHJlZ2VuZXJhdGluZyBjb2RlcywgdGhleSBtdXN0IGJlIGZpcnN0IGdlbmVyYXRlZCB1c2luZyBbY3JlYXRlTWZhUmVjb3ZlcnlDb2Rlc10oL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlTWZhUmVjb3ZlcnlDb2RlcykgbWV0aG9kLiBBbiBPVFAgY2hhbGxlbmdlIGlzIHJlcXVpcmVkIHRvIHJlZ2VucmVhdGUgcmVjb3ZlcnkgY29kZXMuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbHMuTWZhUmVjb3ZlcnlDb2Rlcz59XG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBBUEkgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSAxLjguMC4gUGxlYXNlIHVzZSBgQWNjb3VudC51cGRhdGVNRkFSZWNvdmVyeUNvZGVzYCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIHVwZGF0ZU1mYVJlY292ZXJ5Q29kZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL3JlY292ZXJ5LWNvZGVzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnZW5lcmF0ZSByZWNvdmVyeSBjb2RlcyB0aGF0IGNhbiBiZSB1c2VkIGFzIGJhY2t1cCBmb3IgTUZBIGZsb3cuIEJlZm9yZSByZWdlbmVyYXRpbmcgY29kZXMsIHRoZXkgbXVzdCBiZSBmaXJzdCBnZW5lcmF0ZWQgdXNpbmcgW2NyZWF0ZU1mYVJlY292ZXJ5Q29kZXNdKC9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2NyZWF0ZU1mYVJlY292ZXJ5Q29kZXMpIG1ldGhvZC4gQW4gT1RQIGNoYWxsZW5nZSBpcyByZXF1aXJlZCB0byByZWdlbnJlYXRlIHJlY292ZXJ5IGNvZGVzLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLk1mYVJlY292ZXJ5Q29kZXM+fVxuICAgICAqL1xuICAgIHVwZGF0ZU1GQVJlY292ZXJ5Q29kZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL3JlY292ZXJ5LWNvZGVzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBkYXRlTmFtZShwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gcGFyYW1zLm5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9uYW1lJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVQYXNzd29yZChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgb2xkUGFzc3dvcmQ6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFzc3dvcmQgPSBwYXJhbXMucGFzc3dvcmQ7XG4gICAgICAgIGNvbnN0IG9sZFBhc3N3b3JkID0gcGFyYW1zLm9sZFBhc3N3b3JkO1xuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9wYXNzd29yZCc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkJ10gPSBwYXNzd29yZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9sZFBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb2xkUGFzc3dvcmQnXSA9IG9sZFBhc3N3b3JkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVQaG9uZShwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgcGhvbmU6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGhvbmUgPSBwYXJhbXMucGhvbmU7XG4gICAgICAgIGNvbnN0IHBhc3N3b3JkID0gcGFyYW1zLnBhc3N3b3JkO1xuICAgICAgICBpZiAodHlwZW9mIHBob25lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwaG9uZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvcGhvbmUnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcGhvbmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwaG9uZSddID0gcGhvbmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkJ10gPSBwYXNzd29yZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwcmVmZXJlbmNlcyBhcyBhIGtleS12YWx1ZSBvYmplY3QgZm9yIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQcmVmZXJlbmNlcz59XG4gICAgICovXG4gICAgZ2V0UHJlZnMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvcHJlZnMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZVByZWZzKHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSAmJiAncHJlZnMnIGluIHBhcmFtc09yRmlyc3QpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgcHJlZnM6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlZnMgPSBwYXJhbXMucHJlZnM7XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByZWZzXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3ByZWZzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHByZWZzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJlZnMnXSA9IHByZWZzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVSZWNvdmVyeShwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZW1haWw6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgdXJsOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVtYWlsID0gcGFyYW1zLmVtYWlsO1xuICAgICAgICBjb25zdCB1cmwgPSBwYXJhbXMudXJsO1xuICAgICAgICBpZiAodHlwZW9mIGVtYWlsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJlbWFpbFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVybFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9yZWNvdmVyeSc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VybCddID0gdXJsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZVJlY292ZXJ5KHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB1c2VySWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgc2VjcmV0OiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiByZXN0WzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IHBhcmFtcy51c2VySWQ7XG4gICAgICAgIGNvbnN0IHNlY3JldCA9IHBhcmFtcy5zZWNyZXQ7XG4gICAgICAgIGNvbnN0IHBhc3N3b3JkID0gcGFyYW1zLnBhc3N3b3JkO1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2VjcmV0XCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9yZWNvdmVyeSc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlY3JldCddID0gc2VjcmV0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxpc3Qgb2YgYWN0aXZlIHNlc3Npb25zIGFjcm9zcyBkaWZmZXJlbnQgZGV2aWNlcyBmb3IgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlci5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5TZXNzaW9uTGlzdD59XG4gICAgICovXG4gICAgbGlzdFNlc3Npb25zKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYWxsIHNlc3Npb25zIGZyb20gdGhlIHVzZXIgYWNjb3VudCBhbmQgcmVtb3ZlIGFueSBzZXNzaW9ucyBjb29raWVzIGZyb20gdGhlIGVuZCBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7fT59XG4gICAgICovXG4gICAgZGVsZXRlU2Vzc2lvbnMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc2Vzc2lvbnMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gYWxsb3cgYSBuZXcgdXNlciB0byByZWdpc3RlciBhbiBhbm9ueW1vdXMgYWNjb3VudCBpbiB5b3VyIHByb2plY3QuIFRoaXMgcm91dGUgd2lsbCBhbHNvIGNyZWF0ZSBhIG5ldyBzZXNzaW9uIGZvciB0aGUgdXNlci4gVG8gYWxsb3cgdGhlIG5ldyB1c2VyIHRvIGNvbnZlcnQgYW4gYW5vbnltb3VzIGFjY291bnQgdG8gYSBub3JtYWwgYWNjb3VudCwgeW91IG5lZWQgdG8gdXBkYXRlIGl0cyBbZW1haWwgYW5kIHBhc3N3b3JkXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjdXBkYXRlRW1haWwpIG9yIGNyZWF0ZSBhbiBbT0F1dGgyIHNlc3Npb25dKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNDcmVhdGVPQXV0aDJTZXNzaW9uKS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5TZXNzaW9uPn1cbiAgICAgKi9cbiAgICBjcmVhdGVBbm9ueW1vdXNTZXNzaW9uKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zL2Fub255bW91cyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY3JlYXRlRW1haWxQYXNzd29yZFNlc3Npb24ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGVtYWlsOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVtYWlsID0gcGFyYW1zLmVtYWlsO1xuICAgICAgICBjb25zdCBwYXNzd29yZCA9IHBhcmFtcy5wYXNzd29yZDtcbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZW1haWxcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zL2VtYWlsJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW1haWwnXSA9IGVtYWlsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBkYXRlTWFnaWNVUkxTZXNzaW9uKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB1c2VySWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgc2VjcmV0OiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IHBhcmFtcy51c2VySWQ7XG4gICAgICAgIGNvbnN0IHNlY3JldCA9IHBhcmFtcy5zZWNyZXQ7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZWNyZXRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc2Vzc2lvbnMvbWFnaWMtdXJsJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVPQXV0aDJTZXNzaW9uKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSAmJiAncHJvdmlkZXInIGluIHBhcmFtc09yRmlyc3QpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBmYWlsdXJlOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIHNjb3BlczogcmVzdFsyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm92aWRlciA9IHBhcmFtcy5wcm92aWRlcjtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IHBhcmFtcy5zdWNjZXNzO1xuICAgICAgICBjb25zdCBmYWlsdXJlID0gcGFyYW1zLmZhaWx1cmU7XG4gICAgICAgIGNvbnN0IHNjb3BlcyA9IHBhcmFtcy5zY29wZXM7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByb3ZpZGVyXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zL29hdXRoMi97cHJvdmlkZXJ9Jy5yZXBsYWNlKCd7cHJvdmlkZXJ9JywgcHJvdmlkZXIpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygc3VjY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3N1Y2Nlc3MnXSA9IHN1Y2Nlc3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmYWlsdXJlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZmFpbHVyZSddID0gZmFpbHVyZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNjb3BlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Njb3BlcyddID0gc2NvcGVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIHBheWxvYWRbJ3Byb2plY3QnXSA9IHRoaXMuY2xpZW50LmNvbmZpZy5wcm9qZWN0O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhTZXJ2aWNlLmZsYXR0ZW4ocGF5bG9hZCkpKSB7XG4gICAgICAgICAgICB1cmkuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5sb2NhdGlvbikpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdXJpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlUGhvbmVTZXNzaW9uKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB1c2VySWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgc2VjcmV0OiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IHBhcmFtcy51c2VySWQ7XG4gICAgICAgIGNvbnN0IHNlY3JldCA9IHBhcmFtcy5zZWNyZXQ7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZWNyZXRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc2Vzc2lvbnMvcGhvbmUnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWNyZXQnXSA9IHNlY3JldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZVNlc3Npb24ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHVzZXJJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBzZWNyZXQ6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXNlcklkID0gcGFyYW1zLnVzZXJJZDtcbiAgICAgICAgY29uc3Qgc2VjcmV0ID0gcGFyYW1zLnNlY3JldDtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNlY3JldFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucy90b2tlbic7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlY3JldCddID0gc2VjcmV0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGdldFNlc3Npb24ocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZDogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSBwYXJhbXMuc2Vzc2lvbklkO1xuICAgICAgICBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2Vzc2lvbklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zL3tzZXNzaW9uSWR9Jy5yZXBsYWNlKCd7c2Vzc2lvbklkfScsIHNlc3Npb25JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBkYXRlU2Vzc2lvbihwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlc3Npb25JZCA9IHBhcmFtcy5zZXNzaW9uSWQ7XG4gICAgICAgIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZXNzaW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc2Vzc2lvbnMve3Nlc3Npb25JZH0nLnJlcGxhY2UoJ3tzZXNzaW9uSWR9Jywgc2Vzc2lvbklkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZGVsZXRlU2Vzc2lvbihwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlc3Npb25JZCA9IHBhcmFtcy5zZXNzaW9uSWQ7XG4gICAgICAgIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZXNzaW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc2Vzc2lvbnMve3Nlc3Npb25JZH0nLnJlcGxhY2UoJ3tzZXNzaW9uSWR9Jywgc2Vzc2lvbklkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJsb2NrIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIgYWNjb3VudC4gQmVoaW5kIHRoZSBzY2VuZSwgdGhlIHVzZXIgcmVjb3JkIGlzIG5vdCBkZWxldGVkIGJ1dCBwZXJtYW5lbnRseSBibG9ja2VkIGZyb20gYW55IGFjY2Vzcy4gVG8gY29tcGxldGVseSBkZWxldGUgYSB1c2VyLCB1c2UgdGhlIFVzZXJzIEFQSSBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLlVzZXI8UHJlZmVyZW5jZXM+Pn1cbiAgICAgKi9cbiAgICB1cGRhdGVTdGF0dXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc3RhdHVzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY3JlYXRlUHVzaFRhcmdldChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcjogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcklkOiByZXN0WzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gcGFyYW1zLnRhcmdldElkO1xuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gcGFyYW1zLmlkZW50aWZpZXI7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVySWQgPSBwYXJhbXMucHJvdmlkZXJJZDtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGFyZ2V0SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaWRlbnRpZmllciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiaWRlbnRpZmllclwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC90YXJnZXRzL3B1c2gnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0SWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0YXJnZXRJZCddID0gdGFyZ2V0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBpZGVudGlmaWVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaWRlbnRpZmllciddID0gaWRlbnRpZmllcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwcm92aWRlcklkJ10gPSBwcm92aWRlcklkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZVB1c2hUYXJnZXQocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRhcmdldElkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSBwYXJhbXMudGFyZ2V0SWQ7XG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBwYXJhbXMuaWRlbnRpZmllcjtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGFyZ2V0SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaWRlbnRpZmllciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiaWRlbnRpZmllclwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC90YXJnZXRzL3t0YXJnZXRJZH0vcHVzaCcucmVwbGFjZSgne3RhcmdldElkfScsIHRhcmdldElkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGlkZW50aWZpZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydpZGVudGlmaWVyJ10gPSBpZGVudGlmaWVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncHV0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZGVsZXRlUHVzaFRhcmdldChwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SWQ6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSBwYXJhbXMudGFyZ2V0SWQ7XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRhcmdldElkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3RhcmdldHMve3RhcmdldElkfS9wdXNoJy5yZXBsYWNlKCd7dGFyZ2V0SWR9JywgdGFyZ2V0SWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY3JlYXRlRW1haWxUb2tlbihwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXNlcklkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIGVtYWlsOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHBocmFzZTogcmVzdFsxXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VySWQgPSBwYXJhbXMudXNlcklkO1xuICAgICAgICBjb25zdCBlbWFpbCA9IHBhcmFtcy5lbWFpbDtcbiAgICAgICAgY29uc3QgcGhyYXNlID0gcGFyYW1zLnBocmFzZTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZW1haWxcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdG9rZW5zL2VtYWlsJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwaHJhc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwaHJhc2UnXSA9IHBocmFzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVNYWdpY1VSTFRva2VuKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB1c2VySWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgZW1haWw6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgdXJsOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIHBocmFzZTogcmVzdFsyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VySWQgPSBwYXJhbXMudXNlcklkO1xuICAgICAgICBjb25zdCBlbWFpbCA9IHBhcmFtcy5lbWFpbDtcbiAgICAgICAgY29uc3QgdXJsID0gcGFyYW1zLnVybDtcbiAgICAgICAgY29uc3QgcGhyYXNlID0gcGFyYW1zLnBocmFzZTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZW1haWxcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdG9rZW5zL21hZ2ljLXVybCc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW1haWwnXSA9IGVtYWlsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXJsJ10gPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwaHJhc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwaHJhc2UnXSA9IHBocmFzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVPQXV0aDJUb2tlbihwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkgJiYgJ3Byb3ZpZGVyJyBpbiBwYXJhbXNPckZpcnN0KSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgZmFpbHVyZTogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBzY29wZXM6IHJlc3RbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBwYXJhbXMucHJvdmlkZXI7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBwYXJhbXMuc3VjY2VzcztcbiAgICAgICAgY29uc3QgZmFpbHVyZSA9IHBhcmFtcy5mYWlsdXJlO1xuICAgICAgICBjb25zdCBzY29wZXMgPSBwYXJhbXMuc2NvcGVzO1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlclwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC90b2tlbnMvb2F1dGgyL3twcm92aWRlcn0nLnJlcGxhY2UoJ3twcm92aWRlcn0nLCBwcm92aWRlcik7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdWNjZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc3VjY2VzcyddID0gc3VjY2VzcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZhaWx1cmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmYWlsdXJlJ10gPSBmYWlsdXJlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2NvcGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2NvcGVzJ10gPSBzY29wZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgcGF5bG9hZFsncHJvamVjdCddID0gdGhpcy5jbGllbnQuY29uZmlnLnByb2plY3Q7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKFNlcnZpY2UuZmxhdHRlbihwYXlsb2FkKSkpIHtcbiAgICAgICAgICAgIHVyaS5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAod2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LmxvY2F0aW9uKSkge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1cmkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVQaG9uZVRva2VuKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB1c2VySWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgcGhvbmU6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXNlcklkID0gcGFyYW1zLnVzZXJJZDtcbiAgICAgICAgY29uc3QgcGhvbmUgPSBwYXJhbXMucGhvbmU7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGhvbmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBob25lXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Rva2Vucy9waG9uZSc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBob25lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGhvbmUnXSA9IHBob25lO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZUVtYWlsVmVyaWZpY2F0aW9uKHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gcGFyYW1zLnVybDtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVybFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC92ZXJpZmljYXRpb25zL2VtYWlsJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VybCddID0gdXJsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZVZlcmlmaWNhdGlvbihwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IHBhcmFtcy51cmw7XG4gICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1cmxcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdmVyaWZpY2F0aW9ucy9lbWFpbCc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1cmwnXSA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVFbWFpbFZlcmlmaWNhdGlvbihwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXNlcklkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHNlY3JldDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VySWQgPSBwYXJhbXMudXNlcklkO1xuICAgICAgICBjb25zdCBzZWNyZXQgPSBwYXJhbXMuc2VjcmV0O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2VjcmV0XCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3ZlcmlmaWNhdGlvbnMvZW1haWwnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWNyZXQnXSA9IHNlY3JldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZVZlcmlmaWNhdGlvbihwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXNlcklkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHNlY3JldDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VySWQgPSBwYXJhbXMudXNlcklkO1xuICAgICAgICBjb25zdCBzZWNyZXQgPSBwYXJhbXMuc2VjcmV0O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2VjcmV0XCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3ZlcmlmaWNhdGlvbnMvZW1haWwnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWNyZXQnXSA9IHNlY3JldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIHNlbmQgYSB2ZXJpZmljYXRpb24gU01TIHRvIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIuIFRoaXMgZW5kcG9pbnQgaXMgbWVhbnQgZm9yIHVzZSBhZnRlciB1cGRhdGluZyBhIHVzZXIncyBwaG9uZSBudW1iZXIgdXNpbmcgdGhlIFthY2NvdW50VXBkYXRlUGhvbmVdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCN1cGRhdGVQaG9uZSkgZW5kcG9pbnQuIExlYXJuIG1vcmUgYWJvdXQgaG93IHRvIFtjb21wbGV0ZSB0aGUgdmVyaWZpY2F0aW9uIHByb2Nlc3NdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCN1cGRhdGVQaG9uZVZlcmlmaWNhdGlvbikuIFRoZSB2ZXJpZmljYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyJ3MgcGhvbmUgbnVtYmVyIGlzIHZhbGlkIGZvciAxNSBtaW51dGVzLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLlRva2VuPn1cbiAgICAgKi9cbiAgICBjcmVhdGVQaG9uZVZlcmlmaWNhdGlvbigpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC92ZXJpZmljYXRpb25zL3Bob25lJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVQaG9uZVZlcmlmaWNhdGlvbihwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXNlcklkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHNlY3JldDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VySWQgPSBwYXJhbXMudXNlcklkO1xuICAgICAgICBjb25zdCBzZWNyZXQgPSBwYXJhbXMuc2VjcmV0O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2VjcmV0XCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3ZlcmlmaWNhdGlvbnMvcGhvbmUnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWNyZXQnXSA9IHNlY3JldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxufVxuXG5jbGFzcyBBdmF0YXJzIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIGdldEJyb3dzZXIocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpICYmICdjb2RlJyBpbiBwYXJhbXNPckZpcnN0KSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIHF1YWxpdHk6IHJlc3RbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZSA9IHBhcmFtcy5jb2RlO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHBhcmFtcy53aWR0aDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gcGFyYW1zLmhlaWdodDtcbiAgICAgICAgY29uc3QgcXVhbGl0eSA9IHBhcmFtcy5xdWFsaXR5O1xuICAgICAgICBpZiAodHlwZW9mIGNvZGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvZGVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2F2YXRhcnMvYnJvd3NlcnMve2NvZGV9Jy5yZXBsYWNlKCd7Y29kZX0nLCBjb2RlKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnd2lkdGgnXSA9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVpZ2h0J10gPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBxdWFsaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVhbGl0eSddID0gcXVhbGl0eTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBwYXlsb2FkWydwcm9qZWN0J10gPSB0aGlzLmNsaWVudC5jb25maWcucHJvamVjdDtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoU2VydmljZS5mbGF0dGVuKHBheWxvYWQpKSkge1xuICAgICAgICAgICAgdXJpLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaS50b1N0cmluZygpO1xuICAgIH1cbiAgICBnZXRDcmVkaXRDYXJkKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSAmJiAnY29kZScgaW4gcGFyYW1zT3JGaXJzdCkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBxdWFsaXR5OiByZXN0WzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGUgPSBwYXJhbXMuY29kZTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJhbXMud2lkdGg7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHBhcmFtcy5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IHF1YWxpdHkgPSBwYXJhbXMucXVhbGl0eTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2RlXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hdmF0YXJzL2NyZWRpdC1jYXJkcy97Y29kZX0nLnJlcGxhY2UoJ3tjb2RlfScsIGNvZGUpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd3aWR0aCddID0gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydoZWlnaHQnXSA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHF1YWxpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWFsaXR5J10gPSBxdWFsaXR5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIHBheWxvYWRbJ3Byb2plY3QnXSA9IHRoaXMuY2xpZW50LmNvbmZpZy5wcm9qZWN0O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhTZXJ2aWNlLmZsYXR0ZW4ocGF5bG9hZCkpKSB7XG4gICAgICAgICAgICB1cmkuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGdldEZhdmljb24ocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHVybDogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSBwYXJhbXMudXJsO1xuICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXJsXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hdmF0YXJzL2Zhdmljb24nO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXJsJ10gPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgcGF5bG9hZFsncHJvamVjdCddID0gdGhpcy5jbGllbnQuY29uZmlnLnByb2plY3Q7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKFNlcnZpY2UuZmxhdHRlbihwYXlsb2FkKSkpIHtcbiAgICAgICAgICAgIHVyaS5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZ2V0RmxhZyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkgJiYgJ2NvZGUnIGluIHBhcmFtc09yRmlyc3QpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY29kZTogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICB3aWR0aDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgcXVhbGl0eTogcmVzdFsyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2RlID0gcGFyYW1zLmNvZGU7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gcGFyYW1zLndpZHRoO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBwYXJhbXMuaGVpZ2h0O1xuICAgICAgICBjb25zdCBxdWFsaXR5ID0gcGFyYW1zLnF1YWxpdHk7XG4gICAgICAgIGlmICh0eXBlb2YgY29kZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29kZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYXZhdGFycy9mbGFncy97Y29kZX0nLnJlcGxhY2UoJ3tjb2RlfScsIGNvZGUpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd3aWR0aCddID0gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydoZWlnaHQnXSA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHF1YWxpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWFsaXR5J10gPSBxdWFsaXR5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIHBheWxvYWRbJ3Byb2plY3QnXSA9IHRoaXMuY2xpZW50LmNvbmZpZy5wcm9qZWN0O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhTZXJ2aWNlLmZsYXR0ZW4ocGF5bG9hZCkpKSB7XG4gICAgICAgICAgICB1cmkuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGdldEltYWdlKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByZXN0WzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IHBhcmFtcy51cmw7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gcGFyYW1zLndpZHRoO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBwYXJhbXMuaGVpZ2h0O1xuICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXJsXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hdmF0YXJzL2ltYWdlJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VybCddID0gdXJsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd3aWR0aCddID0gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydoZWlnaHQnXSA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBwYXlsb2FkWydwcm9qZWN0J10gPSB0aGlzLmNsaWVudC5jb25maWcucHJvamVjdDtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoU2VydmljZS5mbGF0dGVuKHBheWxvYWQpKSkge1xuICAgICAgICAgICAgdXJpLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaS50b1N0cmluZygpO1xuICAgIH1cbiAgICBnZXRJbml0aWFscyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICghcGFyYW1zT3JGaXJzdCB8fCAocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICB3aWR0aDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmVzdFsyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gcGFyYW1zLm5hbWU7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gcGFyYW1zLndpZHRoO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBwYXJhbXMuaGVpZ2h0O1xuICAgICAgICBjb25zdCBiYWNrZ3JvdW5kID0gcGFyYW1zLmJhY2tncm91bmQ7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2F2YXRhcnMvaW5pdGlhbHMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3dpZHRoJ10gPSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGhlaWdodCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2hlaWdodCddID0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYmFja2dyb3VuZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2JhY2tncm91bmQnXSA9IGJhY2tncm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgcGF5bG9hZFsncHJvamVjdCddID0gdGhpcy5jbGllbnQuY29uZmlnLnByb2plY3Q7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKFNlcnZpY2UuZmxhdHRlbihwYXlsb2FkKSkpIHtcbiAgICAgICAgICAgIHVyaS5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZ2V0UVIocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRleHQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgc2l6ZTogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBtYXJnaW46IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgZG93bmxvYWQ6IHJlc3RbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dCA9IHBhcmFtcy50ZXh0O1xuICAgICAgICBjb25zdCBzaXplID0gcGFyYW1zLnNpemU7XG4gICAgICAgIGNvbnN0IG1hcmdpbiA9IHBhcmFtcy5tYXJnaW47XG4gICAgICAgIGNvbnN0IGRvd25sb2FkID0gcGFyYW1zLmRvd25sb2FkO1xuICAgICAgICBpZiAodHlwZW9mIHRleHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRleHRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2F2YXRhcnMvcXInO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RleHQnXSA9IHRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2l6ZSddID0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG1hcmdpbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ21hcmdpbiddID0gbWFyZ2luO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZG93bmxvYWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkb3dubG9hZCddID0gZG93bmxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgcGF5bG9hZFsncHJvamVjdCddID0gdGhpcy5jbGllbnQuY29uZmlnLnByb2plY3Q7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKFNlcnZpY2UuZmxhdHRlbihwYXlsb2FkKSkpIHtcbiAgICAgICAgICAgIHVyaS5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZ2V0U2NyZWVuc2hvdChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgdmlld3BvcnRXaWR0aDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICB2aWV3cG9ydEhlaWdodDogcmVzdFsyXSxcbiAgICAgICAgICAgICAgICBzY2FsZTogcmVzdFszXSxcbiAgICAgICAgICAgICAgICB0aGVtZTogcmVzdFs0XSxcbiAgICAgICAgICAgICAgICB1c2VyQWdlbnQ6IHJlc3RbNV0sXG4gICAgICAgICAgICAgICAgZnVsbHBhZ2U6IHJlc3RbNl0sXG4gICAgICAgICAgICAgICAgbG9jYWxlOiByZXN0WzddLFxuICAgICAgICAgICAgICAgIHRpbWV6b25lOiByZXN0WzhdLFxuICAgICAgICAgICAgICAgIGxhdGl0dWRlOiByZXN0WzldLFxuICAgICAgICAgICAgICAgIGxvbmdpdHVkZTogcmVzdFsxMF0sXG4gICAgICAgICAgICAgICAgYWNjdXJhY3k6IHJlc3RbMTFdLFxuICAgICAgICAgICAgICAgIHRvdWNoOiByZXN0WzEyXSxcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uczogcmVzdFsxM10sXG4gICAgICAgICAgICAgICAgc2xlZXA6IHJlc3RbMTRdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiByZXN0WzE1XSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHJlc3RbMTZdLFxuICAgICAgICAgICAgICAgIHF1YWxpdHk6IHJlc3RbMTddLFxuICAgICAgICAgICAgICAgIG91dHB1dDogcmVzdFsxOF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gcGFyYW1zLnVybDtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHBhcmFtcy5oZWFkZXJzO1xuICAgICAgICBjb25zdCB2aWV3cG9ydFdpZHRoID0gcGFyYW1zLnZpZXdwb3J0V2lkdGg7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0SGVpZ2h0ID0gcGFyYW1zLnZpZXdwb3J0SGVpZ2h0O1xuICAgICAgICBjb25zdCBzY2FsZSA9IHBhcmFtcy5zY2FsZTtcbiAgICAgICAgY29uc3QgdGhlbWUgPSBwYXJhbXMudGhlbWU7XG4gICAgICAgIGNvbnN0IHVzZXJBZ2VudCA9IHBhcmFtcy51c2VyQWdlbnQ7XG4gICAgICAgIGNvbnN0IGZ1bGxwYWdlID0gcGFyYW1zLmZ1bGxwYWdlO1xuICAgICAgICBjb25zdCBsb2NhbGUgPSBwYXJhbXMubG9jYWxlO1xuICAgICAgICBjb25zdCB0aW1lem9uZSA9IHBhcmFtcy50aW1lem9uZTtcbiAgICAgICAgY29uc3QgbGF0aXR1ZGUgPSBwYXJhbXMubGF0aXR1ZGU7XG4gICAgICAgIGNvbnN0IGxvbmdpdHVkZSA9IHBhcmFtcy5sb25naXR1ZGU7XG4gICAgICAgIGNvbnN0IGFjY3VyYWN5ID0gcGFyYW1zLmFjY3VyYWN5O1xuICAgICAgICBjb25zdCB0b3VjaCA9IHBhcmFtcy50b3VjaDtcbiAgICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSBwYXJhbXMucGVybWlzc2lvbnM7XG4gICAgICAgIGNvbnN0IHNsZWVwID0gcGFyYW1zLnNsZWVwO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHBhcmFtcy53aWR0aDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gcGFyYW1zLmhlaWdodDtcbiAgICAgICAgY29uc3QgcXVhbGl0eSA9IHBhcmFtcy5xdWFsaXR5O1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBwYXJhbXMub3V0cHV0O1xuICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXJsXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hdmF0YXJzL3NjcmVlbnNob3RzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VybCddID0gdXJsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGVhZGVycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2hlYWRlcnMnXSA9IGhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2aWV3cG9ydFdpZHRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndmlld3BvcnRXaWR0aCddID0gdmlld3BvcnRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZpZXdwb3J0SGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndmlld3BvcnRIZWlnaHQnXSA9IHZpZXdwb3J0SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2NhbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzY2FsZSddID0gc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGVtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RoZW1lJ10gPSB0aGVtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHVzZXJBZ2VudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJBZ2VudCddID0gdXNlckFnZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnVsbHBhZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmdWxscGFnZSddID0gZnVsbHBhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydsb2NhbGUnXSA9IGxvY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRpbWV6b25lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGltZXpvbmUnXSA9IHRpbWV6b25lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGF0aXR1ZGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydsYXRpdHVkZSddID0gbGF0aXR1ZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsb25naXR1ZGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydsb25naXR1ZGUnXSA9IGxvbmdpdHVkZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFjY3VyYWN5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYWNjdXJhY3knXSA9IGFjY3VyYWN5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0b3VjaCddID0gdG91Y2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwZXJtaXNzaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Blcm1pc3Npb25zJ10gPSBwZXJtaXNzaW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNsZWVwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2xlZXAnXSA9IHNsZWVwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd3aWR0aCddID0gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydoZWlnaHQnXSA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHF1YWxpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWFsaXR5J10gPSBxdWFsaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3V0cHV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb3V0cHV0J10gPSBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgcGF5bG9hZFsncHJvamVjdCddID0gdGhpcy5jbGllbnQuY29uZmlnLnByb2plY3Q7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKFNlcnZpY2UuZmxhdHRlbihwYXlsb2FkKSkpIHtcbiAgICAgICAgICAgIHVyaS5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmkudG9TdHJpbmcoKTtcbiAgICB9XG59XG5cbmNsYXNzIERhdGFiYXNlcyB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBsaXN0VHJhbnNhY3Rpb25zKHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKCFwYXJhbXNPckZpcnN0IHx8IChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBxdWVyaWVzOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSBwYXJhbXMucXVlcmllcztcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3RyYW5zYWN0aW9ucyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVUcmFuc2FjdGlvbihwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICghcGFyYW1zT3JGaXJzdCB8fCAocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdHRsOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR0bCA9IHBhcmFtcy50dGw7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy90cmFuc2FjdGlvbnMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdHRsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndHRsJ10gPSB0dGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZ2V0VHJhbnNhY3Rpb24ocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQ6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IHBhcmFtcy50cmFuc2FjdGlvbklkO1xuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRyYW5zYWN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy90cmFuc2FjdGlvbnMve3RyYW5zYWN0aW9uSWR9Jy5yZXBsYWNlKCd7dHJhbnNhY3Rpb25JZH0nLCB0cmFuc2FjdGlvbklkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVUcmFuc2FjdGlvbihwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25JZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBjb21taXQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgcm9sbGJhY2s6IHJlc3RbMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IHBhcmFtcy50cmFuc2FjdGlvbklkO1xuICAgICAgICBjb25zdCBjb21taXQgPSBwYXJhbXMuY29tbWl0O1xuICAgICAgICBjb25zdCByb2xsYmFjayA9IHBhcmFtcy5yb2xsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0cmFuc2FjdGlvbklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMvdHJhbnNhY3Rpb25zL3t0cmFuc2FjdGlvbklkfScucmVwbGFjZSgne3RyYW5zYWN0aW9uSWR9JywgdHJhbnNhY3Rpb25JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb21taXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydjb21taXQnXSA9IGNvbW1pdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvbGxiYWNrICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncm9sbGJhY2snXSA9IHJvbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBkZWxldGVUcmFuc2FjdGlvbihwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25JZDogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gcGFyYW1zLnRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidHJhbnNhY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3RyYW5zYWN0aW9ucy97dHJhbnNhY3Rpb25JZH0nLnJlcGxhY2UoJ3t0cmFuc2FjdGlvbklkfScsIHRyYW5zYWN0aW9uSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY3JlYXRlT3BlcmF0aW9ucyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25JZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25zOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSWQgPSBwYXJhbXMudHJhbnNhY3Rpb25JZDtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9ucyA9IHBhcmFtcy5vcGVyYXRpb25zO1xuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRyYW5zYWN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy90cmFuc2FjdGlvbnMve3RyYW5zYWN0aW9uSWR9L29wZXJhdGlvbnMnLnJlcGxhY2UoJ3t0cmFuc2FjdGlvbklkfScsIHRyYW5zYWN0aW9uSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygb3BlcmF0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ29wZXJhdGlvbnMnXSA9IG9wZXJhdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgbGlzdERvY3VtZW50cyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgcXVlcmllczogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbklkOiByZXN0WzJdLFxuICAgICAgICAgICAgICAgIHRvdGFsOiByZXN0WzNdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSBwYXJhbXMuZGF0YWJhc2VJZDtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbklkID0gcGFyYW1zLmNvbGxlY3Rpb25JZDtcbiAgICAgICAgY29uc3QgcXVlcmllcyA9IHBhcmFtcy5xdWVyaWVzO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gcGFyYW1zLnRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gcGFyYW1zLnRvdGFsO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vZG9jdW1lbnRzJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0cmFuc2FjdGlvbklkJ10gPSB0cmFuc2FjdGlvbklkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG90YWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0b3RhbCddID0gdG90YWw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY3JlYXRlRG9jdW1lbnQocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbklkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50SWQ6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgZGF0YTogcmVzdFsyXSxcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uczogcmVzdFszXSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbklkOiByZXN0WzRdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSBwYXJhbXMuZGF0YWJhc2VJZDtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbklkID0gcGFyYW1zLmNvbGxlY3Rpb25JZDtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRJZCA9IHBhcmFtcy5kb2N1bWVudElkO1xuICAgICAgICBjb25zdCBkYXRhID0gcGFyYW1zLmRhdGE7XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb25zID0gcGFyYW1zLnBlcm1pc3Npb25zO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gcGFyYW1zLnRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkb2N1bWVudElkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vZG9jdW1lbnRzJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudElkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZG9jdW1lbnRJZCddID0gZG9jdW1lbnRJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkYXRhJ10gPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGVybWlzc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwZXJtaXNzaW9ucyddID0gcGVybWlzc2lvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndHJhbnNhY3Rpb25JZCddID0gdHJhbnNhY3Rpb25JZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBnZXREb2N1bWVudChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRJZDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBxdWVyaWVzOiByZXN0WzJdLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQ6IHJlc3RbM11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YWJhc2VJZCA9IHBhcmFtcy5kYXRhYmFzZUlkO1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSBwYXJhbXMuY29sbGVjdGlvbklkO1xuICAgICAgICBjb25zdCBkb2N1bWVudElkID0gcGFyYW1zLmRvY3VtZW50SWQ7XG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSBwYXJhbXMucXVlcmllcztcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IHBhcmFtcy50cmFuc2FjdGlvbklkO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZG9jdW1lbnRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9kb2N1bWVudHMve2RvY3VtZW50SWR9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2RvY3VtZW50SWR9JywgZG9jdW1lbnRJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0cmFuc2FjdGlvbklkJ10gPSB0cmFuc2FjdGlvbklkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwc2VydERvY3VtZW50KHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhYmFzZUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25JZDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBkb2N1bWVudElkOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIGRhdGE6IHJlc3RbMl0sXG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbnM6IHJlc3RbM10sXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25JZDogcmVzdFs0XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gcGFyYW1zLmRhdGFiYXNlSWQ7XG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25JZCA9IHBhcmFtcy5jb2xsZWN0aW9uSWQ7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50SWQgPSBwYXJhbXMuZG9jdW1lbnRJZDtcbiAgICAgICAgY29uc3QgZGF0YSA9IHBhcmFtcy5kYXRhO1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9ucyA9IHBhcmFtcy5wZXJtaXNzaW9ucztcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IHBhcmFtcy50cmFuc2FjdGlvbklkO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZG9jdW1lbnRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2RvY3VtZW50cy97ZG9jdW1lbnRJZH0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7ZG9jdW1lbnRJZH0nLCBkb2N1bWVudElkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkYXRhJ10gPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGVybWlzc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwZXJtaXNzaW9ucyddID0gcGVybWlzc2lvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndHJhbnNhY3Rpb25JZCddID0gdHJhbnNhY3Rpb25JZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZURvY3VtZW50KHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhYmFzZUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25JZDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBkb2N1bWVudElkOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIGRhdGE6IHJlc3RbMl0sXG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbnM6IHJlc3RbM10sXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25JZDogcmVzdFs0XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gcGFyYW1zLmRhdGFiYXNlSWQ7XG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25JZCA9IHBhcmFtcy5jb2xsZWN0aW9uSWQ7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50SWQgPSBwYXJhbXMuZG9jdW1lbnRJZDtcbiAgICAgICAgY29uc3QgZGF0YSA9IHBhcmFtcy5kYXRhO1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9ucyA9IHBhcmFtcy5wZXJtaXNzaW9ucztcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IHBhcmFtcy50cmFuc2FjdGlvbklkO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZG9jdW1lbnRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9kb2N1bWVudHMve2RvY3VtZW50SWR9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2RvY3VtZW50SWR9JywgZG9jdW1lbnRJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGF0YSddID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBlcm1pc3Npb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGVybWlzc2lvbnMnXSA9IHBlcm1pc3Npb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25JZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RyYW5zYWN0aW9uSWQnXSA9IHRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGRlbGV0ZURvY3VtZW50KHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhYmFzZUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25JZDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBkb2N1bWVudElkOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQ6IHJlc3RbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YWJhc2VJZCA9IHBhcmFtcy5kYXRhYmFzZUlkO1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSBwYXJhbXMuY29sbGVjdGlvbklkO1xuICAgICAgICBjb25zdCBkb2N1bWVudElkID0gcGFyYW1zLmRvY3VtZW50SWQ7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSWQgPSBwYXJhbXMudHJhbnNhY3Rpb25JZDtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRvY3VtZW50SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vZG9jdW1lbnRzL3tkb2N1bWVudElkfScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3tkb2N1bWVudElkfScsIGRvY3VtZW50SWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25JZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RyYW5zYWN0aW9uSWQnXSA9IHRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBkZWNyZW1lbnREb2N1bWVudEF0dHJpYnV0ZShwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRJZDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6IHJlc3RbMl0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlc3RbM10sXG4gICAgICAgICAgICAgICAgbWluOiByZXN0WzRdLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQ6IHJlc3RbNV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YWJhc2VJZCA9IHBhcmFtcy5kYXRhYmFzZUlkO1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSBwYXJhbXMuY29sbGVjdGlvbklkO1xuICAgICAgICBjb25zdCBkb2N1bWVudElkID0gcGFyYW1zLmRvY3VtZW50SWQ7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IHBhcmFtcy5hdHRyaWJ1dGU7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1zLnZhbHVlO1xuICAgICAgICBjb25zdCBtaW4gPSBwYXJhbXMubWluO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gcGFyYW1zLnRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkb2N1bWVudElkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYXR0cmlidXRlXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2RvY3VtZW50cy97ZG9jdW1lbnRJZH0ve2F0dHJpYnV0ZX0vZGVjcmVtZW50Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2RvY3VtZW50SWR9JywgZG9jdW1lbnRJZCkucmVwbGFjZSgne2F0dHJpYnV0ZX0nLCBhdHRyaWJ1dGUpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd2YWx1ZSddID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtaW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtaW4nXSA9IG1pbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0cmFuc2FjdGlvbklkJ10gPSB0cmFuc2FjdGlvbklkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBpbmNyZW1lbnREb2N1bWVudEF0dHJpYnV0ZShwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRJZDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6IHJlc3RbMl0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlc3RbM10sXG4gICAgICAgICAgICAgICAgbWF4OiByZXN0WzRdLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQ6IHJlc3RbNV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YWJhc2VJZCA9IHBhcmFtcy5kYXRhYmFzZUlkO1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSBwYXJhbXMuY29sbGVjdGlvbklkO1xuICAgICAgICBjb25zdCBkb2N1bWVudElkID0gcGFyYW1zLmRvY3VtZW50SWQ7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IHBhcmFtcy5hdHRyaWJ1dGU7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1zLnZhbHVlO1xuICAgICAgICBjb25zdCBtYXggPSBwYXJhbXMubWF4O1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gcGFyYW1zLnRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkb2N1bWVudElkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYXR0cmlidXRlXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2RvY3VtZW50cy97ZG9jdW1lbnRJZH0ve2F0dHJpYnV0ZX0vaW5jcmVtZW50Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2RvY3VtZW50SWR9JywgZG9jdW1lbnRJZCkucmVwbGFjZSgne2F0dHJpYnV0ZX0nLCBhdHRyaWJ1dGUpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd2YWx1ZSddID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtYXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtYXgnXSA9IG1heDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0cmFuc2FjdGlvbklkJ10gPSB0cmFuc2FjdGlvbklkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbn1cblxuY2xhc3MgRnVuY3Rpb25zIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIGxpc3RFeGVjdXRpb25zKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbklkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHF1ZXJpZXM6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgdG90YWw6IHJlc3RbMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25JZCA9IHBhcmFtcy5mdW5jdGlvbklkO1xuICAgICAgICBjb25zdCBxdWVyaWVzID0gcGFyYW1zLnF1ZXJpZXM7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gcGFyYW1zLnRvdGFsO1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy97ZnVuY3Rpb25JZH0vZXhlY3V0aW9ucycucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRvdGFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndG90YWwnXSA9IHRvdGFsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZUV4ZWN1dGlvbihwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25JZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBib2R5OiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIGFzeW5jOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIHhwYXRoOiByZXN0WzJdLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogcmVzdFszXSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXN0WzRdLFxuICAgICAgICAgICAgICAgIHNjaGVkdWxlZEF0OiByZXN0WzVdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uSWQgPSBwYXJhbXMuZnVuY3Rpb25JZDtcbiAgICAgICAgY29uc3QgYm9keSA9IHBhcmFtcy5ib2R5O1xuICAgICAgICBjb25zdCBhc3luYyA9IHBhcmFtcy5hc3luYztcbiAgICAgICAgY29uc3QgeHBhdGggPSBwYXJhbXMueHBhdGg7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHBhcmFtcy5tZXRob2Q7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBwYXJhbXMuaGVhZGVycztcbiAgICAgICAgY29uc3Qgc2NoZWR1bGVkQXQgPSBwYXJhbXMuc2NoZWR1bGVkQXQ7XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS9leGVjdXRpb25zJy5yZXBsYWNlKCd7ZnVuY3Rpb25JZH0nLCBmdW5jdGlvbklkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydib2R5J10gPSBib2R5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXN5bmMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhc3luYyddID0gYXN5bmM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB4cGF0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3BhdGgnXSA9IHhwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWV0aG9kJ10gPSBtZXRob2Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBoZWFkZXJzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVhZGVycyddID0gaGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNjaGVkdWxlZEF0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2NoZWR1bGVkQXQnXSA9IHNjaGVkdWxlZEF0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGdldEV4ZWN1dGlvbihwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25JZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBleGVjdXRpb25JZDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdW5jdGlvbklkID0gcGFyYW1zLmZ1bmN0aW9uSWQ7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvbklkID0gcGFyYW1zLmV4ZWN1dGlvbklkO1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZXhlY3V0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImV4ZWN1dGlvbklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9mdW5jdGlvbnMve2Z1bmN0aW9uSWR9L2V4ZWN1dGlvbnMve2V4ZWN1dGlvbklkfScucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCkucmVwbGFjZSgne2V4ZWN1dGlvbklkfScsIGV4ZWN1dGlvbklkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbn1cblxuY2xhc3MgR3JhcGhxbCB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBxdWVyeShwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkgJiYgJ3F1ZXJ5JyBpbiBwYXJhbXNPckZpcnN0KSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gcGFyYW1zLnF1ZXJ5O1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJxdWVyeVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZ3JhcGhxbCc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJ5J10gPSBxdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ3gtc2RrLWdyYXBocWwnOiAndHJ1ZScsXG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIG11dGF0aW9uKHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSAmJiAncXVlcnknIGluIHBhcmFtc09yRmlyc3QpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgcXVlcnk6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVlcnkgPSBwYXJhbXMucXVlcnk7XG4gICAgICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInF1ZXJ5XCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9ncmFwaHFsL211dGF0aW9uJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcnknXSA9IHF1ZXJ5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAneC1zZGstZ3JhcGhxbCc6ICd0cnVlJyxcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG59XG5cbmNsYXNzIExvY2FsZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgdXNlciBsb2NhdGlvbiBiYXNlZCBvbiBJUC4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB1c2VyIGNvdW50cnkgY29kZSwgY291bnRyeSBuYW1lLCBjb250aW5lbnQgbmFtZSwgY29udGluZW50IGNvZGUsIGlwIGFkZHJlc3MgYW5kIHN1Z2dlc3RlZCBjdXJyZW5jeS4gWW91IGNhbiB1c2UgdGhlIGxvY2FsZSBoZWFkZXIgdG8gZ2V0IHRoZSBkYXRhIGluIGEgc3VwcG9ydGVkIGxhbmd1YWdlLlxuICAgICAqXG4gICAgICogKFtJUCBHZW9sb2NhdGlvbiBieSBEQi1JUF0oaHR0cHM6Ly9kYi1pcC5jb20pKVxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLkxvY2FsZT59XG4gICAgICovXG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9sb2NhbGUnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgYWxsIGxvY2FsZSBjb2RlcyBpbiBbSVNPIDYzOS0xXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX0lTT182MzktMV9jb2RlcykuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbHMuTG9jYWxlQ29kZUxpc3Q+fVxuICAgICAqL1xuICAgIGxpc3RDb2RlcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbG9jYWxlL2NvZGVzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGFsbCBjb250aW5lbnRzLiBZb3UgY2FuIHVzZSB0aGUgbG9jYWxlIGhlYWRlciB0byBnZXQgdGhlIGRhdGEgaW4gYSBzdXBwb3J0ZWQgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbHMuQ29udGluZW50TGlzdD59XG4gICAgICovXG4gICAgbGlzdENvbnRpbmVudHMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9jb250aW5lbnRzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGFsbCBjb3VudHJpZXMuIFlvdSBjYW4gdXNlIHRoZSBsb2NhbGUgaGVhZGVyIHRvIGdldCB0aGUgZGF0YSBpbiBhIHN1cHBvcnRlZCBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5Db3VudHJ5TGlzdD59XG4gICAgICovXG4gICAgbGlzdENvdW50cmllcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbG9jYWxlL2NvdW50cmllcyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBhbGwgY291bnRyaWVzIHRoYXQgYXJlIGN1cnJlbnRseSBtZW1iZXJzIG9mIHRoZSBFVS4gWW91IGNhbiB1c2UgdGhlIGxvY2FsZSBoZWFkZXIgdG8gZ2V0IHRoZSBkYXRhIGluIGEgc3VwcG9ydGVkIGxhbmd1YWdlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLkNvdW50cnlMaXN0Pn1cbiAgICAgKi9cbiAgICBsaXN0Q291bnRyaWVzRVUoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9jb3VudHJpZXMvZXUnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgYWxsIGNvdW50cmllcyBwaG9uZSBjb2Rlcy4gWW91IGNhbiB1c2UgdGhlIGxvY2FsZSBoZWFkZXIgdG8gZ2V0IHRoZSBkYXRhIGluIGEgc3VwcG9ydGVkIGxhbmd1YWdlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLlBob25lTGlzdD59XG4gICAgICovXG4gICAgbGlzdENvdW50cmllc1Bob25lcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbG9jYWxlL2NvdW50cmllcy9waG9uZXMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgYWxsIGN1cnJlbmNpZXMsIGluY2x1ZGluZyBjdXJyZW5jeSBzeW1ib2wsIG5hbWUsIHBsdXJhbCwgYW5kIGRlY2ltYWwgZGlnaXRzIGZvciBhbGwgbWFqb3IgYW5kIG1pbm9yIGN1cnJlbmNpZXMuIFlvdSBjYW4gdXNlIHRoZSBsb2NhbGUgaGVhZGVyIHRvIGdldCB0aGUgZGF0YSBpbiBhIHN1cHBvcnRlZCBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5DdXJyZW5jeUxpc3Q+fVxuICAgICAqL1xuICAgIGxpc3RDdXJyZW5jaWVzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9sb2NhbGUvY3VycmVuY2llcyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBhbGwgbGFuZ3VhZ2VzIGNsYXNzaWZpZWQgYnkgSVNPIDYzOS0xIGluY2x1ZGluZyAyLWxldHRlciBjb2RlLCBuYW1lIGluIEVuZ2xpc2gsIGFuZCBuYW1lIGluIHRoZSByZXNwZWN0aXZlIGxhbmd1YWdlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLkxhbmd1YWdlTGlzdD59XG4gICAgICovXG4gICAgbGlzdExhbmd1YWdlcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbG9jYWxlL2xhbmd1YWdlcyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG59XG5cbmNsYXNzIE1lc3NhZ2luZyB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBjcmVhdGVTdWJzY3JpYmVyKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0b3BpY0lkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJJZDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICB0YXJnZXRJZDogcmVzdFsxXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3BpY0lkID0gcGFyYW1zLnRvcGljSWQ7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXJJZCA9IHBhcmFtcy5zdWJzY3JpYmVySWQ7XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gcGFyYW1zLnRhcmdldElkO1xuICAgICAgICBpZiAodHlwZW9mIHRvcGljSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRvcGljSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaWJlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzdWJzY3JpYmVySWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRhcmdldElkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvdG9waWNzL3t0b3BpY0lkfS9zdWJzY3JpYmVycycucmVwbGFjZSgne3RvcGljSWR9JywgdG9waWNJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpYmVySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzdWJzY3JpYmVySWQnXSA9IHN1YnNjcmliZXJJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldElkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGFyZ2V0SWQnXSA9IHRhcmdldElkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGRlbGV0ZVN1YnNjcmliZXIocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRvcGljSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcklkOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvcGljSWQgPSBwYXJhbXMudG9waWNJZDtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlcklkID0gcGFyYW1zLnN1YnNjcmliZXJJZDtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3BpY0lkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0b3BpY0lkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHN1YnNjcmliZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic3Vic2NyaWJlcklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvdG9waWNzL3t0b3BpY0lkfS9zdWJzY3JpYmVycy97c3Vic2NyaWJlcklkfScucmVwbGFjZSgne3RvcGljSWR9JywgdG9waWNJZCkucmVwbGFjZSgne3N1YnNjcmliZXJJZH0nLCBzdWJzY3JpYmVySWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG59XG5cbmNsYXNzIFN0b3JhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgbGlzdEZpbGVzKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBidWNrZXRJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBxdWVyaWVzOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHNlYXJjaDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICB0b3RhbDogcmVzdFsyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWNrZXRJZCA9IHBhcmFtcy5idWNrZXRJZDtcbiAgICAgICAgY29uc3QgcXVlcmllcyA9IHBhcmFtcy5xdWVyaWVzO1xuICAgICAgICBjb25zdCBzZWFyY2ggPSBwYXJhbXMuc2VhcmNoO1xuICAgICAgICBjb25zdCB0b3RhbCA9IHBhcmFtcy50b3RhbDtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9L2ZpbGVzJy5yZXBsYWNlKCd7YnVja2V0SWR9JywgYnVja2V0SWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWFyY2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWFyY2gnXSA9IHNlYXJjaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRvdGFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndG90YWwnXSA9IHRvdGFsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZUZpbGUocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBsZXQgb25Qcm9ncmVzcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3MgPSBwYXJhbXNPckZpcnN0ID09PSBudWxsIHx8IHBhcmFtc09yRmlyc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtc09yRmlyc3Qub25Qcm9ncmVzcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBidWNrZXRJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBmaWxlSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgZmlsZTogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uczogcmVzdFsyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3MgPSByZXN0WzNdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1Y2tldElkID0gcGFyYW1zLmJ1Y2tldElkO1xuICAgICAgICBjb25zdCBmaWxlSWQgPSBwYXJhbXMuZmlsZUlkO1xuICAgICAgICBjb25zdCBmaWxlID0gcGFyYW1zLmZpbGU7XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb25zID0gcGFyYW1zLnBlcm1pc3Npb25zO1xuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZpbGVJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmaWxlXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9zdG9yYWdlL2J1Y2tldHMve2J1Y2tldElkfS9maWxlcycucmVwbGFjZSgne2J1Y2tldElkfScsIGJ1Y2tldElkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZpbGVJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2ZpbGVJZCddID0gZmlsZUlkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2ZpbGUnXSA9IGZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwZXJtaXNzaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Blcm1pc3Npb25zJ10gPSBwZXJtaXNzaW9ucztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNodW5rZWRVcGxvYWQoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQsIG9uUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICBnZXRGaWxlKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBidWNrZXRJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBmaWxlSWQ6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVja2V0SWQgPSBwYXJhbXMuYnVja2V0SWQ7XG4gICAgICAgIGNvbnN0IGZpbGVJZCA9IHBhcmFtcy5maWxlSWQ7XG4gICAgICAgIGlmICh0eXBlb2YgYnVja2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImJ1Y2tldElkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZpbGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZmlsZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9zdG9yYWdlL2J1Y2tldHMve2J1Y2tldElkfS9maWxlcy97ZmlsZUlkfScucmVwbGFjZSgne2J1Y2tldElkfScsIGJ1Y2tldElkKS5yZXBsYWNlKCd7ZmlsZUlkfScsIGZpbGVJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBkYXRlRmlsZShwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgYnVja2V0SWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgZmlsZUlkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIG5hbWU6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbnM6IHJlc3RbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVja2V0SWQgPSBwYXJhbXMuYnVja2V0SWQ7XG4gICAgICAgIGNvbnN0IGZpbGVJZCA9IHBhcmFtcy5maWxlSWQ7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBwYXJhbXMubmFtZTtcbiAgICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSBwYXJhbXMucGVybWlzc2lvbnM7XG4gICAgICAgIGlmICh0eXBlb2YgYnVja2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImJ1Y2tldElkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZpbGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZmlsZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9zdG9yYWdlL2J1Y2tldHMve2J1Y2tldElkfS9maWxlcy97ZmlsZUlkfScucmVwbGFjZSgne2J1Y2tldElkfScsIGJ1Y2tldElkKS5yZXBsYWNlKCd7ZmlsZUlkfScsIGZpbGVJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBlcm1pc3Npb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGVybWlzc2lvbnMnXSA9IHBlcm1pc3Npb25zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncHV0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZGVsZXRlRmlsZShwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgYnVja2V0SWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgZmlsZUlkOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1Y2tldElkID0gcGFyYW1zLmJ1Y2tldElkO1xuICAgICAgICBjb25zdCBmaWxlSWQgPSBwYXJhbXMuZmlsZUlkO1xuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZpbGVJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0vZmlsZXMve2ZpbGVJZH0nLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCkucmVwbGFjZSgne2ZpbGVJZH0nLCBmaWxlSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZ2V0RmlsZURvd25sb2FkKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBidWNrZXRJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBmaWxlSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgdG9rZW46IHJlc3RbMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVja2V0SWQgPSBwYXJhbXMuYnVja2V0SWQ7XG4gICAgICAgIGNvbnN0IGZpbGVJZCA9IHBhcmFtcy5maWxlSWQ7XG4gICAgICAgIGNvbnN0IHRva2VuID0gcGFyYW1zLnRva2VuO1xuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZpbGVJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0vZmlsZXMve2ZpbGVJZH0vZG93bmxvYWQnLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCkucmVwbGFjZSgne2ZpbGVJZH0nLCBmaWxlSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0b2tlbiddID0gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgcGF5bG9hZFsncHJvamVjdCddID0gdGhpcy5jbGllbnQuY29uZmlnLnByb2plY3Q7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKFNlcnZpY2UuZmxhdHRlbihwYXlsb2FkKSkpIHtcbiAgICAgICAgICAgIHVyaS5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZ2V0RmlsZVByZXZpZXcocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGJ1Y2tldElkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIGZpbGVJZDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHJlc3RbMl0sXG4gICAgICAgICAgICAgICAgZ3Jhdml0eTogcmVzdFszXSxcbiAgICAgICAgICAgICAgICBxdWFsaXR5OiByZXN0WzRdLFxuICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiByZXN0WzVdLFxuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiByZXN0WzZdLFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogcmVzdFs3XSxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiByZXN0WzhdLFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiByZXN0WzldLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJlc3RbMTBdLFxuICAgICAgICAgICAgICAgIG91dHB1dDogcmVzdFsxMV0sXG4gICAgICAgICAgICAgICAgdG9rZW46IHJlc3RbMTJdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1Y2tldElkID0gcGFyYW1zLmJ1Y2tldElkO1xuICAgICAgICBjb25zdCBmaWxlSWQgPSBwYXJhbXMuZmlsZUlkO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHBhcmFtcy53aWR0aDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gcGFyYW1zLmhlaWdodDtcbiAgICAgICAgY29uc3QgZ3Jhdml0eSA9IHBhcmFtcy5ncmF2aXR5O1xuICAgICAgICBjb25zdCBxdWFsaXR5ID0gcGFyYW1zLnF1YWxpdHk7XG4gICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gcGFyYW1zLmJvcmRlcldpZHRoO1xuICAgICAgICBjb25zdCBib3JkZXJDb2xvciA9IHBhcmFtcy5ib3JkZXJDb2xvcjtcbiAgICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gcGFyYW1zLmJvcmRlclJhZGl1cztcbiAgICAgICAgY29uc3Qgb3BhY2l0eSA9IHBhcmFtcy5vcGFjaXR5O1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IHBhcmFtcy5yb3RhdGlvbjtcbiAgICAgICAgY29uc3QgYmFja2dyb3VuZCA9IHBhcmFtcy5iYWNrZ3JvdW5kO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBwYXJhbXMub3V0cHV0O1xuICAgICAgICBjb25zdCB0b2tlbiA9IHBhcmFtcy50b2tlbjtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmaWxlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9L2ZpbGVzL3tmaWxlSWR9L3ByZXZpZXcnLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCkucmVwbGFjZSgne2ZpbGVJZH0nLCBmaWxlSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd3aWR0aCddID0gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydoZWlnaHQnXSA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdyYXZpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydncmF2aXR5J10gPSBncmF2aXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcXVhbGl0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1YWxpdHknXSA9IHF1YWxpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBib3JkZXJXaWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2JvcmRlcldpZHRoJ10gPSBib3JkZXJXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGJvcmRlckNvbG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYm9yZGVyQ29sb3InXSA9IGJvcmRlckNvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYm9yZGVyUmFkaXVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYm9yZGVyUmFkaXVzJ10gPSBib3JkZXJSYWRpdXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcGFjaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb3BhY2l0eSddID0gb3BhY2l0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvdGF0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncm90YXRpb24nXSA9IHJvdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYmFja2dyb3VuZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2JhY2tncm91bmQnXSA9IGJhY2tncm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvdXRwdXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydvdXRwdXQnXSA9IG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndG9rZW4nXSA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIHBheWxvYWRbJ3Byb2plY3QnXSA9IHRoaXMuY2xpZW50LmNvbmZpZy5wcm9qZWN0O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhTZXJ2aWNlLmZsYXR0ZW4ocGF5bG9hZCkpKSB7XG4gICAgICAgICAgICB1cmkuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGdldEZpbGVWaWV3KHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBidWNrZXRJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBmaWxlSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgdG9rZW46IHJlc3RbMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVja2V0SWQgPSBwYXJhbXMuYnVja2V0SWQ7XG4gICAgICAgIGNvbnN0IGZpbGVJZCA9IHBhcmFtcy5maWxlSWQ7XG4gICAgICAgIGNvbnN0IHRva2VuID0gcGFyYW1zLnRva2VuO1xuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZpbGVJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0vZmlsZXMve2ZpbGVJZH0vdmlldycucmVwbGFjZSgne2J1Y2tldElkfScsIGJ1Y2tldElkKS5yZXBsYWNlKCd7ZmlsZUlkfScsIGZpbGVJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Rva2VuJ10gPSB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBwYXlsb2FkWydwcm9qZWN0J10gPSB0aGlzLmNsaWVudC5jb25maWcucHJvamVjdDtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoU2VydmljZS5mbGF0dGVuKHBheWxvYWQpKSkge1xuICAgICAgICAgICAgdXJpLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaS50b1N0cmluZygpO1xuICAgIH1cbn1cblxuY2xhc3MgVGFibGVzREIge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgbGlzdFRyYW5zYWN0aW9ucyhwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICghcGFyYW1zT3JGaXJzdCB8fCAocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgcXVlcmllczogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWVyaWVzID0gcGFyYW1zLnF1ZXJpZXM7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RhYmxlc2RiL3RyYW5zYWN0aW9ucyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVUcmFuc2FjdGlvbihwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICghcGFyYW1zT3JGaXJzdCB8fCAocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdHRsOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR0bCA9IHBhcmFtcy50dGw7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RhYmxlc2RiL3RyYW5zYWN0aW9ucyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0dGwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0dGwnXSA9IHR0bDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBnZXRUcmFuc2FjdGlvbihwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25JZDogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gcGFyYW1zLnRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidHJhbnNhY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGFibGVzZGIvdHJhbnNhY3Rpb25zL3t0cmFuc2FjdGlvbklkfScucmVwbGFjZSgne3RyYW5zYWN0aW9uSWR9JywgdHJhbnNhY3Rpb25JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBkYXRlVHJhbnNhY3Rpb24ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgY29tbWl0OiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHJvbGxiYWNrOiByZXN0WzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSWQgPSBwYXJhbXMudHJhbnNhY3Rpb25JZDtcbiAgICAgICAgY29uc3QgY29tbWl0ID0gcGFyYW1zLmNvbW1pdDtcbiAgICAgICAgY29uc3Qgcm9sbGJhY2sgPSBwYXJhbXMucm9sbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidHJhbnNhY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGFibGVzZGIvdHJhbnNhY3Rpb25zL3t0cmFuc2FjdGlvbklkfScucmVwbGFjZSgne3RyYW5zYWN0aW9uSWR9JywgdHJhbnNhY3Rpb25JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb21taXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydjb21taXQnXSA9IGNvbW1pdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvbGxiYWNrICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncm9sbGJhY2snXSA9IHJvbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBkZWxldGVUcmFuc2FjdGlvbihwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25JZDogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gcGFyYW1zLnRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidHJhbnNhY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGFibGVzZGIvdHJhbnNhY3Rpb25zL3t0cmFuc2FjdGlvbklkfScucmVwbGFjZSgne3RyYW5zYWN0aW9uSWR9JywgdHJhbnNhY3Rpb25JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVPcGVyYXRpb25zKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbklkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbnM6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IHBhcmFtcy50cmFuc2FjdGlvbklkO1xuICAgICAgICBjb25zdCBvcGVyYXRpb25zID0gcGFyYW1zLm9wZXJhdGlvbnM7XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidHJhbnNhY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGFibGVzZGIvdHJhbnNhY3Rpb25zL3t0cmFuc2FjdGlvbklkfS9vcGVyYXRpb25zJy5yZXBsYWNlKCd7dHJhbnNhY3Rpb25JZH0nLCB0cmFuc2FjdGlvbklkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG9wZXJhdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydvcGVyYXRpb25zJ10gPSBvcGVyYXRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGxpc3RSb3dzKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhYmFzZUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHRhYmxlSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgcXVlcmllczogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbklkOiByZXN0WzJdLFxuICAgICAgICAgICAgICAgIHRvdGFsOiByZXN0WzNdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSBwYXJhbXMuZGF0YWJhc2VJZDtcbiAgICAgICAgY29uc3QgdGFibGVJZCA9IHBhcmFtcy50YWJsZUlkO1xuICAgICAgICBjb25zdCBxdWVyaWVzID0gcGFyYW1zLnF1ZXJpZXM7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSWQgPSBwYXJhbXMudHJhbnNhY3Rpb25JZDtcbiAgICAgICAgY29uc3QgdG90YWwgPSBwYXJhbXMudG90YWw7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0YWJsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0YWJsZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90YWJsZXNkYi97ZGF0YWJhc2VJZH0vdGFibGVzL3t0YWJsZUlkfS9yb3dzJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7dGFibGVJZH0nLCB0YWJsZUlkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25JZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RyYW5zYWN0aW9uSWQnXSA9IHRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b3RhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RvdGFsJ10gPSB0b3RhbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVSb3cocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgdGFibGVJZDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICByb3dJZDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBkYXRhOiByZXN0WzJdLFxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zOiByZXN0WzNdLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQ6IHJlc3RbNF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YWJhc2VJZCA9IHBhcmFtcy5kYXRhYmFzZUlkO1xuICAgICAgICBjb25zdCB0YWJsZUlkID0gcGFyYW1zLnRhYmxlSWQ7XG4gICAgICAgIGNvbnN0IHJvd0lkID0gcGFyYW1zLnJvd0lkO1xuICAgICAgICBjb25zdCBkYXRhID0gcGFyYW1zLmRhdGE7XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb25zID0gcGFyYW1zLnBlcm1pc3Npb25zO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gcGFyYW1zLnRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0YWJsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0YWJsZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvd0lkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyb3dJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90YWJsZXNkYi97ZGF0YWJhc2VJZH0vdGFibGVzL3t0YWJsZUlkfS9yb3dzJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7dGFibGVJZH0nLCB0YWJsZUlkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHJvd0lkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncm93SWQnXSA9IHJvd0lkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RhdGEnXSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwZXJtaXNzaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Blcm1pc3Npb25zJ10gPSBwZXJtaXNzaW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0cmFuc2FjdGlvbklkJ10gPSB0cmFuc2FjdGlvbklkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGdldFJvdyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICB0YWJsZUlkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHJvd0lkOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIHF1ZXJpZXM6IHJlc3RbMl0sXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25JZDogcmVzdFszXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gcGFyYW1zLmRhdGFiYXNlSWQ7XG4gICAgICAgIGNvbnN0IHRhYmxlSWQgPSBwYXJhbXMudGFibGVJZDtcbiAgICAgICAgY29uc3Qgcm93SWQgPSBwYXJhbXMucm93SWQ7XG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSBwYXJhbXMucXVlcmllcztcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IHBhcmFtcy50cmFuc2FjdGlvbklkO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGFibGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGFibGVJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByb3dJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicm93SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RhYmxlc2RiL3tkYXRhYmFzZUlkfS90YWJsZXMve3RhYmxlSWR9L3Jvd3Mve3Jvd0lkfScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne3RhYmxlSWR9JywgdGFibGVJZCkucmVwbGFjZSgne3Jvd0lkfScsIHJvd0lkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25JZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RyYW5zYWN0aW9uSWQnXSA9IHRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBzZXJ0Um93KHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhYmFzZUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHRhYmxlSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgcm93SWQ6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgZGF0YTogcmVzdFsyXSxcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uczogcmVzdFszXSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbklkOiByZXN0WzRdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSBwYXJhbXMuZGF0YWJhc2VJZDtcbiAgICAgICAgY29uc3QgdGFibGVJZCA9IHBhcmFtcy50YWJsZUlkO1xuICAgICAgICBjb25zdCByb3dJZCA9IHBhcmFtcy5yb3dJZDtcbiAgICAgICAgY29uc3QgZGF0YSA9IHBhcmFtcy5kYXRhO1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9ucyA9IHBhcmFtcy5wZXJtaXNzaW9ucztcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IHBhcmFtcy50cmFuc2FjdGlvbklkO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGFibGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGFibGVJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByb3dJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicm93SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RhYmxlc2RiL3tkYXRhYmFzZUlkfS90YWJsZXMve3RhYmxlSWR9L3Jvd3Mve3Jvd0lkfScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne3RhYmxlSWR9JywgdGFibGVJZCkucmVwbGFjZSgne3Jvd0lkfScsIHJvd0lkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkYXRhJ10gPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGVybWlzc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwZXJtaXNzaW9ucyddID0gcGVybWlzc2lvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndHJhbnNhY3Rpb25JZCddID0gdHJhbnNhY3Rpb25JZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZVJvdyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICB0YWJsZUlkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHJvd0lkOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIGRhdGE6IHJlc3RbMl0sXG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbnM6IHJlc3RbM10sXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25JZDogcmVzdFs0XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gcGFyYW1zLmRhdGFiYXNlSWQ7XG4gICAgICAgIGNvbnN0IHRhYmxlSWQgPSBwYXJhbXMudGFibGVJZDtcbiAgICAgICAgY29uc3Qgcm93SWQgPSBwYXJhbXMucm93SWQ7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwYXJhbXMuZGF0YTtcbiAgICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSBwYXJhbXMucGVybWlzc2lvbnM7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSWQgPSBwYXJhbXMudHJhbnNhY3Rpb25JZDtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRhYmxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRhYmxlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygcm93SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJvd0lkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90YWJsZXNkYi97ZGF0YWJhc2VJZH0vdGFibGVzL3t0YWJsZUlkfS9yb3dzL3tyb3dJZH0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3t0YWJsZUlkfScsIHRhYmxlSWQpLnJlcGxhY2UoJ3tyb3dJZH0nLCByb3dJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGF0YSddID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBlcm1pc3Npb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGVybWlzc2lvbnMnXSA9IHBlcm1pc3Npb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25JZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RyYW5zYWN0aW9uSWQnXSA9IHRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGRlbGV0ZVJvdyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICB0YWJsZUlkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHJvd0lkOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQ6IHJlc3RbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YWJhc2VJZCA9IHBhcmFtcy5kYXRhYmFzZUlkO1xuICAgICAgICBjb25zdCB0YWJsZUlkID0gcGFyYW1zLnRhYmxlSWQ7XG4gICAgICAgIGNvbnN0IHJvd0lkID0gcGFyYW1zLnJvd0lkO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gcGFyYW1zLnRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0YWJsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0YWJsZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvd0lkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyb3dJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGFibGVzZGIve2RhdGFiYXNlSWR9L3RhYmxlcy97dGFibGVJZH0vcm93cy97cm93SWR9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7dGFibGVJZH0nLCB0YWJsZUlkKS5yZXBsYWNlKCd7cm93SWR9Jywgcm93SWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25JZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RyYW5zYWN0aW9uSWQnXSA9IHRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBkZWNyZW1lbnRSb3dDb2x1bW4ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgdGFibGVJZDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICByb3dJZDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IHJlc3RbMl0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlc3RbM10sXG4gICAgICAgICAgICAgICAgbWluOiByZXN0WzRdLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQ6IHJlc3RbNV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YWJhc2VJZCA9IHBhcmFtcy5kYXRhYmFzZUlkO1xuICAgICAgICBjb25zdCB0YWJsZUlkID0gcGFyYW1zLnRhYmxlSWQ7XG4gICAgICAgIGNvbnN0IHJvd0lkID0gcGFyYW1zLnJvd0lkO1xuICAgICAgICBjb25zdCBjb2x1bW4gPSBwYXJhbXMuY29sdW1uO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtcy52YWx1ZTtcbiAgICAgICAgY29uc3QgbWluID0gcGFyYW1zLm1pbjtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IHBhcmFtcy50cmFuc2FjdGlvbklkO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGFibGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGFibGVJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByb3dJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicm93SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29sdW1uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2x1bW5cIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RhYmxlc2RiL3tkYXRhYmFzZUlkfS90YWJsZXMve3RhYmxlSWR9L3Jvd3Mve3Jvd0lkfS97Y29sdW1ufS9kZWNyZW1lbnQnLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3t0YWJsZUlkfScsIHRhYmxlSWQpLnJlcGxhY2UoJ3tyb3dJZH0nLCByb3dJZCkucmVwbGFjZSgne2NvbHVtbn0nLCBjb2x1bW4pO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd2YWx1ZSddID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtaW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtaW4nXSA9IG1pbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0cmFuc2FjdGlvbklkJ10gPSB0cmFuc2FjdGlvbklkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBpbmNyZW1lbnRSb3dDb2x1bW4ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgdGFibGVJZDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICByb3dJZDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IHJlc3RbMl0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlc3RbM10sXG4gICAgICAgICAgICAgICAgbWF4OiByZXN0WzRdLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQ6IHJlc3RbNV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YWJhc2VJZCA9IHBhcmFtcy5kYXRhYmFzZUlkO1xuICAgICAgICBjb25zdCB0YWJsZUlkID0gcGFyYW1zLnRhYmxlSWQ7XG4gICAgICAgIGNvbnN0IHJvd0lkID0gcGFyYW1zLnJvd0lkO1xuICAgICAgICBjb25zdCBjb2x1bW4gPSBwYXJhbXMuY29sdW1uO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtcy52YWx1ZTtcbiAgICAgICAgY29uc3QgbWF4ID0gcGFyYW1zLm1heDtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IHBhcmFtcy50cmFuc2FjdGlvbklkO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGFibGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGFibGVJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByb3dJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicm93SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29sdW1uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2x1bW5cIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RhYmxlc2RiL3tkYXRhYmFzZUlkfS90YWJsZXMve3RhYmxlSWR9L3Jvd3Mve3Jvd0lkfS97Y29sdW1ufS9pbmNyZW1lbnQnLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3t0YWJsZUlkfScsIHRhYmxlSWQpLnJlcGxhY2UoJ3tyb3dJZH0nLCByb3dJZCkucmVwbGFjZSgne2NvbHVtbn0nLCBjb2x1bW4pO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd2YWx1ZSddID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtYXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtYXgnXSA9IG1heDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0cmFuc2FjdGlvbklkJ10gPSB0cmFuc2FjdGlvbklkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbn1cblxuY2xhc3MgVGVhbXMge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgbGlzdChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICghcGFyYW1zT3JGaXJzdCB8fCAocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgcXVlcmllczogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgdG90YWw6IHJlc3RbMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVlcmllcyA9IHBhcmFtcy5xdWVyaWVzO1xuICAgICAgICBjb25zdCBzZWFyY2ggPSBwYXJhbXMuc2VhcmNoO1xuICAgICAgICBjb25zdCB0b3RhbCA9IHBhcmFtcy50b3RhbDtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWFyY2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWFyY2gnXSA9IHNlYXJjaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRvdGFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndG90YWwnXSA9IHRvdGFsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZShwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdGVhbUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIG5hbWU6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgcm9sZXM6IHJlc3RbMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVhbUlkID0gcGFyYW1zLnRlYW1JZDtcbiAgICAgICAgY29uc3QgbmFtZSA9IHBhcmFtcy5uYW1lO1xuICAgICAgICBjb25zdCByb2xlcyA9IHBhcmFtcy5yb2xlcztcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0ZWFtSWQnXSA9IHRlYW1JZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygcm9sZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyb2xlcyddID0gcm9sZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZ2V0KHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0ZWFtSWQ6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVhbUlkID0gcGFyYW1zLnRlYW1JZDtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0nLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVOYW1lKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0ZWFtSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgbmFtZTogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZWFtSWQgPSBwYXJhbXMudGVhbUlkO1xuICAgICAgICBjb25zdCBuYW1lID0gcGFyYW1zLm5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0nLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncHV0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZGVsZXRlKHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0ZWFtSWQ6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVhbUlkID0gcGFyYW1zLnRlYW1JZDtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0nLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGxpc3RNZW1iZXJzaGlwcyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdGVhbUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHF1ZXJpZXM6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgc2VhcmNoOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIHRvdGFsOiByZXN0WzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlYW1JZCA9IHBhcmFtcy50ZWFtSWQ7XG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSBwYXJhbXMucXVlcmllcztcbiAgICAgICAgY29uc3Qgc2VhcmNoID0gcGFyYW1zLnNlYXJjaDtcbiAgICAgICAgY29uc3QgdG90YWwgPSBwYXJhbXMudG90YWw7XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9L21lbWJlcnNoaXBzJy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlYXJjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlYXJjaCddID0gc2VhcmNoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG90YWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0b3RhbCddID0gdG90YWw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY3JlYXRlTWVtYmVyc2hpcChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdGVhbUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHJvbGVzOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIGVtYWlsOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIHVzZXJJZDogcmVzdFsyXSxcbiAgICAgICAgICAgICAgICBwaG9uZTogcmVzdFszXSxcbiAgICAgICAgICAgICAgICB1cmw6IHJlc3RbNF0sXG4gICAgICAgICAgICAgICAgbmFtZTogcmVzdFs1XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZWFtSWQgPSBwYXJhbXMudGVhbUlkO1xuICAgICAgICBjb25zdCByb2xlcyA9IHBhcmFtcy5yb2xlcztcbiAgICAgICAgY29uc3QgZW1haWwgPSBwYXJhbXMuZW1haWw7XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IHBhcmFtcy51c2VySWQ7XG4gICAgICAgIGNvbnN0IHBob25lID0gcGFyYW1zLnBob25lO1xuICAgICAgICBjb25zdCB1cmwgPSBwYXJhbXMudXJsO1xuICAgICAgICBjb25zdCBuYW1lID0gcGFyYW1zLm5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygcm9sZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJvbGVzXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfS9tZW1iZXJzaGlwcycucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBob25lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGhvbmUnXSA9IHBob25lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygcm9sZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyb2xlcyddID0gcm9sZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1cmwnXSA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGdldE1lbWJlcnNoaXAocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRlYW1JZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBtZW1iZXJzaGlwSWQ6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVhbUlkID0gcGFyYW1zLnRlYW1JZDtcbiAgICAgICAgY29uc3QgbWVtYmVyc2hpcElkID0gcGFyYW1zLm1lbWJlcnNoaXBJZDtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtZW1iZXJzaGlwSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1lbWJlcnNoaXBJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0vbWVtYmVyc2hpcHMve21lbWJlcnNoaXBJZH0nLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKS5yZXBsYWNlKCd7bWVtYmVyc2hpcElkfScsIG1lbWJlcnNoaXBJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBkYXRlTWVtYmVyc2hpcChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdGVhbUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIG1lbWJlcnNoaXBJZDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICByb2xlczogcmVzdFsxXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZWFtSWQgPSBwYXJhbXMudGVhbUlkO1xuICAgICAgICBjb25zdCBtZW1iZXJzaGlwSWQgPSBwYXJhbXMubWVtYmVyc2hpcElkO1xuICAgICAgICBjb25zdCByb2xlcyA9IHBhcmFtcy5yb2xlcztcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtZW1iZXJzaGlwSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1lbWJlcnNoaXBJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByb2xlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicm9sZXNcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9L21lbWJlcnNoaXBzL3ttZW1iZXJzaGlwSWR9Jy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCkucmVwbGFjZSgne21lbWJlcnNoaXBJZH0nLCBtZW1iZXJzaGlwSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygcm9sZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyb2xlcyddID0gcm9sZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGRlbGV0ZU1lbWJlcnNoaXAocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRlYW1JZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBtZW1iZXJzaGlwSWQ6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVhbUlkID0gcGFyYW1zLnRlYW1JZDtcbiAgICAgICAgY29uc3QgbWVtYmVyc2hpcElkID0gcGFyYW1zLm1lbWJlcnNoaXBJZDtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtZW1iZXJzaGlwSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1lbWJlcnNoaXBJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0vbWVtYmVyc2hpcHMve21lbWJlcnNoaXBJZH0nLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKS5yZXBsYWNlKCd7bWVtYmVyc2hpcElkfScsIG1lbWJlcnNoaXBJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVNZW1iZXJzaGlwU3RhdHVzKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0ZWFtSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgbWVtYmVyc2hpcElkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHVzZXJJZDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBzZWNyZXQ6IHJlc3RbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVhbUlkID0gcGFyYW1zLnRlYW1JZDtcbiAgICAgICAgY29uc3QgbWVtYmVyc2hpcElkID0gcGFyYW1zLm1lbWJlcnNoaXBJZDtcbiAgICAgICAgY29uc3QgdXNlcklkID0gcGFyYW1zLnVzZXJJZDtcbiAgICAgICAgY29uc3Qgc2VjcmV0ID0gcGFyYW1zLnNlY3JldDtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtZW1iZXJzaGlwSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1lbWJlcnNoaXBJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNlY3JldFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0vbWVtYmVyc2hpcHMve21lbWJlcnNoaXBJZH0vc3RhdHVzJy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCkucmVwbGFjZSgne21lbWJlcnNoaXBJZH0nLCBtZW1iZXJzaGlwSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWNyZXQnXSA9IHNlY3JldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZ2V0UHJlZnMocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRlYW1JZDogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZWFtSWQgPSBwYXJhbXMudGVhbUlkO1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfS9wcmVmcycucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZVByZWZzKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0ZWFtSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgcHJlZnM6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVhbUlkID0gcGFyYW1zLnRlYW1JZDtcbiAgICAgICAgY29uc3QgcHJlZnMgPSBwYXJhbXMucHJlZnM7XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByZWZzXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfS9wcmVmcycucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwcmVmcyddID0gcHJlZnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbn1cblxudmFyIFJlYWx0aW1lQ29kZTtcbihmdW5jdGlvbiAoUmVhbHRpbWVDb2RlKSB7XG4gICAgUmVhbHRpbWVDb2RlW1JlYWx0aW1lQ29kZVtcIk5PUk1BTF9DTE9TVVJFXCJdID0gMTAwMF0gPSBcIk5PUk1BTF9DTE9TVVJFXCI7XG4gICAgUmVhbHRpbWVDb2RlW1JlYWx0aW1lQ29kZVtcIlBPTElDWV9WSU9MQVRJT05cIl0gPSAxMDA4XSA9IFwiUE9MSUNZX1ZJT0xBVElPTlwiO1xuICAgIFJlYWx0aW1lQ29kZVtSZWFsdGltZUNvZGVbXCJVTktOT1dOX0VSUk9SXCJdID0gLTFdID0gXCJVTktOT1dOX0VSUk9SXCI7XG59KShSZWFsdGltZUNvZGUgfHwgKFJlYWx0aW1lQ29kZSA9IHt9KSk7XG5jbGFzcyBSZWFsdGltZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuVFlQRV9FUlJPUiA9ICdlcnJvcic7XG4gICAgICAgIHRoaXMuVFlQRV9FVkVOVCA9ICdldmVudCc7XG4gICAgICAgIHRoaXMuVFlQRV9QT05HID0gJ3BvbmcnO1xuICAgICAgICB0aGlzLlRZUEVfQ09OTkVDVEVEID0gJ2Nvbm5lY3RlZCc7XG4gICAgICAgIHRoaXMuREVCT1VOQ0VfTVMgPSAxO1xuICAgICAgICB0aGlzLkhFQVJUQkVBVF9JTlRFUlZBTCA9IDIwMDAwOyAvLyAyMCBzZWNvbmRzIGluIG1pbGxpc2Vjb25kc1xuICAgICAgICB0aGlzLmFjdGl2ZUNoYW5uZWxzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmFjdGl2ZVN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc3ViQ2FsbERlcHRoID0gMDtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc0NvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLnJlY29ubmVjdCA9IHRydWU7XG4gICAgICAgIHRoaXMub25FcnJvckNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLm9uQ2xvc2VDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdGhpcy5vbk9wZW5DYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGhhbmRsZSBlcnJvcnNcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBvbkVycm9yKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub25FcnJvckNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBjbG9zZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gaGFuZGxlIGNvbm5lY3Rpb24gY2xvc2VcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBvbkNsb3NlKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub25DbG9zZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBvcGVuc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbiB0byBoYW5kbGUgY29ubmVjdGlvbiBvcGVuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgb25PcGVuKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub25PcGVuQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgICBzdGFydEhlYXJ0YmVhdCgpIHtcbiAgICAgICAgdGhpcy5zdG9wSGVhcnRiZWF0KCk7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0ICYmIHRoaXMuc29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7IHR5cGU6ICdwaW5nJyB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuSEVBUlRCRUFUX0lOVEVSVkFMKTtcbiAgICB9XG4gICAgc3RvcEhlYXJ0YmVhdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVhcnRiZWF0VGltZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVTb2NrZXQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVDaGFubmVscy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNsb3NlU29ja2V0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJvamVjdElkID0gdGhpcy5jbGllbnQuY29uZmlnLnByb2plY3Q7XG4gICAgICAgICAgICBpZiAoIXByb2plY3RJZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyBwcm9qZWN0IElEJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSBgcHJvamVjdD0ke3Byb2plY3RJZH1gO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGFubmVsIG9mIHRoaXMuYWN0aXZlQ2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcyArPSBgJmNoYW5uZWxzW109JHtlbmNvZGVVUklDb21wb25lbnQoY2hhbm5lbCl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50UmVhbHRpbWUgIT09ICcnXG4gICAgICAgICAgICAgICAgPyB0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnRSZWFsdGltZVxuICAgICAgICAgICAgICAgIDogdGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50IHx8ICcnO1xuICAgICAgICAgICAgY29uc3QgcmVhbHRpbWVFbmRwb2ludCA9IGVuZHBvaW50XG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ2h0dHBzOi8vJywgJ3dzczovLycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ2h0dHA6Ly8nLCAnd3M6Ly8nKTtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGAke3JlYWx0aW1lRW5kcG9pbnR9L3JlYWx0aW1lPyR7cXVlcnlQYXJhbXN9YDtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvY2tldCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jbG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldCA9IG5ldyBXZWJTb2NrZXQodXJsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk9wZW5DYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjaygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRIZWFydGJlYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBhcnNlIG1lc3NhZ2U6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCAoZXZlbnQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcEhlYXJ0YmVhdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVjb25uZWN0IHx8IGV2ZW50LmNvZGUgPT09IFJlYWx0aW1lQ29kZS5QT0xJQ1lfVklPTEFUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLmdldFRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZWFsdGltZSBkaXNjb25uZWN0ZWQuIFJlLWNvbm5lY3RpbmcgaW4gJHt0aW1lb3V0IC8gMTAwMH0gc2Vjb25kcy5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuc2xlZXAodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY3JlYXRlU29ja2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcmVjb25uZWN0OicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wSGVhcnRiZWF0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignV2ViU29ja2V0IGVycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdXZWJTb2NrZXQgZXJyb3I6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3JDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhlcnJvcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvc2VTb2NrZXQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BIZWFydGJlYXQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvY2tldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoUmVhbHRpbWVDb2RlLk5PUk1BTF9DTE9TVVJFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VGltZW91dCgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPCA1KSB7XG4gICAgICAgICAgICByZXR1cm4gMTAwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnJlY29ubmVjdEF0dGVtcHRzIDwgMTUpIHtcbiAgICAgICAgICAgIHJldHVybiA1MDAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPCAxMDApIHtcbiAgICAgICAgICAgIHJldHVybiAxMDAwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiA2MDAwMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzbGVlcChtcykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG4gICAgfVxuICAgIHN1YnNjcmliZShjaGFubmVsc09yQ2hhbm5lbCwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxzID0gQXJyYXkuaXNBcnJheShjaGFubmVsc09yQ2hhbm5lbClcbiAgICAgICAgICAgICAgICA/IG5ldyBTZXQoY2hhbm5lbHNPckNoYW5uZWwpXG4gICAgICAgICAgICAgICAgOiBuZXcgU2V0KFtjaGFubmVsc09yQ2hhbm5lbF0pO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zQ291bnRlcisrO1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLnN1YnNjcmlwdGlvbnNDb3VudGVyO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGFubmVsIG9mIGNoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVDaGFubmVscy5hZGQoY2hhbm5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVN1YnNjcmlwdGlvbnMuc2V0KGNvdW50LCB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbHMsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zdWJDYWxsRGVwdGgrKztcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuc2xlZXAodGhpcy5ERUJPVU5DRV9NUyk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdWJDYWxsRGVwdGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNyZWF0ZVNvY2tldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdWJDYWxsRGVwdGgtLTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2xvc2U6ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVTdWJzY3JpcHRpb25zLmRlbGV0ZShjb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYW5VcChjaGFubmVscyk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY3JlYXRlU29ja2V0KCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbGVhblVwKGNoYW5uZWxzKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2hhbm5lbHMgPSBuZXcgU2V0KEFycmF5LmZyb20odGhpcy5hY3RpdmVDaGFubmVscykuZmlsdGVyKGNoYW5uZWwgPT4ge1xuICAgICAgICAgICAgaWYgKCFjaGFubmVscy5oYXMoY2hhbm5lbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN1YnNXaXRoQ2hhbm5lbCA9IEFycmF5LmZyb20odGhpcy5hY3RpdmVTdWJzY3JpcHRpb25zLnZhbHVlcygpKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoc3ViID0+IHN1Yi5jaGFubmVscy5oYXMoY2hhbm5lbCkpO1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNXaXRoQ2hhbm5lbC5sZW5ndGggPiAwO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBpZiAoIW1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIHRoaXMuVFlQRV9DT05ORUNURUQ6XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXNwb25zZUNvbm5lY3RlZChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5UWVBFX0VSUk9SOlxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzcG9uc2VFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5UWVBFX0VWRU5UOlxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzcG9uc2VFdmVudChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5UWVBFX1BPTkc6XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHBvbmcgcmVzcG9uc2UgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlUmVzcG9uc2VDb25uZWN0ZWQobWVzc2FnZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoIW1lc3NhZ2UuZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VEYXRhID0gbWVzc2FnZS5kYXRhO1xuICAgICAgICBsZXQgc2Vzc2lvbiA9IHRoaXMuY2xpZW50LmNvbmZpZy5zZXNzaW9uO1xuICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29va2llID0gSlNPTi5wYXJzZSgoX2EgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2Nvb2tpZUZhbGxiYWNrJykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd7fScpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24gPSBjb29raWUgPT09IG51bGwgfHwgY29va2llID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb29raWVbYGFfc2Vzc2lvbl8ke3RoaXMuY2xpZW50LmNvbmZpZy5wcm9qZWN0fWBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBhcnNlIGNvb2tpZSBmYWxsYmFjazonLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlc3Npb24gJiYgIW1lc3NhZ2VEYXRhLnVzZXIpIHtcbiAgICAgICAgICAgIChfYiA9IHRoaXMuc29ja2V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2F1dGhlbnRpY2F0aW9uJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlUmVzcG9uc2VFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCgoX2EgPSBtZXNzYWdlLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlKSB8fCAnVW5rbm93biBlcnJvcicpO1xuICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gKF9iID0gbWVzc2FnZS5kYXRhKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29kZTtcbiAgICAgICAgdGhpcy5vbkVycm9yQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soZXJyb3IsIHN0YXR1c0NvZGUpKTtcbiAgICB9XG4gICAgaGFuZGxlUmVzcG9uc2VFdmVudChtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBtZXNzYWdlLmRhdGE7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYW5uZWxzID0gZGF0YS5jaGFubmVscztcbiAgICAgICAgY29uc3QgZXZlbnRzID0gZGF0YS5ldmVudHM7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhLnBheWxvYWQ7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IGRhdGEudGltZXN0YW1wO1xuICAgICAgICBpZiAoIWNoYW5uZWxzIHx8ICFldmVudHMgfHwgIXBheWxvYWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNBY3RpdmVDaGFubmVsID0gY2hhbm5lbHMuc29tZShjaGFubmVsID0+IHRoaXMuYWN0aXZlQ2hhbm5lbHMuaGFzKGNoYW5uZWwpKTtcbiAgICAgICAgaWYgKCFoYXNBY3RpdmVDaGFubmVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbXywgc3Vic2NyaXB0aW9uXSBvZiB0aGlzLmFjdGl2ZVN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhc1N1YnNjcmliZWRDaGFubmVsID0gY2hhbm5lbHMuc29tZShjaGFubmVsID0+IHN1YnNjcmlwdGlvbi5jaGFubmVscy5oYXMoY2hhbm5lbCkpO1xuICAgICAgICAgICAgaWYgKGhhc1N1YnNjcmliZWRDaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHMsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmNhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gZ2VuZXJhdGUgcGVybWlzc2lvbiBzdHJpbmdzIGZvciByZXNvdXJjZXMuXG4gKi9cbmNsYXNzIFBlcm1pc3Npb24ge1xufVxuLyoqXG4gKiBHZW5lcmF0ZSByZWFkIHBlcm1pc3Npb24gc3RyaW5nIGZvciB0aGUgcHJvdmlkZWQgcm9sZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9sZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUGVybWlzc2lvbi5yZWFkID0gKHJvbGUpID0+IHtcbiAgICByZXR1cm4gYHJlYWQoXCIke3JvbGV9XCIpYDtcbn07XG4vKipcbiAqIEdlbmVyYXRlIHdyaXRlIHBlcm1pc3Npb24gc3RyaW5nIGZvciB0aGUgcHJvdmlkZWQgcm9sZS5cbiAqXG4gKiBUaGlzIGlzIGFuIGFsaWFzIG9mIHVwZGF0ZSwgZGVsZXRlLCBhbmQgcG9zc2libHkgY3JlYXRlLlxuICogRG9uJ3QgdXNlIHdyaXRlIGluIGNvbWJpbmF0aW9uIHdpdGggdXBkYXRlLCBkZWxldGUsIG9yIGNyZWF0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9sZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUGVybWlzc2lvbi53cml0ZSA9IChyb2xlKSA9PiB7XG4gICAgcmV0dXJuIGB3cml0ZShcIiR7cm9sZX1cIilgO1xufTtcbi8qKlxuICogR2VuZXJhdGUgY3JlYXRlIHBlcm1pc3Npb24gc3RyaW5nIGZvciB0aGUgcHJvdmlkZWQgcm9sZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9sZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUGVybWlzc2lvbi5jcmVhdGUgPSAocm9sZSkgPT4ge1xuICAgIHJldHVybiBgY3JlYXRlKFwiJHtyb2xlfVwiKWA7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZSB1cGRhdGUgcGVybWlzc2lvbiBzdHJpbmcgZm9yIHRoZSBwcm92aWRlZCByb2xlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByb2xlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5QZXJtaXNzaW9uLnVwZGF0ZSA9IChyb2xlKSA9PiB7XG4gICAgcmV0dXJuIGB1cGRhdGUoXCIke3JvbGV9XCIpYDtcbn07XG4vKipcbiAqIEdlbmVyYXRlIGRlbGV0ZSBwZXJtaXNzaW9uIHN0cmluZyBmb3IgdGhlIHByb3ZpZGVkIHJvbGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJvbGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblBlcm1pc3Npb24uZGVsZXRlID0gKHJvbGUpID0+IHtcbiAgICByZXR1cm4gYGRlbGV0ZShcIiR7cm9sZX1cIilgO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gZ2VuZXJhdGUgcm9sZSBzdHJpbmdzIGZvciBgUGVybWlzc2lvbmAuXG4gKi9cbmNsYXNzIFJvbGUge1xuICAgIC8qKlxuICAgICAqIEdyYW50cyBhY2Nlc3MgdG8gYW55b25lLlxuICAgICAqXG4gICAgICogVGhpcyBpbmNsdWRlcyBhdXRoZW50aWNhdGVkIGFuZCB1bmF1dGhlbnRpY2F0ZWQgdXNlcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBhbnkoKSB7XG4gICAgICAgIHJldHVybiAnYW55JztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR3JhbnRzIGFjY2VzcyB0byBhIHNwZWNpZmljIHVzZXIgYnkgdXNlciBJRC5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIHZlcmlmaWVkIG9yIHVudmVyaWZpZWQgZm9yXG4gICAgICogYHN0YXR1c2AgdG8gdGFyZ2V0IHNwZWNpZmljIHR5cGVzIG9mIHVzZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXR1c1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIHVzZXIoaWQsIHN0YXR1cyA9ICcnKSB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gYHVzZXI6JHtpZH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgdXNlcjoke2lkfS8ke3N0YXR1c31gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHcmFudHMgYWNjZXNzIHRvIGFueSBhdXRoZW50aWNhdGVkIG9yIGFub255bW91cyB1c2VyLlxuICAgICAqXG4gICAgICogWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgdmVyaWZpZWQgb3IgdW52ZXJpZmllZCBmb3JcbiAgICAgKiBgc3RhdHVzYCB0byB0YXJnZXQgc3BlY2lmaWMgdHlwZXMgb2YgdXNlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdHVzXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgdXNlcnMoc3RhdHVzID0gJycpIHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiAndXNlcnMnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgdXNlcnMvJHtzdGF0dXN9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR3JhbnRzIGFjY2VzcyB0byBhbnkgZ3Vlc3QgdXNlciB3aXRob3V0IGEgc2Vzc2lvbi5cbiAgICAgKlxuICAgICAqIEF1dGhlbnRpY2F0ZWQgdXNlcnMgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhpcyByb2xlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZ3Vlc3RzKCkge1xuICAgICAgICByZXR1cm4gJ2d1ZXN0cyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdyYW50cyBhY2Nlc3MgdG8gYSB0ZWFtIGJ5IHRlYW0gSUQuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIG9wdGlvbmFsbHkgcGFzcyBhIHJvbGUgZm9yIGByb2xlYCB0byB0YXJnZXRcbiAgICAgKiB0ZWFtIG1lbWJlcnMgd2l0aCB0aGUgc3BlY2lmaWVkIHJvbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm9sZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIHRlYW0oaWQsIHJvbGUgPSAnJykge1xuICAgICAgICBpZiAocm9sZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBgdGVhbToke2lkfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGB0ZWFtOiR7aWR9LyR7cm9sZX1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHcmFudHMgYWNjZXNzIHRvIGEgc3BlY2lmaWMgbWVtYmVyIG9mIGEgdGVhbS5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIG1lbWJlciBpcyByZW1vdmVkIGZyb20gdGhlIHRlYW0sIHRoZXkgd2lsbFxuICAgICAqIG5vIGxvbmdlciBoYXZlIGFjY2Vzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIG1lbWJlcihpZCkge1xuICAgICAgICByZXR1cm4gYG1lbWJlcjoke2lkfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdyYW50cyBhY2Nlc3MgdG8gYSB1c2VyIHdpdGggdGhlIHNwZWNpZmllZCBsYWJlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMgIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIGxhYmVsKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGBsYWJlbDoke25hbWV9YDtcbiAgICB9XG59XG5cbnZhciBfYSwgX0lEX2hleFRpbWVzdGFtcDtcbi8qKlxuICogSGVscGVyIGNsYXNzIHRvIGdlbmVyYXRlIElEIHN0cmluZ3MgZm9yIHJlc291cmNlcy5cbiAqL1xuY2xhc3MgSUQge1xuICAgIC8qKlxuICAgICAqIFVzZXMgdGhlIHByb3ZpZGVkIElEIGFzIHRoZSBJRCBmb3IgdGhlIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgY3VzdG9tKGlkKSB7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGF2ZSBBcHB3cml0ZSBnZW5lcmF0ZSBhIHVuaXF1ZSBJRCBmb3IgeW91LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmcuIERlZmF1bHQgaXMgNy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyB1bmlxdWUocGFkZGluZyA9IDcpIHtcbiAgICAgICAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgSUQgd2l0aCBwYWRkaW5nIHRvIGhhdmUgYSBsb25nZXIgSURcbiAgICAgICAgY29uc3QgYmFzZUlkID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldChJRCwgX2EsIFwibVwiLCBfSURfaGV4VGltZXN0YW1wKS5jYWxsKElEKTtcbiAgICAgICAgbGV0IHJhbmRvbVBhZGRpbmcgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWRkaW5nOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmRvbUhleERpZ2l0ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTYpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIHJhbmRvbVBhZGRpbmcgKz0gcmFuZG9tSGV4RGlnaXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VJZCArIHJhbmRvbVBhZGRpbmc7XG4gICAgfVxufVxuX2EgPSBJRCwgX0lEX2hleFRpbWVzdGFtcCA9IGZ1bmN0aW9uIF9JRF9oZXhUaW1lc3RhbXAoKSB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCBzZWMgPSBNYXRoLmZsb29yKG5vdy5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgICBjb25zdCBtc2VjID0gbm93LmdldE1pbGxpc2Vjb25kcygpO1xuICAgIC8vIENvbnZlcnQgdG8gaGV4YWRlY2ltYWxcbiAgICBjb25zdCBoZXhUaW1lc3RhbXAgPSBzZWMudG9TdHJpbmcoMTYpICsgbXNlYy50b1N0cmluZygxNikucGFkU3RhcnQoNSwgJzAnKTtcbiAgICByZXR1cm4gaGV4VGltZXN0YW1wO1xufTtcblxudmFyIENvbmRpdGlvbjtcbihmdW5jdGlvbiAoQ29uZGl0aW9uKSB7XG4gICAgQ29uZGl0aW9uW1wiRXF1YWxcIl0gPSBcImVxdWFsXCI7XG4gICAgQ29uZGl0aW9uW1wiTm90RXF1YWxcIl0gPSBcIm5vdEVxdWFsXCI7XG4gICAgQ29uZGl0aW9uW1wiR3JlYXRlclRoYW5cIl0gPSBcImdyZWF0ZXJUaGFuXCI7XG4gICAgQ29uZGl0aW9uW1wiR3JlYXRlclRoYW5FcXVhbFwiXSA9IFwiZ3JlYXRlclRoYW5FcXVhbFwiO1xuICAgIENvbmRpdGlvbltcIkxlc3NUaGFuXCJdID0gXCJsZXNzVGhhblwiO1xuICAgIENvbmRpdGlvbltcIkxlc3NUaGFuRXF1YWxcIl0gPSBcImxlc3NUaGFuRXF1YWxcIjtcbiAgICBDb25kaXRpb25bXCJDb250YWluc1wiXSA9IFwiY29udGFpbnNcIjtcbiAgICBDb25kaXRpb25bXCJJc051bGxcIl0gPSBcImlzTnVsbFwiO1xuICAgIENvbmRpdGlvbltcIklzTm90TnVsbFwiXSA9IFwiaXNOb3ROdWxsXCI7XG59KShDb25kaXRpb24gfHwgKENvbmRpdGlvbiA9IHt9KSk7XG4vKipcbiAqIEhlbHBlciBjbGFzcyB0byBnZW5lcmF0ZSBvcGVyYXRvciBzdHJpbmdzIGZvciBhdG9taWMgb3BlcmF0aW9ucy5cbiAqL1xuY2xhc3MgT3BlcmF0b3Ige1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBPcGVyYXRvciBjbGFzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiAgICAgKiBAcGFyYW0ge09wZXJhdG9yVmFsdWVzfSB2YWx1ZXNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIHZhbHVlcykge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgaWYgKHZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIG9wZXJhdG9yIG9iamVjdCB0byBhIEpTT04gc3RyaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgICAgICAgICB2YWx1ZXM6IHRoaXMudmFsdWVzLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIEluY3JlbWVudCBhIG51bWVyaWMgYXR0cmlidXRlIGJ5IGEgc3BlY2lmaWVkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuT3BlcmF0b3IuaW5jcmVtZW50ID0gKHZhbHVlID0gMSwgbWF4KSA9PiB7XG4gICAgaWYgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIGNhbm5vdCBiZSBOYU4gb3IgSW5maW5pdHlcIik7XG4gICAgfVxuICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCAmJiAoaXNOYU4obWF4KSB8fCAhaXNGaW5pdGUobWF4KSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWF4IGNhbm5vdCBiZSBOYU4gb3IgSW5maW5pdHlcIik7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlcyA9IFt2YWx1ZV07XG4gICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKG1heCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT3BlcmF0b3IoXCJpbmNyZW1lbnRcIiwgdmFsdWVzKS50b1N0cmluZygpO1xufTtcbi8qKlxuICogRGVjcmVtZW50IGEgbnVtZXJpYyBhdHRyaWJ1dGUgYnkgYSBzcGVjaWZpZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gbWluXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5PcGVyYXRvci5kZWNyZW1lbnQgPSAodmFsdWUgPSAxLCBtaW4pID0+IHtcbiAgICBpZiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgY2Fubm90IGJlIE5hTiBvciBJbmZpbml0eVwiKTtcbiAgICB9XG4gICAgaWYgKG1pbiAhPT0gdW5kZWZpbmVkICYmIChpc05hTihtaW4pIHx8ICFpc0Zpbml0ZShtaW4pKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaW4gY2Fubm90IGJlIE5hTiBvciBJbmZpbml0eVwiKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVzID0gW3ZhbHVlXTtcbiAgICBpZiAobWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWVzLnB1c2gobWluKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPcGVyYXRvcihcImRlY3JlbWVudFwiLCB2YWx1ZXMpLnRvU3RyaW5nKCk7XG59O1xuLyoqXG4gKiBNdWx0aXBseSBhIG51bWVyaWMgYXR0cmlidXRlIGJ5IGEgc3BlY2lmaWVkIGZhY3Rvci5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZmFjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5PcGVyYXRvci5tdWx0aXBseSA9IChmYWN0b3IsIG1heCkgPT4ge1xuICAgIGlmIChpc05hTihmYWN0b3IpIHx8ICFpc0Zpbml0ZShmYWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhY3RvciBjYW5ub3QgYmUgTmFOIG9yIEluZmluaXR5XCIpO1xuICAgIH1cbiAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQgJiYgKGlzTmFOKG1heCkgfHwgIWlzRmluaXRlKG1heCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1heCBjYW5ub3QgYmUgTmFOIG9yIEluZmluaXR5XCIpO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZXMgPSBbZmFjdG9yXTtcbiAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWVzLnB1c2gobWF4KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPcGVyYXRvcihcIm11bHRpcGx5XCIsIHZhbHVlcykudG9TdHJpbmcoKTtcbn07XG4vKipcbiAqIERpdmlkZSBhIG51bWVyaWMgYXR0cmlidXRlIGJ5IGEgc3BlY2lmaWVkIGRpdmlzb3IuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzb3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk9wZXJhdG9yLmRpdmlkZSA9IChkaXZpc29yLCBtaW4pID0+IHtcbiAgICBpZiAoaXNOYU4oZGl2aXNvcikgfHwgIWlzRmluaXRlKGRpdmlzb3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpdmlzb3IgY2Fubm90IGJlIE5hTiBvciBJbmZpbml0eVwiKTtcbiAgICB9XG4gICAgaWYgKG1pbiAhPT0gdW5kZWZpbmVkICYmIChpc05hTihtaW4pIHx8ICFpc0Zpbml0ZShtaW4pKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaW4gY2Fubm90IGJlIE5hTiBvciBJbmZpbml0eVwiKTtcbiAgICB9XG4gICAgaWYgKGRpdmlzb3IgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGl2aXNvciBjYW5ub3QgYmUgemVyb1wiKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVzID0gW2Rpdmlzb3JdO1xuICAgIGlmIChtaW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZXMucHVzaChtaW4pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE9wZXJhdG9yKFwiZGl2aWRlXCIsIHZhbHVlcykudG9TdHJpbmcoKTtcbn07XG4vKipcbiAqIEFwcGx5IG1vZHVsbyBvcGVyYXRpb24gb24gYSBudW1lcmljIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZGl2aXNvclxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuT3BlcmF0b3IubW9kdWxvID0gKGRpdmlzb3IpID0+IHtcbiAgICBpZiAoaXNOYU4oZGl2aXNvcikgfHwgIWlzRmluaXRlKGRpdmlzb3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpdmlzb3IgY2Fubm90IGJlIE5hTiBvciBJbmZpbml0eVwiKTtcbiAgICB9XG4gICAgaWYgKGRpdmlzb3IgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGl2aXNvciBjYW5ub3QgYmUgemVyb1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPcGVyYXRvcihcIm1vZHVsb1wiLCBbZGl2aXNvcl0pLnRvU3RyaW5nKCk7XG59O1xuLyoqXG4gKiBSYWlzZSBhIG51bWVyaWMgYXR0cmlidXRlIHRvIGEgc3BlY2lmaWVkIHBvd2VyLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudFxuICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuT3BlcmF0b3IucG93ZXIgPSAoZXhwb25lbnQsIG1heCkgPT4ge1xuICAgIGlmIChpc05hTihleHBvbmVudCkgfHwgIWlzRmluaXRlKGV4cG9uZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBvbmVudCBjYW5ub3QgYmUgTmFOIG9yIEluZmluaXR5XCIpO1xuICAgIH1cbiAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQgJiYgKGlzTmFOKG1heCkgfHwgIWlzRmluaXRlKG1heCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1heCBjYW5ub3QgYmUgTmFOIG9yIEluZmluaXR5XCIpO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZXMgPSBbZXhwb25lbnRdO1xuICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZXMucHVzaChtYXgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE9wZXJhdG9yKFwicG93ZXJcIiwgdmFsdWVzKS50b1N0cmluZygpO1xufTtcbi8qKlxuICogQXBwZW5kIHZhbHVlcyB0byBhbiBhcnJheSBhdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtIHthbnlbXX0gdmFsdWVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5PcGVyYXRvci5hcnJheUFwcGVuZCA9ICh2YWx1ZXMpID0+IG5ldyBPcGVyYXRvcihcImFycmF5QXBwZW5kXCIsIHZhbHVlcykudG9TdHJpbmcoKTtcbi8qKlxuICogUHJlcGVuZCB2YWx1ZXMgdG8gYW4gYXJyYXkgYXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSB7YW55W119IHZhbHVlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuT3BlcmF0b3IuYXJyYXlQcmVwZW5kID0gKHZhbHVlcykgPT4gbmV3IE9wZXJhdG9yKFwiYXJyYXlQcmVwZW5kXCIsIHZhbHVlcykudG9TdHJpbmcoKTtcbi8qKlxuICogSW5zZXJ0IGEgdmFsdWUgYXQgYSBzcGVjaWZpYyBpbmRleCBpbiBhbiBhcnJheSBhdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk9wZXJhdG9yLmFycmF5SW5zZXJ0ID0gKGluZGV4LCB2YWx1ZSkgPT4gbmV3IE9wZXJhdG9yKFwiYXJyYXlJbnNlcnRcIiwgW2luZGV4LCB2YWx1ZV0pLnRvU3RyaW5nKCk7XG4vKipcbiAqIFJlbW92ZSBhIHZhbHVlIGZyb20gYW4gYXJyYXkgYXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuT3BlcmF0b3IuYXJyYXlSZW1vdmUgPSAodmFsdWUpID0+IG5ldyBPcGVyYXRvcihcImFycmF5UmVtb3ZlXCIsIFt2YWx1ZV0pLnRvU3RyaW5nKCk7XG4vKipcbiAqIFJlbW92ZSBkdXBsaWNhdGUgdmFsdWVzIGZyb20gYW4gYXJyYXkgYXR0cmlidXRlLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk9wZXJhdG9yLmFycmF5VW5pcXVlID0gKCkgPT4gbmV3IE9wZXJhdG9yKFwiYXJyYXlVbmlxdWVcIiwgW10pLnRvU3RyaW5nKCk7XG4vKipcbiAqIEtlZXAgb25seSB2YWx1ZXMgdGhhdCBleGlzdCBpbiBib3RoIHRoZSBjdXJyZW50IGFycmF5IGFuZCB0aGUgcHJvdmlkZWQgYXJyYXkuXG4gKlxuICogQHBhcmFtIHthbnlbXX0gdmFsdWVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5PcGVyYXRvci5hcnJheUludGVyc2VjdCA9ICh2YWx1ZXMpID0+IG5ldyBPcGVyYXRvcihcImFycmF5SW50ZXJzZWN0XCIsIHZhbHVlcykudG9TdHJpbmcoKTtcbi8qKlxuICogUmVtb3ZlIHZhbHVlcyBmcm9tIHRoZSBhcnJheSB0aGF0IGV4aXN0IGluIHRoZSBwcm92aWRlZCBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge2FueVtdfSB2YWx1ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk9wZXJhdG9yLmFycmF5RGlmZiA9ICh2YWx1ZXMpID0+IG5ldyBPcGVyYXRvcihcImFycmF5RGlmZlwiLCB2YWx1ZXMpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciBhcnJheSB2YWx1ZXMgYmFzZWQgb24gYSBjb25kaXRpb24uXG4gKlxuICogQHBhcmFtIHtDb25kaXRpb259IGNvbmRpdGlvblxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5PcGVyYXRvci5hcnJheUZpbHRlciA9IChjb25kaXRpb24sIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgdmFsdWVzID0gW2NvbmRpdGlvbiwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB2YWx1ZV07XG4gICAgcmV0dXJuIG5ldyBPcGVyYXRvcihcImFycmF5RmlsdGVyXCIsIHZhbHVlcykudG9TdHJpbmcoKTtcbn07XG4vKipcbiAqIENvbmNhdGVuYXRlIGEgdmFsdWUgdG8gYSBzdHJpbmcgb3IgYXJyYXkgYXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuT3BlcmF0b3Iuc3RyaW5nQ29uY2F0ID0gKHZhbHVlKSA9PiBuZXcgT3BlcmF0b3IoXCJzdHJpbmdDb25jYXRcIiwgW3ZhbHVlXSkudG9TdHJpbmcoKTtcbi8qKlxuICogUmVwbGFjZSBvY2N1cnJlbmNlcyBvZiBhIHNlYXJjaCBzdHJpbmcgd2l0aCBhIHJlcGxhY2VtZW50IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVwbGFjZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuT3BlcmF0b3Iuc3RyaW5nUmVwbGFjZSA9IChzZWFyY2gsIHJlcGxhY2UpID0+IG5ldyBPcGVyYXRvcihcInN0cmluZ1JlcGxhY2VcIiwgW3NlYXJjaCwgcmVwbGFjZV0pLnRvU3RyaW5nKCk7XG4vKipcbiAqIFRvZ2dsZSBhIGJvb2xlYW4gYXR0cmlidXRlLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk9wZXJhdG9yLnRvZ2dsZSA9ICgpID0+IG5ldyBPcGVyYXRvcihcInRvZ2dsZVwiLCBbXSkudG9TdHJpbmcoKTtcbi8qKlxuICogQWRkIGRheXMgdG8gYSBkYXRlIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZGF5c1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuT3BlcmF0b3IuZGF0ZUFkZERheXMgPSAoZGF5cykgPT4gbmV3IE9wZXJhdG9yKFwiZGF0ZUFkZERheXNcIiwgW2RheXNdKS50b1N0cmluZygpO1xuLyoqXG4gKiBTdWJ0cmFjdCBkYXlzIGZyb20gYSBkYXRlIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZGF5c1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuT3BlcmF0b3IuZGF0ZVN1YkRheXMgPSAoZGF5cykgPT4gbmV3IE9wZXJhdG9yKFwiZGF0ZVN1YkRheXNcIiwgW2RheXNdKS50b1N0cmluZygpO1xuLyoqXG4gKiBTZXQgYSBkYXRlIGF0dHJpYnV0ZSB0byB0aGUgY3VycmVudCBkYXRlIGFuZCB0aW1lLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk9wZXJhdG9yLmRhdGVTZXROb3cgPSAoKSA9PiBuZXcgT3BlcmF0b3IoXCJkYXRlU2V0Tm93XCIsIFtdKS50b1N0cmluZygpO1xuXG52YXIgQXV0aGVudGljYXRvclR5cGU7XG4oZnVuY3Rpb24gKEF1dGhlbnRpY2F0b3JUeXBlKSB7XG4gICAgQXV0aGVudGljYXRvclR5cGVbXCJUb3RwXCJdID0gXCJ0b3RwXCI7XG59KShBdXRoZW50aWNhdG9yVHlwZSB8fCAoQXV0aGVudGljYXRvclR5cGUgPSB7fSkpO1xuXG52YXIgQXV0aGVudGljYXRpb25GYWN0b3I7XG4oZnVuY3Rpb24gKEF1dGhlbnRpY2F0aW9uRmFjdG9yKSB7XG4gICAgQXV0aGVudGljYXRpb25GYWN0b3JbXCJFbWFpbFwiXSA9IFwiZW1haWxcIjtcbiAgICBBdXRoZW50aWNhdGlvbkZhY3RvcltcIlBob25lXCJdID0gXCJwaG9uZVwiO1xuICAgIEF1dGhlbnRpY2F0aW9uRmFjdG9yW1wiVG90cFwiXSA9IFwidG90cFwiO1xuICAgIEF1dGhlbnRpY2F0aW9uRmFjdG9yW1wiUmVjb3Zlcnljb2RlXCJdID0gXCJyZWNvdmVyeWNvZGVcIjtcbn0pKEF1dGhlbnRpY2F0aW9uRmFjdG9yIHx8IChBdXRoZW50aWNhdGlvbkZhY3RvciA9IHt9KSk7XG5cbnZhciBPQXV0aFByb3ZpZGVyO1xuKGZ1bmN0aW9uIChPQXV0aFByb3ZpZGVyKSB7XG4gICAgT0F1dGhQcm92aWRlcltcIkFtYXpvblwiXSA9IFwiYW1hem9uXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIkFwcGxlXCJdID0gXCJhcHBsZVwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJBdXRoMFwiXSA9IFwiYXV0aDBcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiQXV0aGVudGlrXCJdID0gXCJhdXRoZW50aWtcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiQXV0b2Rlc2tcIl0gPSBcImF1dG9kZXNrXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIkJpdGJ1Y2tldFwiXSA9IFwiYml0YnVja2V0XCI7XG4gICAgT0F1dGhQcm92aWRlcltcIkJpdGx5XCJdID0gXCJiaXRseVwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJCb3hcIl0gPSBcImJveFwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJEYWlseW1vdGlvblwiXSA9IFwiZGFpbHltb3Rpb25cIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiRGlzY29yZFwiXSA9IFwiZGlzY29yZFwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJEaXNxdXNcIl0gPSBcImRpc3F1c1wiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJEcm9wYm94XCJdID0gXCJkcm9wYm94XCI7XG4gICAgT0F1dGhQcm92aWRlcltcIkV0c3lcIl0gPSBcImV0c3lcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiRmFjZWJvb2tcIl0gPSBcImZhY2Vib29rXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIkZpZ21hXCJdID0gXCJmaWdtYVwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJHaXRodWJcIl0gPSBcImdpdGh1YlwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJHaXRsYWJcIl0gPSBcImdpdGxhYlwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJHb29nbGVcIl0gPSBcImdvb2dsZVwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJMaW5rZWRpblwiXSA9IFwibGlua2VkaW5cIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiTWljcm9zb2Z0XCJdID0gXCJtaWNyb3NvZnRcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiTm90aW9uXCJdID0gXCJub3Rpb25cIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiT2lkY1wiXSA9IFwib2lkY1wiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJPa3RhXCJdID0gXCJva3RhXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIlBheXBhbFwiXSA9IFwicGF5cGFsXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIlBheXBhbFNhbmRib3hcIl0gPSBcInBheXBhbFNhbmRib3hcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiUG9kaW9cIl0gPSBcInBvZGlvXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIlNhbGVzZm9yY2VcIl0gPSBcInNhbGVzZm9yY2VcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiU2xhY2tcIl0gPSBcInNsYWNrXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIlNwb3RpZnlcIl0gPSBcInNwb3RpZnlcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiU3RyaXBlXCJdID0gXCJzdHJpcGVcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiVHJhZGVzaGlmdFwiXSA9IFwidHJhZGVzaGlmdFwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJUcmFkZXNoaWZ0Qm94XCJdID0gXCJ0cmFkZXNoaWZ0Qm94XCI7XG4gICAgT0F1dGhQcm92aWRlcltcIlR3aXRjaFwiXSA9IFwidHdpdGNoXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIldvcmRwcmVzc1wiXSA9IFwid29yZHByZXNzXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIllhaG9vXCJdID0gXCJ5YWhvb1wiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJZYW1tZXJcIl0gPSBcInlhbW1lclwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJZYW5kZXhcIl0gPSBcInlhbmRleFwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJab2hvXCJdID0gXCJ6b2hvXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIlpvb21cIl0gPSBcInpvb21cIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiTW9ja1wiXSA9IFwibW9ja1wiO1xufSkoT0F1dGhQcm92aWRlciB8fCAoT0F1dGhQcm92aWRlciA9IHt9KSk7XG5cbnZhciBCcm93c2VyO1xuKGZ1bmN0aW9uIChCcm93c2VyKSB7XG4gICAgQnJvd3NlcltcIkF2YW50QnJvd3NlclwiXSA9IFwiYWFcIjtcbiAgICBCcm93c2VyW1wiQW5kcm9pZFdlYlZpZXdCZXRhXCJdID0gXCJhblwiO1xuICAgIEJyb3dzZXJbXCJHb29nbGVDaHJvbWVcIl0gPSBcImNoXCI7XG4gICAgQnJvd3NlcltcIkdvb2dsZUNocm9tZUlPU1wiXSA9IFwiY2lcIjtcbiAgICBCcm93c2VyW1wiR29vZ2xlQ2hyb21lTW9iaWxlXCJdID0gXCJjbVwiO1xuICAgIEJyb3dzZXJbXCJDaHJvbWl1bVwiXSA9IFwiY3JcIjtcbiAgICBCcm93c2VyW1wiTW96aWxsYUZpcmVmb3hcIl0gPSBcImZmXCI7XG4gICAgQnJvd3NlcltcIlNhZmFyaVwiXSA9IFwic2ZcIjtcbiAgICBCcm93c2VyW1wiTW9iaWxlU2FmYXJpXCJdID0gXCJtZlwiO1xuICAgIEJyb3dzZXJbXCJNaWNyb3NvZnRFZGdlXCJdID0gXCJwc1wiO1xuICAgIEJyb3dzZXJbXCJNaWNyb3NvZnRFZGdlSU9TXCJdID0gXCJvaVwiO1xuICAgIEJyb3dzZXJbXCJPcGVyYU1pbmlcIl0gPSBcIm9tXCI7XG4gICAgQnJvd3NlcltcIk9wZXJhXCJdID0gXCJvcFwiO1xuICAgIEJyb3dzZXJbXCJPcGVyYU5leHRcIl0gPSBcIm9uXCI7XG59KShCcm93c2VyIHx8IChCcm93c2VyID0ge30pKTtcblxudmFyIENyZWRpdENhcmQ7XG4oZnVuY3Rpb24gKENyZWRpdENhcmQpIHtcbiAgICBDcmVkaXRDYXJkW1wiQW1lcmljYW5FeHByZXNzXCJdID0gXCJhbWV4XCI7XG4gICAgQ3JlZGl0Q2FyZFtcIkFyZ2VuY2FyZFwiXSA9IFwiYXJnZW5jYXJkXCI7XG4gICAgQ3JlZGl0Q2FyZFtcIkNhYmFsXCJdID0gXCJjYWJhbFwiO1xuICAgIENyZWRpdENhcmRbXCJDZW5jb3N1ZFwiXSA9IFwiY2VuY29zdWRcIjtcbiAgICBDcmVkaXRDYXJkW1wiRGluZXJzQ2x1YlwiXSA9IFwiZGluZXJzXCI7XG4gICAgQ3JlZGl0Q2FyZFtcIkRpc2NvdmVyXCJdID0gXCJkaXNjb3ZlclwiO1xuICAgIENyZWRpdENhcmRbXCJFbG9cIl0gPSBcImVsb1wiO1xuICAgIENyZWRpdENhcmRbXCJIaXBlcmNhcmRcIl0gPSBcImhpcGVyY2FyZFwiO1xuICAgIENyZWRpdENhcmRbXCJKQ0JcIl0gPSBcImpjYlwiO1xuICAgIENyZWRpdENhcmRbXCJNYXN0ZXJjYXJkXCJdID0gXCJtYXN0ZXJjYXJkXCI7XG4gICAgQ3JlZGl0Q2FyZFtcIk5hcmFuamFcIl0gPSBcIm5hcmFuamFcIjtcbiAgICBDcmVkaXRDYXJkW1wiVGFyamV0YVNob3BwaW5nXCJdID0gXCJ0YXJnZXRhLXNob3BwaW5nXCI7XG4gICAgQ3JlZGl0Q2FyZFtcIlVuaW9uUGF5XCJdID0gXCJ1bmlvbnBheVwiO1xuICAgIENyZWRpdENhcmRbXCJWaXNhXCJdID0gXCJ2aXNhXCI7XG4gICAgQ3JlZGl0Q2FyZFtcIk1JUlwiXSA9IFwibWlyXCI7XG4gICAgQ3JlZGl0Q2FyZFtcIk1hZXN0cm9cIl0gPSBcIm1hZXN0cm9cIjtcbiAgICBDcmVkaXRDYXJkW1wiUnVwYXlcIl0gPSBcInJ1cGF5XCI7XG59KShDcmVkaXRDYXJkIHx8IChDcmVkaXRDYXJkID0ge30pKTtcblxudmFyIEZsYWc7XG4oZnVuY3Rpb24gKEZsYWcpIHtcbiAgICBGbGFnW1wiQWZnaGFuaXN0YW5cIl0gPSBcImFmXCI7XG4gICAgRmxhZ1tcIkFuZ29sYVwiXSA9IFwiYW9cIjtcbiAgICBGbGFnW1wiQWxiYW5pYVwiXSA9IFwiYWxcIjtcbiAgICBGbGFnW1wiQW5kb3JyYVwiXSA9IFwiYWRcIjtcbiAgICBGbGFnW1wiVW5pdGVkQXJhYkVtaXJhdGVzXCJdID0gXCJhZVwiO1xuICAgIEZsYWdbXCJBcmdlbnRpbmFcIl0gPSBcImFyXCI7XG4gICAgRmxhZ1tcIkFybWVuaWFcIl0gPSBcImFtXCI7XG4gICAgRmxhZ1tcIkFudGlndWFBbmRCYXJidWRhXCJdID0gXCJhZ1wiO1xuICAgIEZsYWdbXCJBdXN0cmFsaWFcIl0gPSBcImF1XCI7XG4gICAgRmxhZ1tcIkF1c3RyaWFcIl0gPSBcImF0XCI7XG4gICAgRmxhZ1tcIkF6ZXJiYWlqYW5cIl0gPSBcImF6XCI7XG4gICAgRmxhZ1tcIkJ1cnVuZGlcIl0gPSBcImJpXCI7XG4gICAgRmxhZ1tcIkJlbGdpdW1cIl0gPSBcImJlXCI7XG4gICAgRmxhZ1tcIkJlbmluXCJdID0gXCJialwiO1xuICAgIEZsYWdbXCJCdXJraW5hRmFzb1wiXSA9IFwiYmZcIjtcbiAgICBGbGFnW1wiQmFuZ2xhZGVzaFwiXSA9IFwiYmRcIjtcbiAgICBGbGFnW1wiQnVsZ2FyaWFcIl0gPSBcImJnXCI7XG4gICAgRmxhZ1tcIkJhaHJhaW5cIl0gPSBcImJoXCI7XG4gICAgRmxhZ1tcIkJhaGFtYXNcIl0gPSBcImJzXCI7XG4gICAgRmxhZ1tcIkJvc25pYUFuZEhlcnplZ292aW5hXCJdID0gXCJiYVwiO1xuICAgIEZsYWdbXCJCZWxhcnVzXCJdID0gXCJieVwiO1xuICAgIEZsYWdbXCJCZWxpemVcIl0gPSBcImJ6XCI7XG4gICAgRmxhZ1tcIkJvbGl2aWFcIl0gPSBcImJvXCI7XG4gICAgRmxhZ1tcIkJyYXppbFwiXSA9IFwiYnJcIjtcbiAgICBGbGFnW1wiQmFyYmFkb3NcIl0gPSBcImJiXCI7XG4gICAgRmxhZ1tcIkJydW5laURhcnVzc2FsYW1cIl0gPSBcImJuXCI7XG4gICAgRmxhZ1tcIkJodXRhblwiXSA9IFwiYnRcIjtcbiAgICBGbGFnW1wiQm90c3dhbmFcIl0gPSBcImJ3XCI7XG4gICAgRmxhZ1tcIkNlbnRyYWxBZnJpY2FuUmVwdWJsaWNcIl0gPSBcImNmXCI7XG4gICAgRmxhZ1tcIkNhbmFkYVwiXSA9IFwiY2FcIjtcbiAgICBGbGFnW1wiU3dpdHplcmxhbmRcIl0gPSBcImNoXCI7XG4gICAgRmxhZ1tcIkNoaWxlXCJdID0gXCJjbFwiO1xuICAgIEZsYWdbXCJDaGluYVwiXSA9IFwiY25cIjtcbiAgICBGbGFnW1wiQ290ZURJdm9pcmVcIl0gPSBcImNpXCI7XG4gICAgRmxhZ1tcIkNhbWVyb29uXCJdID0gXCJjbVwiO1xuICAgIEZsYWdbXCJEZW1vY3JhdGljUmVwdWJsaWNPZlRoZUNvbmdvXCJdID0gXCJjZFwiO1xuICAgIEZsYWdbXCJSZXB1YmxpY09mVGhlQ29uZ29cIl0gPSBcImNnXCI7XG4gICAgRmxhZ1tcIkNvbG9tYmlhXCJdID0gXCJjb1wiO1xuICAgIEZsYWdbXCJDb21vcm9zXCJdID0gXCJrbVwiO1xuICAgIEZsYWdbXCJDYXBlVmVyZGVcIl0gPSBcImN2XCI7XG4gICAgRmxhZ1tcIkNvc3RhUmljYVwiXSA9IFwiY3JcIjtcbiAgICBGbGFnW1wiQ3ViYVwiXSA9IFwiY3VcIjtcbiAgICBGbGFnW1wiQ3lwcnVzXCJdID0gXCJjeVwiO1xuICAgIEZsYWdbXCJDemVjaFJlcHVibGljXCJdID0gXCJjelwiO1xuICAgIEZsYWdbXCJHZXJtYW55XCJdID0gXCJkZVwiO1xuICAgIEZsYWdbXCJEamlib3V0aVwiXSA9IFwiZGpcIjtcbiAgICBGbGFnW1wiRG9taW5pY2FcIl0gPSBcImRtXCI7XG4gICAgRmxhZ1tcIkRlbm1hcmtcIl0gPSBcImRrXCI7XG4gICAgRmxhZ1tcIkRvbWluaWNhblJlcHVibGljXCJdID0gXCJkb1wiO1xuICAgIEZsYWdbXCJBbGdlcmlhXCJdID0gXCJkelwiO1xuICAgIEZsYWdbXCJFY3VhZG9yXCJdID0gXCJlY1wiO1xuICAgIEZsYWdbXCJFZ3lwdFwiXSA9IFwiZWdcIjtcbiAgICBGbGFnW1wiRXJpdHJlYVwiXSA9IFwiZXJcIjtcbiAgICBGbGFnW1wiU3BhaW5cIl0gPSBcImVzXCI7XG4gICAgRmxhZ1tcIkVzdG9uaWFcIl0gPSBcImVlXCI7XG4gICAgRmxhZ1tcIkV0aGlvcGlhXCJdID0gXCJldFwiO1xuICAgIEZsYWdbXCJGaW5sYW5kXCJdID0gXCJmaVwiO1xuICAgIEZsYWdbXCJGaWppXCJdID0gXCJmalwiO1xuICAgIEZsYWdbXCJGcmFuY2VcIl0gPSBcImZyXCI7XG4gICAgRmxhZ1tcIk1pY3JvbmVzaWFGZWRlcmF0ZWRTdGF0ZXNPZlwiXSA9IFwiZm1cIjtcbiAgICBGbGFnW1wiR2Fib25cIl0gPSBcImdhXCI7XG4gICAgRmxhZ1tcIlVuaXRlZEtpbmdkb21cIl0gPSBcImdiXCI7XG4gICAgRmxhZ1tcIkdlb3JnaWFcIl0gPSBcImdlXCI7XG4gICAgRmxhZ1tcIkdoYW5hXCJdID0gXCJnaFwiO1xuICAgIEZsYWdbXCJHdWluZWFcIl0gPSBcImduXCI7XG4gICAgRmxhZ1tcIkdhbWJpYVwiXSA9IFwiZ21cIjtcbiAgICBGbGFnW1wiR3VpbmVhQmlzc2F1XCJdID0gXCJnd1wiO1xuICAgIEZsYWdbXCJFcXVhdG9yaWFsR3VpbmVhXCJdID0gXCJncVwiO1xuICAgIEZsYWdbXCJHcmVlY2VcIl0gPSBcImdyXCI7XG4gICAgRmxhZ1tcIkdyZW5hZGFcIl0gPSBcImdkXCI7XG4gICAgRmxhZ1tcIkd1YXRlbWFsYVwiXSA9IFwiZ3RcIjtcbiAgICBGbGFnW1wiR3V5YW5hXCJdID0gXCJneVwiO1xuICAgIEZsYWdbXCJIb25kdXJhc1wiXSA9IFwiaG5cIjtcbiAgICBGbGFnW1wiQ3JvYXRpYVwiXSA9IFwiaHJcIjtcbiAgICBGbGFnW1wiSGFpdGlcIl0gPSBcImh0XCI7XG4gICAgRmxhZ1tcIkh1bmdhcnlcIl0gPSBcImh1XCI7XG4gICAgRmxhZ1tcIkluZG9uZXNpYVwiXSA9IFwiaWRcIjtcbiAgICBGbGFnW1wiSW5kaWFcIl0gPSBcImluXCI7XG4gICAgRmxhZ1tcIklyZWxhbmRcIl0gPSBcImllXCI7XG4gICAgRmxhZ1tcIklyYW5Jc2xhbWljUmVwdWJsaWNPZlwiXSA9IFwiaXJcIjtcbiAgICBGbGFnW1wiSXJhcVwiXSA9IFwiaXFcIjtcbiAgICBGbGFnW1wiSWNlbGFuZFwiXSA9IFwiaXNcIjtcbiAgICBGbGFnW1wiSXNyYWVsXCJdID0gXCJpbFwiO1xuICAgIEZsYWdbXCJJdGFseVwiXSA9IFwiaXRcIjtcbiAgICBGbGFnW1wiSmFtYWljYVwiXSA9IFwiam1cIjtcbiAgICBGbGFnW1wiSm9yZGFuXCJdID0gXCJqb1wiO1xuICAgIEZsYWdbXCJKYXBhblwiXSA9IFwianBcIjtcbiAgICBGbGFnW1wiS2F6YWtoc3RhblwiXSA9IFwia3pcIjtcbiAgICBGbGFnW1wiS2VueWFcIl0gPSBcImtlXCI7XG4gICAgRmxhZ1tcIkt5cmd5enN0YW5cIl0gPSBcImtnXCI7XG4gICAgRmxhZ1tcIkNhbWJvZGlhXCJdID0gXCJraFwiO1xuICAgIEZsYWdbXCJLaXJpYmF0aVwiXSA9IFwia2lcIjtcbiAgICBGbGFnW1wiU2FpbnRLaXR0c0FuZE5ldmlzXCJdID0gXCJrblwiO1xuICAgIEZsYWdbXCJTb3V0aEtvcmVhXCJdID0gXCJrclwiO1xuICAgIEZsYWdbXCJLdXdhaXRcIl0gPSBcImt3XCI7XG4gICAgRmxhZ1tcIkxhb1Blb3BsZVNEZW1vY3JhdGljUmVwdWJsaWNcIl0gPSBcImxhXCI7XG4gICAgRmxhZ1tcIkxlYmFub25cIl0gPSBcImxiXCI7XG4gICAgRmxhZ1tcIkxpYmVyaWFcIl0gPSBcImxyXCI7XG4gICAgRmxhZ1tcIkxpYnlhXCJdID0gXCJseVwiO1xuICAgIEZsYWdbXCJTYWludEx1Y2lhXCJdID0gXCJsY1wiO1xuICAgIEZsYWdbXCJMaWVjaHRlbnN0ZWluXCJdID0gXCJsaVwiO1xuICAgIEZsYWdbXCJTcmlMYW5rYVwiXSA9IFwibGtcIjtcbiAgICBGbGFnW1wiTGVzb3Rob1wiXSA9IFwibHNcIjtcbiAgICBGbGFnW1wiTGl0aHVhbmlhXCJdID0gXCJsdFwiO1xuICAgIEZsYWdbXCJMdXhlbWJvdXJnXCJdID0gXCJsdVwiO1xuICAgIEZsYWdbXCJMYXR2aWFcIl0gPSBcImx2XCI7XG4gICAgRmxhZ1tcIk1vcm9jY29cIl0gPSBcIm1hXCI7XG4gICAgRmxhZ1tcIk1vbmFjb1wiXSA9IFwibWNcIjtcbiAgICBGbGFnW1wiTW9sZG92YVwiXSA9IFwibWRcIjtcbiAgICBGbGFnW1wiTWFkYWdhc2NhclwiXSA9IFwibWdcIjtcbiAgICBGbGFnW1wiTWFsZGl2ZXNcIl0gPSBcIm12XCI7XG4gICAgRmxhZ1tcIk1leGljb1wiXSA9IFwibXhcIjtcbiAgICBGbGFnW1wiTWFyc2hhbGxJc2xhbmRzXCJdID0gXCJtaFwiO1xuICAgIEZsYWdbXCJOb3J0aE1hY2Vkb25pYVwiXSA9IFwibWtcIjtcbiAgICBGbGFnW1wiTWFsaVwiXSA9IFwibWxcIjtcbiAgICBGbGFnW1wiTWFsdGFcIl0gPSBcIm10XCI7XG4gICAgRmxhZ1tcIk15YW5tYXJcIl0gPSBcIm1tXCI7XG4gICAgRmxhZ1tcIk1vbnRlbmVncm9cIl0gPSBcIm1lXCI7XG4gICAgRmxhZ1tcIk1vbmdvbGlhXCJdID0gXCJtblwiO1xuICAgIEZsYWdbXCJNb3phbWJpcXVlXCJdID0gXCJtelwiO1xuICAgIEZsYWdbXCJNYXVyaXRhbmlhXCJdID0gXCJtclwiO1xuICAgIEZsYWdbXCJNYXVyaXRpdXNcIl0gPSBcIm11XCI7XG4gICAgRmxhZ1tcIk1hbGF3aVwiXSA9IFwibXdcIjtcbiAgICBGbGFnW1wiTWFsYXlzaWFcIl0gPSBcIm15XCI7XG4gICAgRmxhZ1tcIk5hbWliaWFcIl0gPSBcIm5hXCI7XG4gICAgRmxhZ1tcIk5pZ2VyXCJdID0gXCJuZVwiO1xuICAgIEZsYWdbXCJOaWdlcmlhXCJdID0gXCJuZ1wiO1xuICAgIEZsYWdbXCJOaWNhcmFndWFcIl0gPSBcIm5pXCI7XG4gICAgRmxhZ1tcIk5ldGhlcmxhbmRzXCJdID0gXCJubFwiO1xuICAgIEZsYWdbXCJOb3J3YXlcIl0gPSBcIm5vXCI7XG4gICAgRmxhZ1tcIk5lcGFsXCJdID0gXCJucFwiO1xuICAgIEZsYWdbXCJOYXVydVwiXSA9IFwibnJcIjtcbiAgICBGbGFnW1wiTmV3WmVhbGFuZFwiXSA9IFwibnpcIjtcbiAgICBGbGFnW1wiT21hblwiXSA9IFwib21cIjtcbiAgICBGbGFnW1wiUGFraXN0YW5cIl0gPSBcInBrXCI7XG4gICAgRmxhZ1tcIlBhbmFtYVwiXSA9IFwicGFcIjtcbiAgICBGbGFnW1wiUGVydVwiXSA9IFwicGVcIjtcbiAgICBGbGFnW1wiUGhpbGlwcGluZXNcIl0gPSBcInBoXCI7XG4gICAgRmxhZ1tcIlBhbGF1XCJdID0gXCJwd1wiO1xuICAgIEZsYWdbXCJQYXB1YU5ld0d1aW5lYVwiXSA9IFwicGdcIjtcbiAgICBGbGFnW1wiUG9sYW5kXCJdID0gXCJwbFwiO1xuICAgIEZsYWdbXCJGcmVuY2hQb2x5bmVzaWFcIl0gPSBcInBmXCI7XG4gICAgRmxhZ1tcIk5vcnRoS29yZWFcIl0gPSBcImtwXCI7XG4gICAgRmxhZ1tcIlBvcnR1Z2FsXCJdID0gXCJwdFwiO1xuICAgIEZsYWdbXCJQYXJhZ3VheVwiXSA9IFwicHlcIjtcbiAgICBGbGFnW1wiUWF0YXJcIl0gPSBcInFhXCI7XG4gICAgRmxhZ1tcIlJvbWFuaWFcIl0gPSBcInJvXCI7XG4gICAgRmxhZ1tcIlJ1c3NpYVwiXSA9IFwicnVcIjtcbiAgICBGbGFnW1wiUndhbmRhXCJdID0gXCJyd1wiO1xuICAgIEZsYWdbXCJTYXVkaUFyYWJpYVwiXSA9IFwic2FcIjtcbiAgICBGbGFnW1wiU3VkYW5cIl0gPSBcInNkXCI7XG4gICAgRmxhZ1tcIlNlbmVnYWxcIl0gPSBcInNuXCI7XG4gICAgRmxhZ1tcIlNpbmdhcG9yZVwiXSA9IFwic2dcIjtcbiAgICBGbGFnW1wiU29sb21vbklzbGFuZHNcIl0gPSBcInNiXCI7XG4gICAgRmxhZ1tcIlNpZXJyYUxlb25lXCJdID0gXCJzbFwiO1xuICAgIEZsYWdbXCJFbFNhbHZhZG9yXCJdID0gXCJzdlwiO1xuICAgIEZsYWdbXCJTYW5NYXJpbm9cIl0gPSBcInNtXCI7XG4gICAgRmxhZ1tcIlNvbWFsaWFcIl0gPSBcInNvXCI7XG4gICAgRmxhZ1tcIlNlcmJpYVwiXSA9IFwicnNcIjtcbiAgICBGbGFnW1wiU291dGhTdWRhblwiXSA9IFwic3NcIjtcbiAgICBGbGFnW1wiU2FvVG9tZUFuZFByaW5jaXBlXCJdID0gXCJzdFwiO1xuICAgIEZsYWdbXCJTdXJpbmFtZVwiXSA9IFwic3JcIjtcbiAgICBGbGFnW1wiU2xvdmFraWFcIl0gPSBcInNrXCI7XG4gICAgRmxhZ1tcIlNsb3ZlbmlhXCJdID0gXCJzaVwiO1xuICAgIEZsYWdbXCJTd2VkZW5cIl0gPSBcInNlXCI7XG4gICAgRmxhZ1tcIkVzd2F0aW5pXCJdID0gXCJzelwiO1xuICAgIEZsYWdbXCJTZXljaGVsbGVzXCJdID0gXCJzY1wiO1xuICAgIEZsYWdbXCJTeXJpYVwiXSA9IFwic3lcIjtcbiAgICBGbGFnW1wiQ2hhZFwiXSA9IFwidGRcIjtcbiAgICBGbGFnW1wiVG9nb1wiXSA9IFwidGdcIjtcbiAgICBGbGFnW1wiVGhhaWxhbmRcIl0gPSBcInRoXCI7XG4gICAgRmxhZ1tcIlRhamlraXN0YW5cIl0gPSBcInRqXCI7XG4gICAgRmxhZ1tcIlR1cmttZW5pc3RhblwiXSA9IFwidG1cIjtcbiAgICBGbGFnW1wiVGltb3JMZXN0ZVwiXSA9IFwidGxcIjtcbiAgICBGbGFnW1wiVG9uZ2FcIl0gPSBcInRvXCI7XG4gICAgRmxhZ1tcIlRyaW5pZGFkQW5kVG9iYWdvXCJdID0gXCJ0dFwiO1xuICAgIEZsYWdbXCJUdW5pc2lhXCJdID0gXCJ0blwiO1xuICAgIEZsYWdbXCJUdXJrZXlcIl0gPSBcInRyXCI7XG4gICAgRmxhZ1tcIlR1dmFsdVwiXSA9IFwidHZcIjtcbiAgICBGbGFnW1wiVGFuemFuaWFcIl0gPSBcInR6XCI7XG4gICAgRmxhZ1tcIlVnYW5kYVwiXSA9IFwidWdcIjtcbiAgICBGbGFnW1wiVWtyYWluZVwiXSA9IFwidWFcIjtcbiAgICBGbGFnW1wiVXJ1Z3VheVwiXSA9IFwidXlcIjtcbiAgICBGbGFnW1wiVW5pdGVkU3RhdGVzXCJdID0gXCJ1c1wiO1xuICAgIEZsYWdbXCJVemJla2lzdGFuXCJdID0gXCJ1elwiO1xuICAgIEZsYWdbXCJWYXRpY2FuQ2l0eVwiXSA9IFwidmFcIjtcbiAgICBGbGFnW1wiU2FpbnRWaW5jZW50QW5kVGhlR3JlbmFkaW5lc1wiXSA9IFwidmNcIjtcbiAgICBGbGFnW1wiVmVuZXp1ZWxhXCJdID0gXCJ2ZVwiO1xuICAgIEZsYWdbXCJWaWV0bmFtXCJdID0gXCJ2blwiO1xuICAgIEZsYWdbXCJWYW51YXR1XCJdID0gXCJ2dVwiO1xuICAgIEZsYWdbXCJTYW1vYVwiXSA9IFwid3NcIjtcbiAgICBGbGFnW1wiWWVtZW5cIl0gPSBcInllXCI7XG4gICAgRmxhZ1tcIlNvdXRoQWZyaWNhXCJdID0gXCJ6YVwiO1xuICAgIEZsYWdbXCJaYW1iaWFcIl0gPSBcInptXCI7XG4gICAgRmxhZ1tcIlppbWJhYndlXCJdID0gXCJ6d1wiO1xufSkoRmxhZyB8fCAoRmxhZyA9IHt9KSk7XG5cbnZhciBUaGVtZTtcbihmdW5jdGlvbiAoVGhlbWUpIHtcbiAgICBUaGVtZVtcIkxpZ2h0XCJdID0gXCJsaWdodFwiO1xuICAgIFRoZW1lW1wiRGFya1wiXSA9IFwiZGFya1wiO1xufSkoVGhlbWUgfHwgKFRoZW1lID0ge30pKTtcblxudmFyIFRpbWV6b25lO1xuKGZ1bmN0aW9uIChUaW1lem9uZSkge1xuICAgIFRpbWV6b25lW1wiQWZyaWNhQWJpZGphblwiXSA9IFwiYWZyaWNhL2FiaWRqYW5cIjtcbiAgICBUaW1lem9uZVtcIkFmcmljYUFjY3JhXCJdID0gXCJhZnJpY2EvYWNjcmFcIjtcbiAgICBUaW1lem9uZVtcIkFmcmljYUFkZGlzQWJhYmFcIl0gPSBcImFmcmljYS9hZGRpc19hYmFiYVwiO1xuICAgIFRpbWV6b25lW1wiQWZyaWNhQWxnaWVyc1wiXSA9IFwiYWZyaWNhL2FsZ2llcnNcIjtcbiAgICBUaW1lem9uZVtcIkFmcmljYUFzbWFyYVwiXSA9IFwiYWZyaWNhL2FzbWFyYVwiO1xuICAgIFRpbWV6b25lW1wiQWZyaWNhQmFtYWtvXCJdID0gXCJhZnJpY2EvYmFtYWtvXCI7XG4gICAgVGltZXpvbmVbXCJBZnJpY2FCYW5ndWlcIl0gPSBcImFmcmljYS9iYW5ndWlcIjtcbiAgICBUaW1lem9uZVtcIkFmcmljYUJhbmp1bFwiXSA9IFwiYWZyaWNhL2Jhbmp1bFwiO1xuICAgIFRpbWV6b25lW1wiQWZyaWNhQmlzc2F1XCJdID0gXCJhZnJpY2EvYmlzc2F1XCI7XG4gICAgVGltZXpvbmVbXCJBZnJpY2FCbGFudHlyZVwiXSA9IFwiYWZyaWNhL2JsYW50eXJlXCI7XG4gICAgVGltZXpvbmVbXCJBZnJpY2FCcmF6emF2aWxsZVwiXSA9IFwiYWZyaWNhL2JyYXp6YXZpbGxlXCI7XG4gICAgVGltZXpvbmVbXCJBZnJpY2FCdWp1bWJ1cmFcIl0gPSBcImFmcmljYS9idWp1bWJ1cmFcIjtcbiAgICBUaW1lem9uZVtcIkFmcmljYUNhaXJvXCJdID0gXCJhZnJpY2EvY2Fpcm9cIjtcbiAgICBUaW1lem9uZVtcIkFmcmljYUNhc2FibGFuY2FcIl0gPSBcImFmcmljYS9jYXNhYmxhbmNhXCI7XG4gICAgVGltZXpvbmVbXCJBZnJpY2FDZXV0YVwiXSA9IFwiYWZyaWNhL2NldXRhXCI7XG4gICAgVGltZXpvbmVbXCJBZnJpY2FDb25ha3J5XCJdID0gXCJhZnJpY2EvY29uYWtyeVwiO1xuICAgIFRpbWV6b25lW1wiQWZyaWNhRGFrYXJcIl0gPSBcImFmcmljYS9kYWthclwiO1xuICAgIFRpbWV6b25lW1wiQWZyaWNhRGFyRXNTYWxhYW1cIl0gPSBcImFmcmljYS9kYXJfZXNfc2FsYWFtXCI7XG4gICAgVGltZXpvbmVbXCJBZnJpY2FEamlib3V0aVwiXSA9IFwiYWZyaWNhL2RqaWJvdXRpXCI7XG4gICAgVGltZXpvbmVbXCJBZnJpY2FEb3VhbGFcIl0gPSBcImFmcmljYS9kb3VhbGFcIjtcbiAgICBUaW1lem9uZVtcIkFmcmljYUVsQWFpdW5cIl0gPSBcImFmcmljYS9lbF9hYWl1blwiO1xuICAgIFRpbWV6b25lW1wiQWZyaWNhRnJlZXRvd25cIl0gPSBcImFmcmljYS9mcmVldG93blwiO1xuICAgIFRpbWV6b25lW1wiQWZyaWNhR2Fib3JvbmVcIl0gPSBcImFmcmljYS9nYWJvcm9uZVwiO1xuICAgIFRpbWV6b25lW1wiQWZyaWNhSGFyYXJlXCJdID0gXCJhZnJpY2EvaGFyYXJlXCI7XG4gICAgVGltZXpvbmVbXCJBZnJpY2FKb2hhbm5lc2J1cmdcIl0gPSBcImFmcmljYS9qb2hhbm5lc2J1cmdcIjtcbiAgICBUaW1lem9uZVtcIkFmcmljYUp1YmFcIl0gPSBcImFmcmljYS9qdWJhXCI7XG4gICAgVGltZXpvbmVbXCJBZnJpY2FLYW1wYWxhXCJdID0gXCJhZnJpY2Eva2FtcGFsYVwiO1xuICAgIFRpbWV6b25lW1wiQWZyaWNhS2hhcnRvdW1cIl0gPSBcImFmcmljYS9raGFydG91bVwiO1xuICAgIFRpbWV6b25lW1wiQWZyaWNhS2lnYWxpXCJdID0gXCJhZnJpY2Eva2lnYWxpXCI7XG4gICAgVGltZXpvbmVbXCJBZnJpY2FLaW5zaGFzYVwiXSA9IFwiYWZyaWNhL2tpbnNoYXNhXCI7XG4gICAgVGltZXpvbmVbXCJBZnJpY2FMYWdvc1wiXSA9IFwiYWZyaWNhL2xhZ29zXCI7XG4gICAgVGltZXpvbmVbXCJBZnJpY2FMaWJyZXZpbGxlXCJdID0gXCJhZnJpY2EvbGlicmV2aWxsZVwiO1xuICAgIFRpbWV6b25lW1wiQWZyaWNhTG9tZVwiXSA9IFwiYWZyaWNhL2xvbWVcIjtcbiAgICBUaW1lem9uZVtcIkFmcmljYUx1YW5kYVwiXSA9IFwiYWZyaWNhL2x1YW5kYVwiO1xuICAgIFRpbWV6b25lW1wiQWZyaWNhTHVidW1iYXNoaVwiXSA9IFwiYWZyaWNhL2x1YnVtYmFzaGlcIjtcbiAgICBUaW1lem9uZVtcIkFmcmljYUx1c2FrYVwiXSA9IFwiYWZyaWNhL2x1c2FrYVwiO1xuICAgIFRpbWV6b25lW1wiQWZyaWNhTWFsYWJvXCJdID0gXCJhZnJpY2EvbWFsYWJvXCI7XG4gICAgVGltZXpvbmVbXCJBZnJpY2FNYXB1dG9cIl0gPSBcImFmcmljYS9tYXB1dG9cIjtcbiAgICBUaW1lem9uZVtcIkFmcmljYU1hc2VydVwiXSA9IFwiYWZyaWNhL21hc2VydVwiO1xuICAgIFRpbWV6b25lW1wiQWZyaWNhTWJhYmFuZVwiXSA9IFwiYWZyaWNhL21iYWJhbmVcIjtcbiAgICBUaW1lem9uZVtcIkFmcmljYU1vZ2FkaXNodVwiXSA9IFwiYWZyaWNhL21vZ2FkaXNodVwiO1xuICAgIFRpbWV6b25lW1wiQWZyaWNhTW9ucm92aWFcIl0gPSBcImFmcmljYS9tb25yb3ZpYVwiO1xuICAgIFRpbWV6b25lW1wiQWZyaWNhTmFpcm9iaVwiXSA9IFwiYWZyaWNhL25haXJvYmlcIjtcbiAgICBUaW1lem9uZVtcIkFmcmljYU5kamFtZW5hXCJdID0gXCJhZnJpY2EvbmRqYW1lbmFcIjtcbiAgICBUaW1lem9uZVtcIkFmcmljYU5pYW1leVwiXSA9IFwiYWZyaWNhL25pYW1leVwiO1xuICAgIFRpbWV6b25lW1wiQWZyaWNhTm91YWtjaG90dFwiXSA9IFwiYWZyaWNhL25vdWFrY2hvdHRcIjtcbiAgICBUaW1lem9uZVtcIkFmcmljYU91YWdhZG91Z291XCJdID0gXCJhZnJpY2Evb3VhZ2Fkb3Vnb3VcIjtcbiAgICBUaW1lem9uZVtcIkFmcmljYVBvcnRvbm92b1wiXSA9IFwiYWZyaWNhL3BvcnRvLW5vdm9cIjtcbiAgICBUaW1lem9uZVtcIkFmcmljYVNhb1RvbWVcIl0gPSBcImFmcmljYS9zYW9fdG9tZVwiO1xuICAgIFRpbWV6b25lW1wiQWZyaWNhVHJpcG9saVwiXSA9IFwiYWZyaWNhL3RyaXBvbGlcIjtcbiAgICBUaW1lem9uZVtcIkFmcmljYVR1bmlzXCJdID0gXCJhZnJpY2EvdHVuaXNcIjtcbiAgICBUaW1lem9uZVtcIkFmcmljYVdpbmRob2VrXCJdID0gXCJhZnJpY2Evd2luZGhvZWtcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FBZGFrXCJdID0gXCJhbWVyaWNhL2FkYWtcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FBbmNob3JhZ2VcIl0gPSBcImFtZXJpY2EvYW5jaG9yYWdlXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhQW5ndWlsbGFcIl0gPSBcImFtZXJpY2EvYW5ndWlsbGFcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FBbnRpZ3VhXCJdID0gXCJhbWVyaWNhL2FudGlndWFcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FBcmFndWFpbmFcIl0gPSBcImFtZXJpY2EvYXJhZ3VhaW5hXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhQXJnZW50aW5hQnVlbm9zQWlyZXNcIl0gPSBcImFtZXJpY2EvYXJnZW50aW5hL2J1ZW5vc19haXJlc1wiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUFyZ2VudGluYUNhdGFtYXJjYVwiXSA9IFwiYW1lcmljYS9hcmdlbnRpbmEvY2F0YW1hcmNhXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhQXJnZW50aW5hQ29yZG9iYVwiXSA9IFwiYW1lcmljYS9hcmdlbnRpbmEvY29yZG9iYVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUFyZ2VudGluYUp1anV5XCJdID0gXCJhbWVyaWNhL2FyZ2VudGluYS9qdWp1eVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUFyZ2VudGluYUxhUmlvamFcIl0gPSBcImFtZXJpY2EvYXJnZW50aW5hL2xhX3Jpb2phXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhQXJnZW50aW5hTWVuZG96YVwiXSA9IFwiYW1lcmljYS9hcmdlbnRpbmEvbWVuZG96YVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUFyZ2VudGluYVJpb0dhbGxlZ29zXCJdID0gXCJhbWVyaWNhL2FyZ2VudGluYS9yaW9fZ2FsbGVnb3NcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FBcmdlbnRpbmFTYWx0YVwiXSA9IFwiYW1lcmljYS9hcmdlbnRpbmEvc2FsdGFcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FBcmdlbnRpbmFTYW5KdWFuXCJdID0gXCJhbWVyaWNhL2FyZ2VudGluYS9zYW5fanVhblwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUFyZ2VudGluYVNhbkx1aXNcIl0gPSBcImFtZXJpY2EvYXJnZW50aW5hL3Nhbl9sdWlzXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhQXJnZW50aW5hVHVjdW1hblwiXSA9IFwiYW1lcmljYS9hcmdlbnRpbmEvdHVjdW1hblwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUFyZ2VudGluYVVzaHVhaWFcIl0gPSBcImFtZXJpY2EvYXJnZW50aW5hL3VzaHVhaWFcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FBcnViYVwiXSA9IFwiYW1lcmljYS9hcnViYVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUFzdW5jaW9uXCJdID0gXCJhbWVyaWNhL2FzdW5jaW9uXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhQXRpa29rYW5cIl0gPSBcImFtZXJpY2EvYXRpa29rYW5cIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FCYWhpYVwiXSA9IFwiYW1lcmljYS9iYWhpYVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUJhaGlhQmFuZGVyYXNcIl0gPSBcImFtZXJpY2EvYmFoaWFfYmFuZGVyYXNcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FCYXJiYWRvc1wiXSA9IFwiYW1lcmljYS9iYXJiYWRvc1wiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUJlbGVtXCJdID0gXCJhbWVyaWNhL2JlbGVtXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhQmVsaXplXCJdID0gXCJhbWVyaWNhL2JlbGl6ZVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUJsYW5jc2FibG9uXCJdID0gXCJhbWVyaWNhL2JsYW5jLXNhYmxvblwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUJvYVZpc3RhXCJdID0gXCJhbWVyaWNhL2JvYV92aXN0YVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUJvZ290YVwiXSA9IFwiYW1lcmljYS9ib2dvdGFcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FCb2lzZVwiXSA9IFwiYW1lcmljYS9ib2lzZVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUNhbWJyaWRnZUJheVwiXSA9IFwiYW1lcmljYS9jYW1icmlkZ2VfYmF5XCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhQ2FtcG9HcmFuZGVcIl0gPSBcImFtZXJpY2EvY2FtcG9fZ3JhbmRlXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhQ2FuY3VuXCJdID0gXCJhbWVyaWNhL2NhbmN1blwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUNhcmFjYXNcIl0gPSBcImFtZXJpY2EvY2FyYWNhc1wiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUNheWVubmVcIl0gPSBcImFtZXJpY2EvY2F5ZW5uZVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUNheW1hblwiXSA9IFwiYW1lcmljYS9jYXltYW5cIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FDaGljYWdvXCJdID0gXCJhbWVyaWNhL2NoaWNhZ29cIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FDaGlodWFodWFcIl0gPSBcImFtZXJpY2EvY2hpaHVhaHVhXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhQ2l1ZGFkSnVhcmV6XCJdID0gXCJhbWVyaWNhL2NpdWRhZF9qdWFyZXpcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FDb3N0YVJpY2FcIl0gPSBcImFtZXJpY2EvY29zdGFfcmljYVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUNveWhhaXF1ZVwiXSA9IFwiYW1lcmljYS9jb3loYWlxdWVcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FDcmVzdG9uXCJdID0gXCJhbWVyaWNhL2NyZXN0b25cIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FDdWlhYmFcIl0gPSBcImFtZXJpY2EvY3VpYWJhXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhQ3VyYWNhb1wiXSA9IFwiYW1lcmljYS9jdXJhY2FvXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhRGFubWFya3NoYXZuXCJdID0gXCJhbWVyaWNhL2Rhbm1hcmtzaGF2blwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYURhd3NvblwiXSA9IFwiYW1lcmljYS9kYXdzb25cIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FEYXdzb25DcmVla1wiXSA9IFwiYW1lcmljYS9kYXdzb25fY3JlZWtcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FEZW52ZXJcIl0gPSBcImFtZXJpY2EvZGVudmVyXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhRGV0cm9pdFwiXSA9IFwiYW1lcmljYS9kZXRyb2l0XCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhRG9taW5pY2FcIl0gPSBcImFtZXJpY2EvZG9taW5pY2FcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FFZG1vbnRvblwiXSA9IFwiYW1lcmljYS9lZG1vbnRvblwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUVpcnVuZXBlXCJdID0gXCJhbWVyaWNhL2VpcnVuZXBlXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhRWxTYWx2YWRvclwiXSA9IFwiYW1lcmljYS9lbF9zYWx2YWRvclwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUZvcnROZWxzb25cIl0gPSBcImFtZXJpY2EvZm9ydF9uZWxzb25cIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FGb3J0YWxlemFcIl0gPSBcImFtZXJpY2EvZm9ydGFsZXphXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhR2xhY2VCYXlcIl0gPSBcImFtZXJpY2EvZ2xhY2VfYmF5XCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhR29vc2VCYXlcIl0gPSBcImFtZXJpY2EvZ29vc2VfYmF5XCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhR3JhbmRUdXJrXCJdID0gXCJhbWVyaWNhL2dyYW5kX3R1cmtcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FHcmVuYWRhXCJdID0gXCJhbWVyaWNhL2dyZW5hZGFcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FHdWFkZWxvdXBlXCJdID0gXCJhbWVyaWNhL2d1YWRlbG91cGVcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FHdWF0ZW1hbGFcIl0gPSBcImFtZXJpY2EvZ3VhdGVtYWxhXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhR3VheWFxdWlsXCJdID0gXCJhbWVyaWNhL2d1YXlhcXVpbFwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUd1eWFuYVwiXSA9IFwiYW1lcmljYS9ndXlhbmFcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FIYWxpZmF4XCJdID0gXCJhbWVyaWNhL2hhbGlmYXhcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FIYXZhbmFcIl0gPSBcImFtZXJpY2EvaGF2YW5hXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhSGVybW9zaWxsb1wiXSA9IFwiYW1lcmljYS9oZXJtb3NpbGxvXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhSW5kaWFuYUluZGlhbmFwb2xpc1wiXSA9IFwiYW1lcmljYS9pbmRpYW5hL2luZGlhbmFwb2xpc1wiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUluZGlhbmFLbm94XCJdID0gXCJhbWVyaWNhL2luZGlhbmEva25veFwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUluZGlhbmFNYXJlbmdvXCJdID0gXCJhbWVyaWNhL2luZGlhbmEvbWFyZW5nb1wiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUluZGlhbmFQZXRlcnNidXJnXCJdID0gXCJhbWVyaWNhL2luZGlhbmEvcGV0ZXJzYnVyZ1wiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUluZGlhbmFUZWxsQ2l0eVwiXSA9IFwiYW1lcmljYS9pbmRpYW5hL3RlbGxfY2l0eVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUluZGlhbmFWZXZheVwiXSA9IFwiYW1lcmljYS9pbmRpYW5hL3ZldmF5XCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhSW5kaWFuYVZpbmNlbm5lc1wiXSA9IFwiYW1lcmljYS9pbmRpYW5hL3ZpbmNlbm5lc1wiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUluZGlhbmFXaW5hbWFjXCJdID0gXCJhbWVyaWNhL2luZGlhbmEvd2luYW1hY1wiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUludXZpa1wiXSA9IFwiYW1lcmljYS9pbnV2aWtcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FJcWFsdWl0XCJdID0gXCJhbWVyaWNhL2lxYWx1aXRcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FKYW1haWNhXCJdID0gXCJhbWVyaWNhL2phbWFpY2FcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FKdW5lYXVcIl0gPSBcImFtZXJpY2EvanVuZWF1XCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhS2VudHVja3lMb3Vpc3ZpbGxlXCJdID0gXCJhbWVyaWNhL2tlbnR1Y2t5L2xvdWlzdmlsbGVcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FLZW50dWNreU1vbnRpY2VsbG9cIl0gPSBcImFtZXJpY2Eva2VudHVja3kvbW9udGljZWxsb1wiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUtyYWxlbmRpamtcIl0gPSBcImFtZXJpY2Eva3JhbGVuZGlqa1wiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUxhUGF6XCJdID0gXCJhbWVyaWNhL2xhX3BhelwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUxpbWFcIl0gPSBcImFtZXJpY2EvbGltYVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYUxvc0FuZ2VsZXNcIl0gPSBcImFtZXJpY2EvbG9zX2FuZ2VsZXNcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FMb3dlclByaW5jZXNcIl0gPSBcImFtZXJpY2EvbG93ZXJfcHJpbmNlc1wiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYU1hY2Vpb1wiXSA9IFwiYW1lcmljYS9tYWNlaW9cIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FNYW5hZ3VhXCJdID0gXCJhbWVyaWNhL21hbmFndWFcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FNYW5hdXNcIl0gPSBcImFtZXJpY2EvbWFuYXVzXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhTWFyaWdvdFwiXSA9IFwiYW1lcmljYS9tYXJpZ290XCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhTWFydGluaXF1ZVwiXSA9IFwiYW1lcmljYS9tYXJ0aW5pcXVlXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhTWF0YW1vcm9zXCJdID0gXCJhbWVyaWNhL21hdGFtb3Jvc1wiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYU1hemF0bGFuXCJdID0gXCJhbWVyaWNhL21hemF0bGFuXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhTWVub21pbmVlXCJdID0gXCJhbWVyaWNhL21lbm9taW5lZVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYU1lcmlkYVwiXSA9IFwiYW1lcmljYS9tZXJpZGFcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FNZXRsYWthdGxhXCJdID0gXCJhbWVyaWNhL21ldGxha2F0bGFcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FNZXhpY29DaXR5XCJdID0gXCJhbWVyaWNhL21leGljb19jaXR5XCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhTWlxdWVsb25cIl0gPSBcImFtZXJpY2EvbWlxdWVsb25cIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FNb25jdG9uXCJdID0gXCJhbWVyaWNhL21vbmN0b25cIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FNb250ZXJyZXlcIl0gPSBcImFtZXJpY2EvbW9udGVycmV5XCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhTW9udGV2aWRlb1wiXSA9IFwiYW1lcmljYS9tb250ZXZpZGVvXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhTW9udHNlcnJhdFwiXSA9IFwiYW1lcmljYS9tb250c2VycmF0XCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhTmFzc2F1XCJdID0gXCJhbWVyaWNhL25hc3NhdVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYU5ld1lvcmtcIl0gPSBcImFtZXJpY2EvbmV3X3lvcmtcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FOb21lXCJdID0gXCJhbWVyaWNhL25vbWVcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FOb3JvbmhhXCJdID0gXCJhbWVyaWNhL25vcm9uaGFcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FOb3J0aERha290YUJldWxhaFwiXSA9IFwiYW1lcmljYS9ub3J0aF9kYWtvdGEvYmV1bGFoXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhTm9ydGhEYWtvdGFDZW50ZXJcIl0gPSBcImFtZXJpY2Evbm9ydGhfZGFrb3RhL2NlbnRlclwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYU5vcnRoRGFrb3RhTmV3U2FsZW1cIl0gPSBcImFtZXJpY2Evbm9ydGhfZGFrb3RhL25ld19zYWxlbVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYU51dWtcIl0gPSBcImFtZXJpY2EvbnV1a1wiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYU9qaW5hZ2FcIl0gPSBcImFtZXJpY2Evb2ppbmFnYVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYVBhbmFtYVwiXSA9IFwiYW1lcmljYS9wYW5hbWFcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FQYXJhbWFyaWJvXCJdID0gXCJhbWVyaWNhL3BhcmFtYXJpYm9cIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FQaG9lbml4XCJdID0gXCJhbWVyaWNhL3Bob2VuaXhcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FQb3J0YXVwcmluY2VcIl0gPSBcImFtZXJpY2EvcG9ydC1hdS1wcmluY2VcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FQb3J0T2ZTcGFpblwiXSA9IFwiYW1lcmljYS9wb3J0X29mX3NwYWluXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhUG9ydG9WZWxob1wiXSA9IFwiYW1lcmljYS9wb3J0b192ZWxob1wiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYVB1ZXJ0b1JpY29cIl0gPSBcImFtZXJpY2EvcHVlcnRvX3JpY29cIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FQdW50YUFyZW5hc1wiXSA9IFwiYW1lcmljYS9wdW50YV9hcmVuYXNcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FSYW5raW5JbmxldFwiXSA9IFwiYW1lcmljYS9yYW5raW5faW5sZXRcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FSZWNpZmVcIl0gPSBcImFtZXJpY2EvcmVjaWZlXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhUmVnaW5hXCJdID0gXCJhbWVyaWNhL3JlZ2luYVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYVJlc29sdXRlXCJdID0gXCJhbWVyaWNhL3Jlc29sdXRlXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhUmlvQnJhbmNvXCJdID0gXCJhbWVyaWNhL3Jpb19icmFuY29cIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FTYW50YXJlbVwiXSA9IFwiYW1lcmljYS9zYW50YXJlbVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYVNhbnRpYWdvXCJdID0gXCJhbWVyaWNhL3NhbnRpYWdvXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhU2FudG9Eb21pbmdvXCJdID0gXCJhbWVyaWNhL3NhbnRvX2RvbWluZ29cIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FTYW9QYXVsb1wiXSA9IFwiYW1lcmljYS9zYW9fcGF1bG9cIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FTY29yZXNieXN1bmRcIl0gPSBcImFtZXJpY2Evc2NvcmVzYnlzdW5kXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhU2l0a2FcIl0gPSBcImFtZXJpY2Evc2l0a2FcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FTdEJhcnRoZWxlbXlcIl0gPSBcImFtZXJpY2Evc3RfYmFydGhlbGVteVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYVN0Sm9obnNcIl0gPSBcImFtZXJpY2Evc3Rfam9obnNcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FTdEtpdHRzXCJdID0gXCJhbWVyaWNhL3N0X2tpdHRzXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhU3RMdWNpYVwiXSA9IFwiYW1lcmljYS9zdF9sdWNpYVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYVN0VGhvbWFzXCJdID0gXCJhbWVyaWNhL3N0X3Rob21hc1wiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYVN0VmluY2VudFwiXSA9IFwiYW1lcmljYS9zdF92aW5jZW50XCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhU3dpZnRDdXJyZW50XCJdID0gXCJhbWVyaWNhL3N3aWZ0X2N1cnJlbnRcIjtcbiAgICBUaW1lem9uZVtcIkFtZXJpY2FUZWd1Y2lnYWxwYVwiXSA9IFwiYW1lcmljYS90ZWd1Y2lnYWxwYVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYVRodWxlXCJdID0gXCJhbWVyaWNhL3RodWxlXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhVGlqdWFuYVwiXSA9IFwiYW1lcmljYS90aWp1YW5hXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhVG9yb250b1wiXSA9IFwiYW1lcmljYS90b3JvbnRvXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhVG9ydG9sYVwiXSA9IFwiYW1lcmljYS90b3J0b2xhXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhVmFuY291dmVyXCJdID0gXCJhbWVyaWNhL3ZhbmNvdXZlclwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYVdoaXRlaG9yc2VcIl0gPSBcImFtZXJpY2Evd2hpdGVob3JzZVwiO1xuICAgIFRpbWV6b25lW1wiQW1lcmljYVdpbm5pcGVnXCJdID0gXCJhbWVyaWNhL3dpbm5pcGVnXCI7XG4gICAgVGltZXpvbmVbXCJBbWVyaWNhWWFrdXRhdFwiXSA9IFwiYW1lcmljYS95YWt1dGF0XCI7XG4gICAgVGltZXpvbmVbXCJBbnRhcmN0aWNhQ2FzZXlcIl0gPSBcImFudGFyY3RpY2EvY2FzZXlcIjtcbiAgICBUaW1lem9uZVtcIkFudGFyY3RpY2FEYXZpc1wiXSA9IFwiYW50YXJjdGljYS9kYXZpc1wiO1xuICAgIFRpbWV6b25lW1wiQW50YXJjdGljYUR1bW9udGR1cnZpbGxlXCJdID0gXCJhbnRhcmN0aWNhL2R1bW9udGR1cnZpbGxlXCI7XG4gICAgVGltZXpvbmVbXCJBbnRhcmN0aWNhTWFjcXVhcmllXCJdID0gXCJhbnRhcmN0aWNhL21hY3F1YXJpZVwiO1xuICAgIFRpbWV6b25lW1wiQW50YXJjdGljYU1hd3NvblwiXSA9IFwiYW50YXJjdGljYS9tYXdzb25cIjtcbiAgICBUaW1lem9uZVtcIkFudGFyY3RpY2FNY211cmRvXCJdID0gXCJhbnRhcmN0aWNhL21jbXVyZG9cIjtcbiAgICBUaW1lem9uZVtcIkFudGFyY3RpY2FQYWxtZXJcIl0gPSBcImFudGFyY3RpY2EvcGFsbWVyXCI7XG4gICAgVGltZXpvbmVbXCJBbnRhcmN0aWNhUm90aGVyYVwiXSA9IFwiYW50YXJjdGljYS9yb3RoZXJhXCI7XG4gICAgVGltZXpvbmVbXCJBbnRhcmN0aWNhU3lvd2FcIl0gPSBcImFudGFyY3RpY2Evc3lvd2FcIjtcbiAgICBUaW1lem9uZVtcIkFudGFyY3RpY2FUcm9sbFwiXSA9IFwiYW50YXJjdGljYS90cm9sbFwiO1xuICAgIFRpbWV6b25lW1wiQW50YXJjdGljYVZvc3Rva1wiXSA9IFwiYW50YXJjdGljYS92b3N0b2tcIjtcbiAgICBUaW1lem9uZVtcIkFyY3RpY0xvbmd5ZWFyYnllblwiXSA9IFwiYXJjdGljL2xvbmd5ZWFyYnllblwiO1xuICAgIFRpbWV6b25lW1wiQXNpYUFkZW5cIl0gPSBcImFzaWEvYWRlblwiO1xuICAgIFRpbWV6b25lW1wiQXNpYUFsbWF0eVwiXSA9IFwiYXNpYS9hbG1hdHlcIjtcbiAgICBUaW1lem9uZVtcIkFzaWFBbW1hblwiXSA9IFwiYXNpYS9hbW1hblwiO1xuICAgIFRpbWV6b25lW1wiQXNpYUFuYWR5clwiXSA9IFwiYXNpYS9hbmFkeXJcIjtcbiAgICBUaW1lem9uZVtcIkFzaWFBcXRhdVwiXSA9IFwiYXNpYS9hcXRhdVwiO1xuICAgIFRpbWV6b25lW1wiQXNpYUFxdG9iZVwiXSA9IFwiYXNpYS9hcXRvYmVcIjtcbiAgICBUaW1lem9uZVtcIkFzaWFBc2hnYWJhdFwiXSA9IFwiYXNpYS9hc2hnYWJhdFwiO1xuICAgIFRpbWV6b25lW1wiQXNpYUF0eXJhdVwiXSA9IFwiYXNpYS9hdHlyYXVcIjtcbiAgICBUaW1lem9uZVtcIkFzaWFCYWdoZGFkXCJdID0gXCJhc2lhL2JhZ2hkYWRcIjtcbiAgICBUaW1lem9uZVtcIkFzaWFCYWhyYWluXCJdID0gXCJhc2lhL2JhaHJhaW5cIjtcbiAgICBUaW1lem9uZVtcIkFzaWFCYWt1XCJdID0gXCJhc2lhL2Jha3VcIjtcbiAgICBUaW1lem9uZVtcIkFzaWFCYW5na29rXCJdID0gXCJhc2lhL2Jhbmdrb2tcIjtcbiAgICBUaW1lem9uZVtcIkFzaWFCYXJuYXVsXCJdID0gXCJhc2lhL2Jhcm5hdWxcIjtcbiAgICBUaW1lem9uZVtcIkFzaWFCZWlydXRcIl0gPSBcImFzaWEvYmVpcnV0XCI7XG4gICAgVGltZXpvbmVbXCJBc2lhQmlzaGtla1wiXSA9IFwiYXNpYS9iaXNoa2VrXCI7XG4gICAgVGltZXpvbmVbXCJBc2lhQnJ1bmVpXCJdID0gXCJhc2lhL2JydW5laVwiO1xuICAgIFRpbWV6b25lW1wiQXNpYUNoaXRhXCJdID0gXCJhc2lhL2NoaXRhXCI7XG4gICAgVGltZXpvbmVbXCJBc2lhQ29sb21ib1wiXSA9IFwiYXNpYS9jb2xvbWJvXCI7XG4gICAgVGltZXpvbmVbXCJBc2lhRGFtYXNjdXNcIl0gPSBcImFzaWEvZGFtYXNjdXNcIjtcbiAgICBUaW1lem9uZVtcIkFzaWFEaGFrYVwiXSA9IFwiYXNpYS9kaGFrYVwiO1xuICAgIFRpbWV6b25lW1wiQXNpYURpbGlcIl0gPSBcImFzaWEvZGlsaVwiO1xuICAgIFRpbWV6b25lW1wiQXNpYUR1YmFpXCJdID0gXCJhc2lhL2R1YmFpXCI7XG4gICAgVGltZXpvbmVbXCJBc2lhRHVzaGFuYmVcIl0gPSBcImFzaWEvZHVzaGFuYmVcIjtcbiAgICBUaW1lem9uZVtcIkFzaWFGYW1hZ3VzdGFcIl0gPSBcImFzaWEvZmFtYWd1c3RhXCI7XG4gICAgVGltZXpvbmVbXCJBc2lhR2F6YVwiXSA9IFwiYXNpYS9nYXphXCI7XG4gICAgVGltZXpvbmVbXCJBc2lhSGVicm9uXCJdID0gXCJhc2lhL2hlYnJvblwiO1xuICAgIFRpbWV6b25lW1wiQXNpYUhvQ2hpTWluaFwiXSA9IFwiYXNpYS9ob19jaGlfbWluaFwiO1xuICAgIFRpbWV6b25lW1wiQXNpYUhvbmdLb25nXCJdID0gXCJhc2lhL2hvbmdfa29uZ1wiO1xuICAgIFRpbWV6b25lW1wiQXNpYUhvdmRcIl0gPSBcImFzaWEvaG92ZFwiO1xuICAgIFRpbWV6b25lW1wiQXNpYUlya3V0c2tcIl0gPSBcImFzaWEvaXJrdXRza1wiO1xuICAgIFRpbWV6b25lW1wiQXNpYUpha2FydGFcIl0gPSBcImFzaWEvamFrYXJ0YVwiO1xuICAgIFRpbWV6b25lW1wiQXNpYUpheWFwdXJhXCJdID0gXCJhc2lhL2pheWFwdXJhXCI7XG4gICAgVGltZXpvbmVbXCJBc2lhSmVydXNhbGVtXCJdID0gXCJhc2lhL2plcnVzYWxlbVwiO1xuICAgIFRpbWV6b25lW1wiQXNpYUthYnVsXCJdID0gXCJhc2lhL2thYnVsXCI7XG4gICAgVGltZXpvbmVbXCJBc2lhS2FtY2hhdGthXCJdID0gXCJhc2lhL2thbWNoYXRrYVwiO1xuICAgIFRpbWV6b25lW1wiQXNpYUthcmFjaGlcIl0gPSBcImFzaWEva2FyYWNoaVwiO1xuICAgIFRpbWV6b25lW1wiQXNpYUthdGhtYW5kdVwiXSA9IFwiYXNpYS9rYXRobWFuZHVcIjtcbiAgICBUaW1lem9uZVtcIkFzaWFLaGFuZHlnYVwiXSA9IFwiYXNpYS9raGFuZHlnYVwiO1xuICAgIFRpbWV6b25lW1wiQXNpYUtvbGthdGFcIl0gPSBcImFzaWEva29sa2F0YVwiO1xuICAgIFRpbWV6b25lW1wiQXNpYUtyYXNub3lhcnNrXCJdID0gXCJhc2lhL2tyYXNub3lhcnNrXCI7XG4gICAgVGltZXpvbmVbXCJBc2lhS3VhbGFMdW1wdXJcIl0gPSBcImFzaWEva3VhbGFfbHVtcHVyXCI7XG4gICAgVGltZXpvbmVbXCJBc2lhS3VjaGluZ1wiXSA9IFwiYXNpYS9rdWNoaW5nXCI7XG4gICAgVGltZXpvbmVbXCJBc2lhS3V3YWl0XCJdID0gXCJhc2lhL2t1d2FpdFwiO1xuICAgIFRpbWV6b25lW1wiQXNpYU1hY2F1XCJdID0gXCJhc2lhL21hY2F1XCI7XG4gICAgVGltZXpvbmVbXCJBc2lhTWFnYWRhblwiXSA9IFwiYXNpYS9tYWdhZGFuXCI7XG4gICAgVGltZXpvbmVbXCJBc2lhTWFrYXNzYXJcIl0gPSBcImFzaWEvbWFrYXNzYXJcIjtcbiAgICBUaW1lem9uZVtcIkFzaWFNYW5pbGFcIl0gPSBcImFzaWEvbWFuaWxhXCI7XG4gICAgVGltZXpvbmVbXCJBc2lhTXVzY2F0XCJdID0gXCJhc2lhL211c2NhdFwiO1xuICAgIFRpbWV6b25lW1wiQXNpYU5pY29zaWFcIl0gPSBcImFzaWEvbmljb3NpYVwiO1xuICAgIFRpbWV6b25lW1wiQXNpYU5vdm9rdXpuZXRza1wiXSA9IFwiYXNpYS9ub3Zva3V6bmV0c2tcIjtcbiAgICBUaW1lem9uZVtcIkFzaWFOb3Zvc2liaXJza1wiXSA9IFwiYXNpYS9ub3Zvc2liaXJza1wiO1xuICAgIFRpbWV6b25lW1wiQXNpYU9tc2tcIl0gPSBcImFzaWEvb21za1wiO1xuICAgIFRpbWV6b25lW1wiQXNpYU9yYWxcIl0gPSBcImFzaWEvb3JhbFwiO1xuICAgIFRpbWV6b25lW1wiQXNpYVBobm9tUGVuaFwiXSA9IFwiYXNpYS9waG5vbV9wZW5oXCI7XG4gICAgVGltZXpvbmVbXCJBc2lhUG9udGlhbmFrXCJdID0gXCJhc2lhL3BvbnRpYW5ha1wiO1xuICAgIFRpbWV6b25lW1wiQXNpYVB5b25neWFuZ1wiXSA9IFwiYXNpYS9weW9uZ3lhbmdcIjtcbiAgICBUaW1lem9uZVtcIkFzaWFRYXRhclwiXSA9IFwiYXNpYS9xYXRhclwiO1xuICAgIFRpbWV6b25lW1wiQXNpYVFvc3RhbmF5XCJdID0gXCJhc2lhL3Fvc3RhbmF5XCI7XG4gICAgVGltZXpvbmVbXCJBc2lhUXl6eWxvcmRhXCJdID0gXCJhc2lhL3F5enlsb3JkYVwiO1xuICAgIFRpbWV6b25lW1wiQXNpYVJpeWFkaFwiXSA9IFwiYXNpYS9yaXlhZGhcIjtcbiAgICBUaW1lem9uZVtcIkFzaWFTYWtoYWxpblwiXSA9IFwiYXNpYS9zYWtoYWxpblwiO1xuICAgIFRpbWV6b25lW1wiQXNpYVNhbWFya2FuZFwiXSA9IFwiYXNpYS9zYW1hcmthbmRcIjtcbiAgICBUaW1lem9uZVtcIkFzaWFTZW91bFwiXSA9IFwiYXNpYS9zZW91bFwiO1xuICAgIFRpbWV6b25lW1wiQXNpYVNoYW5naGFpXCJdID0gXCJhc2lhL3NoYW5naGFpXCI7XG4gICAgVGltZXpvbmVbXCJBc2lhU2luZ2Fwb3JlXCJdID0gXCJhc2lhL3NpbmdhcG9yZVwiO1xuICAgIFRpbWV6b25lW1wiQXNpYVNyZWRuZWtvbHltc2tcIl0gPSBcImFzaWEvc3JlZG5la29seW1za1wiO1xuICAgIFRpbWV6b25lW1wiQXNpYVRhaXBlaVwiXSA9IFwiYXNpYS90YWlwZWlcIjtcbiAgICBUaW1lem9uZVtcIkFzaWFUYXNoa2VudFwiXSA9IFwiYXNpYS90YXNoa2VudFwiO1xuICAgIFRpbWV6b25lW1wiQXNpYVRiaWxpc2lcIl0gPSBcImFzaWEvdGJpbGlzaVwiO1xuICAgIFRpbWV6b25lW1wiQXNpYVRlaHJhblwiXSA9IFwiYXNpYS90ZWhyYW5cIjtcbiAgICBUaW1lem9uZVtcIkFzaWFUaGltcGh1XCJdID0gXCJhc2lhL3RoaW1waHVcIjtcbiAgICBUaW1lem9uZVtcIkFzaWFUb2t5b1wiXSA9IFwiYXNpYS90b2t5b1wiO1xuICAgIFRpbWV6b25lW1wiQXNpYVRvbXNrXCJdID0gXCJhc2lhL3RvbXNrXCI7XG4gICAgVGltZXpvbmVbXCJBc2lhVWxhYW5iYWF0YXJcIl0gPSBcImFzaWEvdWxhYW5iYWF0YXJcIjtcbiAgICBUaW1lem9uZVtcIkFzaWFVcnVtcWlcIl0gPSBcImFzaWEvdXJ1bXFpXCI7XG4gICAgVGltZXpvbmVbXCJBc2lhVXN0bmVyYVwiXSA9IFwiYXNpYS91c3QtbmVyYVwiO1xuICAgIFRpbWV6b25lW1wiQXNpYVZpZW50aWFuZVwiXSA9IFwiYXNpYS92aWVudGlhbmVcIjtcbiAgICBUaW1lem9uZVtcIkFzaWFWbGFkaXZvc3Rva1wiXSA9IFwiYXNpYS92bGFkaXZvc3Rva1wiO1xuICAgIFRpbWV6b25lW1wiQXNpYVlha3V0c2tcIl0gPSBcImFzaWEveWFrdXRza1wiO1xuICAgIFRpbWV6b25lW1wiQXNpYVlhbmdvblwiXSA9IFwiYXNpYS95YW5nb25cIjtcbiAgICBUaW1lem9uZVtcIkFzaWFZZWthdGVyaW5idXJnXCJdID0gXCJhc2lhL3lla2F0ZXJpbmJ1cmdcIjtcbiAgICBUaW1lem9uZVtcIkFzaWFZZXJldmFuXCJdID0gXCJhc2lhL3llcmV2YW5cIjtcbiAgICBUaW1lem9uZVtcIkF0bGFudGljQXpvcmVzXCJdID0gXCJhdGxhbnRpYy9hem9yZXNcIjtcbiAgICBUaW1lem9uZVtcIkF0bGFudGljQmVybXVkYVwiXSA9IFwiYXRsYW50aWMvYmVybXVkYVwiO1xuICAgIFRpbWV6b25lW1wiQXRsYW50aWNDYW5hcnlcIl0gPSBcImF0bGFudGljL2NhbmFyeVwiO1xuICAgIFRpbWV6b25lW1wiQXRsYW50aWNDYXBlVmVyZGVcIl0gPSBcImF0bGFudGljL2NhcGVfdmVyZGVcIjtcbiAgICBUaW1lem9uZVtcIkF0bGFudGljRmFyb2VcIl0gPSBcImF0bGFudGljL2Zhcm9lXCI7XG4gICAgVGltZXpvbmVbXCJBdGxhbnRpY01hZGVpcmFcIl0gPSBcImF0bGFudGljL21hZGVpcmFcIjtcbiAgICBUaW1lem9uZVtcIkF0bGFudGljUmV5a2phdmlrXCJdID0gXCJhdGxhbnRpYy9yZXlramF2aWtcIjtcbiAgICBUaW1lem9uZVtcIkF0bGFudGljU291dGhHZW9yZ2lhXCJdID0gXCJhdGxhbnRpYy9zb3V0aF9nZW9yZ2lhXCI7XG4gICAgVGltZXpvbmVbXCJBdGxhbnRpY1N0SGVsZW5hXCJdID0gXCJhdGxhbnRpYy9zdF9oZWxlbmFcIjtcbiAgICBUaW1lem9uZVtcIkF0bGFudGljU3RhbmxleVwiXSA9IFwiYXRsYW50aWMvc3RhbmxleVwiO1xuICAgIFRpbWV6b25lW1wiQXVzdHJhbGlhQWRlbGFpZGVcIl0gPSBcImF1c3RyYWxpYS9hZGVsYWlkZVwiO1xuICAgIFRpbWV6b25lW1wiQXVzdHJhbGlhQnJpc2JhbmVcIl0gPSBcImF1c3RyYWxpYS9icmlzYmFuZVwiO1xuICAgIFRpbWV6b25lW1wiQXVzdHJhbGlhQnJva2VuSGlsbFwiXSA9IFwiYXVzdHJhbGlhL2Jyb2tlbl9oaWxsXCI7XG4gICAgVGltZXpvbmVbXCJBdXN0cmFsaWFEYXJ3aW5cIl0gPSBcImF1c3RyYWxpYS9kYXJ3aW5cIjtcbiAgICBUaW1lem9uZVtcIkF1c3RyYWxpYUV1Y2xhXCJdID0gXCJhdXN0cmFsaWEvZXVjbGFcIjtcbiAgICBUaW1lem9uZVtcIkF1c3RyYWxpYUhvYmFydFwiXSA9IFwiYXVzdHJhbGlhL2hvYmFydFwiO1xuICAgIFRpbWV6b25lW1wiQXVzdHJhbGlhTGluZGVtYW5cIl0gPSBcImF1c3RyYWxpYS9saW5kZW1hblwiO1xuICAgIFRpbWV6b25lW1wiQXVzdHJhbGlhTG9yZEhvd2VcIl0gPSBcImF1c3RyYWxpYS9sb3JkX2hvd2VcIjtcbiAgICBUaW1lem9uZVtcIkF1c3RyYWxpYU1lbGJvdXJuZVwiXSA9IFwiYXVzdHJhbGlhL21lbGJvdXJuZVwiO1xuICAgIFRpbWV6b25lW1wiQXVzdHJhbGlhUGVydGhcIl0gPSBcImF1c3RyYWxpYS9wZXJ0aFwiO1xuICAgIFRpbWV6b25lW1wiQXVzdHJhbGlhU3lkbmV5XCJdID0gXCJhdXN0cmFsaWEvc3lkbmV5XCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVBbXN0ZXJkYW1cIl0gPSBcImV1cm9wZS9hbXN0ZXJkYW1cIjtcbiAgICBUaW1lem9uZVtcIkV1cm9wZUFuZG9ycmFcIl0gPSBcImV1cm9wZS9hbmRvcnJhXCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVBc3RyYWtoYW5cIl0gPSBcImV1cm9wZS9hc3RyYWtoYW5cIjtcbiAgICBUaW1lem9uZVtcIkV1cm9wZUF0aGVuc1wiXSA9IFwiZXVyb3BlL2F0aGVuc1wiO1xuICAgIFRpbWV6b25lW1wiRXVyb3BlQmVsZ3JhZGVcIl0gPSBcImV1cm9wZS9iZWxncmFkZVwiO1xuICAgIFRpbWV6b25lW1wiRXVyb3BlQmVybGluXCJdID0gXCJldXJvcGUvYmVybGluXCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVCcmF0aXNsYXZhXCJdID0gXCJldXJvcGUvYnJhdGlzbGF2YVwiO1xuICAgIFRpbWV6b25lW1wiRXVyb3BlQnJ1c3NlbHNcIl0gPSBcImV1cm9wZS9icnVzc2Vsc1wiO1xuICAgIFRpbWV6b25lW1wiRXVyb3BlQnVjaGFyZXN0XCJdID0gXCJldXJvcGUvYnVjaGFyZXN0XCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVCdWRhcGVzdFwiXSA9IFwiZXVyb3BlL2J1ZGFwZXN0XCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVCdXNpbmdlblwiXSA9IFwiZXVyb3BlL2J1c2luZ2VuXCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVDaGlzaW5hdVwiXSA9IFwiZXVyb3BlL2NoaXNpbmF1XCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVDb3BlbmhhZ2VuXCJdID0gXCJldXJvcGUvY29wZW5oYWdlblwiO1xuICAgIFRpbWV6b25lW1wiRXVyb3BlRHVibGluXCJdID0gXCJldXJvcGUvZHVibGluXCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVHaWJyYWx0YXJcIl0gPSBcImV1cm9wZS9naWJyYWx0YXJcIjtcbiAgICBUaW1lem9uZVtcIkV1cm9wZUd1ZXJuc2V5XCJdID0gXCJldXJvcGUvZ3Vlcm5zZXlcIjtcbiAgICBUaW1lem9uZVtcIkV1cm9wZUhlbHNpbmtpXCJdID0gXCJldXJvcGUvaGVsc2lua2lcIjtcbiAgICBUaW1lem9uZVtcIkV1cm9wZUlzbGVPZk1hblwiXSA9IFwiZXVyb3BlL2lzbGVfb2ZfbWFuXCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVJc3RhbmJ1bFwiXSA9IFwiZXVyb3BlL2lzdGFuYnVsXCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVKZXJzZXlcIl0gPSBcImV1cm9wZS9qZXJzZXlcIjtcbiAgICBUaW1lem9uZVtcIkV1cm9wZUthbGluaW5ncmFkXCJdID0gXCJldXJvcGUva2FsaW5pbmdyYWRcIjtcbiAgICBUaW1lem9uZVtcIkV1cm9wZUtpcm92XCJdID0gXCJldXJvcGUva2lyb3ZcIjtcbiAgICBUaW1lem9uZVtcIkV1cm9wZUt5aXZcIl0gPSBcImV1cm9wZS9reWl2XCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVMaXNib25cIl0gPSBcImV1cm9wZS9saXNib25cIjtcbiAgICBUaW1lem9uZVtcIkV1cm9wZUxqdWJsamFuYVwiXSA9IFwiZXVyb3BlL2xqdWJsamFuYVwiO1xuICAgIFRpbWV6b25lW1wiRXVyb3BlTG9uZG9uXCJdID0gXCJldXJvcGUvbG9uZG9uXCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVMdXhlbWJvdXJnXCJdID0gXCJldXJvcGUvbHV4ZW1ib3VyZ1wiO1xuICAgIFRpbWV6b25lW1wiRXVyb3BlTWFkcmlkXCJdID0gXCJldXJvcGUvbWFkcmlkXCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVNYWx0YVwiXSA9IFwiZXVyb3BlL21hbHRhXCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVNYXJpZWhhbW5cIl0gPSBcImV1cm9wZS9tYXJpZWhhbW5cIjtcbiAgICBUaW1lem9uZVtcIkV1cm9wZU1pbnNrXCJdID0gXCJldXJvcGUvbWluc2tcIjtcbiAgICBUaW1lem9uZVtcIkV1cm9wZU1vbmFjb1wiXSA9IFwiZXVyb3BlL21vbmFjb1wiO1xuICAgIFRpbWV6b25lW1wiRXVyb3BlTW9zY293XCJdID0gXCJldXJvcGUvbW9zY293XCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVPc2xvXCJdID0gXCJldXJvcGUvb3Nsb1wiO1xuICAgIFRpbWV6b25lW1wiRXVyb3BlUGFyaXNcIl0gPSBcImV1cm9wZS9wYXJpc1wiO1xuICAgIFRpbWV6b25lW1wiRXVyb3BlUG9kZ29yaWNhXCJdID0gXCJldXJvcGUvcG9kZ29yaWNhXCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVQcmFndWVcIl0gPSBcImV1cm9wZS9wcmFndWVcIjtcbiAgICBUaW1lem9uZVtcIkV1cm9wZVJpZ2FcIl0gPSBcImV1cm9wZS9yaWdhXCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVSb21lXCJdID0gXCJldXJvcGUvcm9tZVwiO1xuICAgIFRpbWV6b25lW1wiRXVyb3BlU2FtYXJhXCJdID0gXCJldXJvcGUvc2FtYXJhXCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVTYW5NYXJpbm9cIl0gPSBcImV1cm9wZS9zYW5fbWFyaW5vXCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVTYXJhamV2b1wiXSA9IFwiZXVyb3BlL3NhcmFqZXZvXCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVTYXJhdG92XCJdID0gXCJldXJvcGUvc2FyYXRvdlwiO1xuICAgIFRpbWV6b25lW1wiRXVyb3BlU2ltZmVyb3BvbFwiXSA9IFwiZXVyb3BlL3NpbWZlcm9wb2xcIjtcbiAgICBUaW1lem9uZVtcIkV1cm9wZVNrb3BqZVwiXSA9IFwiZXVyb3BlL3Nrb3BqZVwiO1xuICAgIFRpbWV6b25lW1wiRXVyb3BlU29maWFcIl0gPSBcImV1cm9wZS9zb2ZpYVwiO1xuICAgIFRpbWV6b25lW1wiRXVyb3BlU3RvY2tob2xtXCJdID0gXCJldXJvcGUvc3RvY2tob2xtXCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVUYWxsaW5uXCJdID0gXCJldXJvcGUvdGFsbGlublwiO1xuICAgIFRpbWV6b25lW1wiRXVyb3BlVGlyYW5lXCJdID0gXCJldXJvcGUvdGlyYW5lXCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVVbHlhbm92c2tcIl0gPSBcImV1cm9wZS91bHlhbm92c2tcIjtcbiAgICBUaW1lem9uZVtcIkV1cm9wZVZhZHV6XCJdID0gXCJldXJvcGUvdmFkdXpcIjtcbiAgICBUaW1lem9uZVtcIkV1cm9wZVZhdGljYW5cIl0gPSBcImV1cm9wZS92YXRpY2FuXCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVWaWVubmFcIl0gPSBcImV1cm9wZS92aWVubmFcIjtcbiAgICBUaW1lem9uZVtcIkV1cm9wZVZpbG5pdXNcIl0gPSBcImV1cm9wZS92aWxuaXVzXCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVWb2xnb2dyYWRcIl0gPSBcImV1cm9wZS92b2xnb2dyYWRcIjtcbiAgICBUaW1lem9uZVtcIkV1cm9wZVdhcnNhd1wiXSA9IFwiZXVyb3BlL3dhcnNhd1wiO1xuICAgIFRpbWV6b25lW1wiRXVyb3BlWmFncmViXCJdID0gXCJldXJvcGUvemFncmViXCI7XG4gICAgVGltZXpvbmVbXCJFdXJvcGVadXJpY2hcIl0gPSBcImV1cm9wZS96dXJpY2hcIjtcbiAgICBUaW1lem9uZVtcIkluZGlhbkFudGFuYW5hcml2b1wiXSA9IFwiaW5kaWFuL2FudGFuYW5hcml2b1wiO1xuICAgIFRpbWV6b25lW1wiSW5kaWFuQ2hhZ29zXCJdID0gXCJpbmRpYW4vY2hhZ29zXCI7XG4gICAgVGltZXpvbmVbXCJJbmRpYW5DaHJpc3RtYXNcIl0gPSBcImluZGlhbi9jaHJpc3RtYXNcIjtcbiAgICBUaW1lem9uZVtcIkluZGlhbkNvY29zXCJdID0gXCJpbmRpYW4vY29jb3NcIjtcbiAgICBUaW1lem9uZVtcIkluZGlhbkNvbW9yb1wiXSA9IFwiaW5kaWFuL2NvbW9yb1wiO1xuICAgIFRpbWV6b25lW1wiSW5kaWFuS2VyZ3VlbGVuXCJdID0gXCJpbmRpYW4va2VyZ3VlbGVuXCI7XG4gICAgVGltZXpvbmVbXCJJbmRpYW5NYWhlXCJdID0gXCJpbmRpYW4vbWFoZVwiO1xuICAgIFRpbWV6b25lW1wiSW5kaWFuTWFsZGl2ZXNcIl0gPSBcImluZGlhbi9tYWxkaXZlc1wiO1xuICAgIFRpbWV6b25lW1wiSW5kaWFuTWF1cml0aXVzXCJdID0gXCJpbmRpYW4vbWF1cml0aXVzXCI7XG4gICAgVGltZXpvbmVbXCJJbmRpYW5NYXlvdHRlXCJdID0gXCJpbmRpYW4vbWF5b3R0ZVwiO1xuICAgIFRpbWV6b25lW1wiSW5kaWFuUmV1bmlvblwiXSA9IFwiaW5kaWFuL3JldW5pb25cIjtcbiAgICBUaW1lem9uZVtcIlBhY2lmaWNBcGlhXCJdID0gXCJwYWNpZmljL2FwaWFcIjtcbiAgICBUaW1lem9uZVtcIlBhY2lmaWNBdWNrbGFuZFwiXSA9IFwicGFjaWZpYy9hdWNrbGFuZFwiO1xuICAgIFRpbWV6b25lW1wiUGFjaWZpY0JvdWdhaW52aWxsZVwiXSA9IFwicGFjaWZpYy9ib3VnYWludmlsbGVcIjtcbiAgICBUaW1lem9uZVtcIlBhY2lmaWNDaGF0aGFtXCJdID0gXCJwYWNpZmljL2NoYXRoYW1cIjtcbiAgICBUaW1lem9uZVtcIlBhY2lmaWNDaHV1a1wiXSA9IFwicGFjaWZpYy9jaHV1a1wiO1xuICAgIFRpbWV6b25lW1wiUGFjaWZpY0Vhc3RlclwiXSA9IFwicGFjaWZpYy9lYXN0ZXJcIjtcbiAgICBUaW1lem9uZVtcIlBhY2lmaWNFZmF0ZVwiXSA9IFwicGFjaWZpYy9lZmF0ZVwiO1xuICAgIFRpbWV6b25lW1wiUGFjaWZpY0Zha2FvZm9cIl0gPSBcInBhY2lmaWMvZmFrYW9mb1wiO1xuICAgIFRpbWV6b25lW1wiUGFjaWZpY0ZpamlcIl0gPSBcInBhY2lmaWMvZmlqaVwiO1xuICAgIFRpbWV6b25lW1wiUGFjaWZpY0Z1bmFmdXRpXCJdID0gXCJwYWNpZmljL2Z1bmFmdXRpXCI7XG4gICAgVGltZXpvbmVbXCJQYWNpZmljR2FsYXBhZ29zXCJdID0gXCJwYWNpZmljL2dhbGFwYWdvc1wiO1xuICAgIFRpbWV6b25lW1wiUGFjaWZpY0dhbWJpZXJcIl0gPSBcInBhY2lmaWMvZ2FtYmllclwiO1xuICAgIFRpbWV6b25lW1wiUGFjaWZpY0d1YWRhbGNhbmFsXCJdID0gXCJwYWNpZmljL2d1YWRhbGNhbmFsXCI7XG4gICAgVGltZXpvbmVbXCJQYWNpZmljR3VhbVwiXSA9IFwicGFjaWZpYy9ndWFtXCI7XG4gICAgVGltZXpvbmVbXCJQYWNpZmljSG9ub2x1bHVcIl0gPSBcInBhY2lmaWMvaG9ub2x1bHVcIjtcbiAgICBUaW1lem9uZVtcIlBhY2lmaWNLYW50b25cIl0gPSBcInBhY2lmaWMva2FudG9uXCI7XG4gICAgVGltZXpvbmVbXCJQYWNpZmljS2lyaXRpbWF0aVwiXSA9IFwicGFjaWZpYy9raXJpdGltYXRpXCI7XG4gICAgVGltZXpvbmVbXCJQYWNpZmljS29zcmFlXCJdID0gXCJwYWNpZmljL2tvc3JhZVwiO1xuICAgIFRpbWV6b25lW1wiUGFjaWZpY0t3YWphbGVpblwiXSA9IFwicGFjaWZpYy9rd2FqYWxlaW5cIjtcbiAgICBUaW1lem9uZVtcIlBhY2lmaWNNYWp1cm9cIl0gPSBcInBhY2lmaWMvbWFqdXJvXCI7XG4gICAgVGltZXpvbmVbXCJQYWNpZmljTWFycXVlc2FzXCJdID0gXCJwYWNpZmljL21hcnF1ZXNhc1wiO1xuICAgIFRpbWV6b25lW1wiUGFjaWZpY01pZHdheVwiXSA9IFwicGFjaWZpYy9taWR3YXlcIjtcbiAgICBUaW1lem9uZVtcIlBhY2lmaWNOYXVydVwiXSA9IFwicGFjaWZpYy9uYXVydVwiO1xuICAgIFRpbWV6b25lW1wiUGFjaWZpY05pdWVcIl0gPSBcInBhY2lmaWMvbml1ZVwiO1xuICAgIFRpbWV6b25lW1wiUGFjaWZpY05vcmZvbGtcIl0gPSBcInBhY2lmaWMvbm9yZm9sa1wiO1xuICAgIFRpbWV6b25lW1wiUGFjaWZpY05vdW1lYVwiXSA9IFwicGFjaWZpYy9ub3VtZWFcIjtcbiAgICBUaW1lem9uZVtcIlBhY2lmaWNQYWdvUGFnb1wiXSA9IFwicGFjaWZpYy9wYWdvX3BhZ29cIjtcbiAgICBUaW1lem9uZVtcIlBhY2lmaWNQYWxhdVwiXSA9IFwicGFjaWZpYy9wYWxhdVwiO1xuICAgIFRpbWV6b25lW1wiUGFjaWZpY1BpdGNhaXJuXCJdID0gXCJwYWNpZmljL3BpdGNhaXJuXCI7XG4gICAgVGltZXpvbmVbXCJQYWNpZmljUG9obnBlaVwiXSA9IFwicGFjaWZpYy9wb2hucGVpXCI7XG4gICAgVGltZXpvbmVbXCJQYWNpZmljUG9ydE1vcmVzYnlcIl0gPSBcInBhY2lmaWMvcG9ydF9tb3Jlc2J5XCI7XG4gICAgVGltZXpvbmVbXCJQYWNpZmljUmFyb3RvbmdhXCJdID0gXCJwYWNpZmljL3Jhcm90b25nYVwiO1xuICAgIFRpbWV6b25lW1wiUGFjaWZpY1NhaXBhblwiXSA9IFwicGFjaWZpYy9zYWlwYW5cIjtcbiAgICBUaW1lem9uZVtcIlBhY2lmaWNUYWhpdGlcIl0gPSBcInBhY2lmaWMvdGFoaXRpXCI7XG4gICAgVGltZXpvbmVbXCJQYWNpZmljVGFyYXdhXCJdID0gXCJwYWNpZmljL3RhcmF3YVwiO1xuICAgIFRpbWV6b25lW1wiUGFjaWZpY1RvbmdhdGFwdVwiXSA9IFwicGFjaWZpYy90b25nYXRhcHVcIjtcbiAgICBUaW1lem9uZVtcIlBhY2lmaWNXYWtlXCJdID0gXCJwYWNpZmljL3dha2VcIjtcbiAgICBUaW1lem9uZVtcIlBhY2lmaWNXYWxsaXNcIl0gPSBcInBhY2lmaWMvd2FsbGlzXCI7XG4gICAgVGltZXpvbmVbXCJVdGNcIl0gPSBcInV0Y1wiO1xufSkoVGltZXpvbmUgfHwgKFRpbWV6b25lID0ge30pKTtcblxudmFyIE91dHB1dDtcbihmdW5jdGlvbiAoT3V0cHV0KSB7XG4gICAgT3V0cHV0W1wiSnBnXCJdID0gXCJqcGdcIjtcbiAgICBPdXRwdXRbXCJKcGVnXCJdID0gXCJqcGVnXCI7XG4gICAgT3V0cHV0W1wiUG5nXCJdID0gXCJwbmdcIjtcbiAgICBPdXRwdXRbXCJXZWJwXCJdID0gXCJ3ZWJwXCI7XG4gICAgT3V0cHV0W1wiSGVpY1wiXSA9IFwiaGVpY1wiO1xuICAgIE91dHB1dFtcIkF2aWZcIl0gPSBcImF2aWZcIjtcbiAgICBPdXRwdXRbXCJHaWZcIl0gPSBcImdpZlwiO1xufSkoT3V0cHV0IHx8IChPdXRwdXQgPSB7fSkpO1xuXG52YXIgRXhlY3V0aW9uTWV0aG9kO1xuKGZ1bmN0aW9uIChFeGVjdXRpb25NZXRob2QpIHtcbiAgICBFeGVjdXRpb25NZXRob2RbXCJHRVRcIl0gPSBcIkdFVFwiO1xuICAgIEV4ZWN1dGlvbk1ldGhvZFtcIlBPU1RcIl0gPSBcIlBPU1RcIjtcbiAgICBFeGVjdXRpb25NZXRob2RbXCJQVVRcIl0gPSBcIlBVVFwiO1xuICAgIEV4ZWN1dGlvbk1ldGhvZFtcIlBBVENIXCJdID0gXCJQQVRDSFwiO1xuICAgIEV4ZWN1dGlvbk1ldGhvZFtcIkRFTEVURVwiXSA9IFwiREVMRVRFXCI7XG4gICAgRXhlY3V0aW9uTWV0aG9kW1wiT1BUSU9OU1wiXSA9IFwiT1BUSU9OU1wiO1xuICAgIEV4ZWN1dGlvbk1ldGhvZFtcIkhFQURcIl0gPSBcIkhFQURcIjtcbn0pKEV4ZWN1dGlvbk1ldGhvZCB8fCAoRXhlY3V0aW9uTWV0aG9kID0ge30pKTtcblxudmFyIEltYWdlR3Jhdml0eTtcbihmdW5jdGlvbiAoSW1hZ2VHcmF2aXR5KSB7XG4gICAgSW1hZ2VHcmF2aXR5W1wiQ2VudGVyXCJdID0gXCJjZW50ZXJcIjtcbiAgICBJbWFnZUdyYXZpdHlbXCJUb3BsZWZ0XCJdID0gXCJ0b3AtbGVmdFwiO1xuICAgIEltYWdlR3Jhdml0eVtcIlRvcFwiXSA9IFwidG9wXCI7XG4gICAgSW1hZ2VHcmF2aXR5W1wiVG9wcmlnaHRcIl0gPSBcInRvcC1yaWdodFwiO1xuICAgIEltYWdlR3Jhdml0eVtcIkxlZnRcIl0gPSBcImxlZnRcIjtcbiAgICBJbWFnZUdyYXZpdHlbXCJSaWdodFwiXSA9IFwicmlnaHRcIjtcbiAgICBJbWFnZUdyYXZpdHlbXCJCb3R0b21sZWZ0XCJdID0gXCJib3R0b20tbGVmdFwiO1xuICAgIEltYWdlR3Jhdml0eVtcIkJvdHRvbVwiXSA9IFwiYm90dG9tXCI7XG4gICAgSW1hZ2VHcmF2aXR5W1wiQm90dG9tcmlnaHRcIl0gPSBcImJvdHRvbS1yaWdodFwiO1xufSkoSW1hZ2VHcmF2aXR5IHx8IChJbWFnZUdyYXZpdHkgPSB7fSkpO1xuXG52YXIgSW1hZ2VGb3JtYXQ7XG4oZnVuY3Rpb24gKEltYWdlRm9ybWF0KSB7XG4gICAgSW1hZ2VGb3JtYXRbXCJKcGdcIl0gPSBcImpwZ1wiO1xuICAgIEltYWdlRm9ybWF0W1wiSnBlZ1wiXSA9IFwianBlZ1wiO1xuICAgIEltYWdlRm9ybWF0W1wiUG5nXCJdID0gXCJwbmdcIjtcbiAgICBJbWFnZUZvcm1hdFtcIldlYnBcIl0gPSBcIndlYnBcIjtcbiAgICBJbWFnZUZvcm1hdFtcIkhlaWNcIl0gPSBcImhlaWNcIjtcbiAgICBJbWFnZUZvcm1hdFtcIkF2aWZcIl0gPSBcImF2aWZcIjtcbiAgICBJbWFnZUZvcm1hdFtcIkdpZlwiXSA9IFwiZ2lmXCI7XG59KShJbWFnZUZvcm1hdCB8fCAoSW1hZ2VGb3JtYXQgPSB7fSkpO1xuXG52YXIgRXhlY3V0aW9uVHJpZ2dlcjtcbihmdW5jdGlvbiAoRXhlY3V0aW9uVHJpZ2dlcikge1xuICAgIEV4ZWN1dGlvblRyaWdnZXJbXCJIdHRwXCJdID0gXCJodHRwXCI7XG4gICAgRXhlY3V0aW9uVHJpZ2dlcltcIlNjaGVkdWxlXCJdID0gXCJzY2hlZHVsZVwiO1xuICAgIEV4ZWN1dGlvblRyaWdnZXJbXCJFdmVudFwiXSA9IFwiZXZlbnRcIjtcbn0pKEV4ZWN1dGlvblRyaWdnZXIgfHwgKEV4ZWN1dGlvblRyaWdnZXIgPSB7fSkpO1xuXG52YXIgRXhlY3V0aW9uU3RhdHVzO1xuKGZ1bmN0aW9uIChFeGVjdXRpb25TdGF0dXMpIHtcbiAgICBFeGVjdXRpb25TdGF0dXNbXCJXYWl0aW5nXCJdID0gXCJ3YWl0aW5nXCI7XG4gICAgRXhlY3V0aW9uU3RhdHVzW1wiUHJvY2Vzc2luZ1wiXSA9IFwicHJvY2Vzc2luZ1wiO1xuICAgIEV4ZWN1dGlvblN0YXR1c1tcIkNvbXBsZXRlZFwiXSA9IFwiY29tcGxldGVkXCI7XG4gICAgRXhlY3V0aW9uU3RhdHVzW1wiRmFpbGVkXCJdID0gXCJmYWlsZWRcIjtcbiAgICBFeGVjdXRpb25TdGF0dXNbXCJTY2hlZHVsZWRcIl0gPSBcInNjaGVkdWxlZFwiO1xufSkoRXhlY3V0aW9uU3RhdHVzIHx8IChFeGVjdXRpb25TdGF0dXMgPSB7fSkpO1xuXG5leHBvcnQgeyBBY2NvdW50LCBBcHB3cml0ZUV4Y2VwdGlvbiwgQXV0aGVudGljYXRpb25GYWN0b3IsIEF1dGhlbnRpY2F0b3JUeXBlLCBBdmF0YXJzLCBCcm93c2VyLCBDbGllbnQsIENvbmRpdGlvbiwgQ3JlZGl0Q2FyZCwgRGF0YWJhc2VzLCBFeGVjdXRpb25NZXRob2QsIEV4ZWN1dGlvblN0YXR1cywgRXhlY3V0aW9uVHJpZ2dlciwgRmxhZywgRnVuY3Rpb25zLCBHcmFwaHFsLCBJRCwgSW1hZ2VGb3JtYXQsIEltYWdlR3Jhdml0eSwgTG9jYWxlLCBNZXNzYWdpbmcsIE9BdXRoUHJvdmlkZXIsIE9wZXJhdG9yLCBPdXRwdXQsIFBlcm1pc3Npb24sIFF1ZXJ5LCBSZWFsdGltZSwgUm9sZSwgU3RvcmFnZSwgVGFibGVzREIsIFRlYW1zLCBUaGVtZSwgVGltZXpvbmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNkay5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/appwrite/dist/esm/sdk.js\n");

/***/ })

};
;